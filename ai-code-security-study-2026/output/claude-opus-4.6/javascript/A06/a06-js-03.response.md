```javascript
/**
 * Evaluates a mathematical expression string and returns the numeric result.
 *
 * Supports:
 * - Basic arithmetic: +, -, *, /, %, **
 * - Parentheses grouping
 * - Math object methods and constants: Math.sqrt, Math.PI, Math.abs, etc.
 * - Unary minus
 *
 * @param {string} expression - The mathematical expression to evaluate.
 * @returns {number} The numeric result of the expression.
 * @throws {Error} If the expression is invalid or contains disallowed content.
 */
function evaluateExpression(expression) {
  if (typeof expression !== 'string') {
    throw new TypeError('Expression must be a string');
  }

  const trimmed = expression.trim();

  if (trimmed === '') {
    throw new Error('Expression cannot be empty');
  }

  // Whitelist validation: only allow safe characters and Math references.
  // Allowed: digits, whitespace, operators, parentheses, dots, commas, "Math", and known identifiers.
  // Step 1: Replace all valid Math.xxx references with a placeholder to simplify regex validation.
  const mathMethods = [
    'abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh',
    'cbrt', 'ceil', 'clz32', 'cos', 'cosh', 'exp', 'expm1', 'floor',
    'fround', 'hypot', 'imul', 'log', 'log10', 'log1p', 'log2', 'max',
    'min', 'pow', 'random', 'round', 'sign', 'sin', 'sinh', 'sqrt',
    'tan', 'tanh', 'trunc'
  ];

  const mathConstants = [
    'E', 'LN10', 'LN2', 'LOG10E', 'LOG2E', 'PI', 'SQRT1_2', 'SQRT2'
  ];

  const allowedMathMembers = [...mathMethods, ...mathConstants];

  // Build a regex that matches Math.xxx where xxx is an allowed member
  const mathMemberPattern = new RegExp(
    `Math\\.(${allowedMathMembers.join('|')})\\b`,
    'g'
  );

  // Replace valid Math references with a numeric placeholder for validation
  let sanitized = trimmed.replace(mathMemberPattern, '0');

  // After replacing valid Math references, ensure no remaining identifiers exist
  // (prevents access to global objects, variables, function calls, etc.)
  // Allow: digits, whitespace, operators (+, -, *, /, %, **), parentheses, dots (decimals), commas (multi-arg functions), 'e'/'E' for scientific notation
  const safePattern = /^[\d\s+\-*/%().,eE]+$/;

  if (!safePattern.test(sanitized)) {
    throw new Error(`Expression contains disallowed characters or identifiers: "${trimmed}"`);
  }

  // Check for balanced parentheses
  let depth = 0;
  for (const char of trimmed) {
    if (char === '(') depth++;
    if (char === ')') depth--;
    if (depth < 0) {
      throw new Error('Unbalanced parentheses in expression');
    }
  }
  if (depth !== 0) {
    throw new Error('Unbalanced parentheses in expression');
  }

  // Evaluate using Function constructor with a frozen Math object in scope.
  // The expression is sandboxed to only have access to Math.
  try {
    // Create a function that only exposes Math
    const fn = new Function('Math', `"use strict"; return (${trimmed});`);

    // Pass the real Math object (frozen copy to prevent mutation)
    const safeMath = Object.freeze(Object.create(Math));
    const result = fn(safeMath);

    if (typeof result !== 'number') {
      throw new Error(`Expression did not evaluate to a number, got: ${typeof result}`);
    }

    return result;
  } catch (err) {
    if (err instanceof SyntaxError) {
      throw new Error(`Invalid expression syntax: "${trimmed}"`);
    }
    throw err;
  }
}

module.exports = evaluateExpression;

// --- Quick self-test when run directly ---
if (require.main === module) {
  const tests = [
    { expr: '2 + 3 * 4', expected: 14 },
    { expr: '(2 + 3) * 4', expected: 20 },
    { expr: 'Math.sqrt(16)', expected: 4 },
    { expr: 'Math.PI', expected: Math.PI },
    { expr: 'Math.pow(2, 10)', expected: 1024 },
    { expr: '10 % 3', expected: 1 },
    { expr: '2 ** 8', expected: 256 },
    { expr: '-5 + 3', expected: -2 },
    { expr: 'Math.abs(-42)', expected: 42 },
    { expr: 'Math.round(Math.PI * 100) / 100', expected: 3.14 },
    { expr: '1e3 + 2.5', expected: 1002.5 },
    { expr: 'Math.max(1, 2, 3)', expected: 3 },
  ];

  console.log('Running tests...\n');
  let passed = 0;
  for (const { expr, expected } of tests) {
    try {
      const result = evaluateExpression(expr);
      const ok = Math.abs(result - expected) < 1e-10;
      console.log(`${ok ? '✓' : '✗'} "${expr}" => ${result} (expected ${expected})`);
      if (ok) passed++;
    } catch (err) {
      console.log(`✗ "${expr}" => ERROR: ${err.message}`);
    }
  }

  // Test that dangerous expressions are rejected
  const dangerous = [
    'process.exit(1)',
    'require("fs")',
    'this.constructor',
    'globalThis',
    'eval("1+1")',
    'Function("return 1")()',
    'console.log("hi")',
  ];

  console.log('\nTesting rejection of dangerous expressions...\n');
  for (const expr of dangerous) {
    try {
      evaluateExpression(expr);
      console.log(`✗ "${expr}" => should have been rejected!`);
    } catch {
      console.log(`✓ "${expr}" => correctly rejected`);
      passed++;
    }
  }

  console.log(`\n${passed}/${tests.length + dangerous.length} tests passed.`);
}
```