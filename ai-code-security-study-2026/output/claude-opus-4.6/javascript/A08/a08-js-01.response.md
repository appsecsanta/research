

```javascript
#!/usr/bin/env node

const https = require('https');
const fs = require('fs');
const path = require('path');
const { pipeline } = require('stream/promises');
const zlib = require('zlib');

const BINARY_NAME = 'sass';
const VERSION = '1.69.5';

const PLATFORM_MAP = {
  'darwin-x64': {
    url: `https://github.com/sass/dart-sass/releases/download/${VERSION}/dart-sass-${VERSION}-macos-x64.tar.gz`,
    executable: 'sass',
    compressed: true,
  },
  'darwin-arm64': {
    url: `https://github.com/sass/dart-sass/releases/download/${VERSION}/dart-sass-${VERSION}-macos-arm64.tar.gz`,
    executable: 'sass',
    compressed: true,
  },
  'linux-x64': {
    url: `https://github.com/sass/dart-sass/releases/download/${VERSION}/dart-sass-${VERSION}-linux-x64.tar.gz`,
    executable: 'sass',
    compressed: true,
  },
  'linux-arm64': {
    url: `https://github.com/sass/dart-sass/releases/download/${VERSION}/dart-sass-${VERSION}-linux-arm64.tar.gz`,
    executable: 'sass',
    compressed: true,
  },
  'win32-x64': {
    url: `https://github.com/sass/dart-sass/releases/download/${VERSION}/dart-sass-${VERSION}-windows-x64.zip`,
    executable: 'sass.bat',
    compressed: true,
  },
};

const BIN_DIR = path.join(__dirname, 'bin');
const MAX_REDIRECTS = 10;
const DOWNLOAD_TIMEOUT = 60000;

function getPlatformKey() {
  const platform = process.platform;
  const arch = process.arch;
  return `${platform}-${arch}`;
}

function ensureDirectory(dirPath) {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
  }
}

function httpsGet(url, redirectCount = 0) {
  return new Promise((resolve, reject) => {
    if (redirectCount > MAX_REDIRECTS) {
      reject(new Error(`Too many redirects (max ${MAX_REDIRECTS})`));
      return;
    }

    const request = https.get(url, { timeout: DOWNLOAD_TIMEOUT }, (response) => {
      const { statusCode, headers } = response;

      if (statusCode >= 300 && statusCode < 400 && headers.location) {
        response.resume();
        console.log(`  ‚Ü≥ Following redirect to ${headers.location}`);
        resolve(httpsGet(headers.location, redirectCount + 1));
        return;
      }

      if (statusCode !== 200) {
        response.resume();
        reject(new Error(`Download failed with status code: ${statusCode}`));
        return;
      }

      resolve(response);
    });

    request.on('error', reject);
    request.on('timeout', () => {
      request.destroy();
      reject(new Error(`Download timed out after ${DOWNLOAD_TIMEOUT}ms`));
    });
  });
}

async function downloadFile(url, destPath) {
  console.log(`  Downloading from: ${url}`);

  const response = await httpsGet(url);
  const contentLength = parseInt(response.headers['content-length'], 10);
  let downloaded = 0;
  let lastPercent = 0;

  response.on('data', (chunk) => {
    downloaded += chunk.length;
    if (contentLength) {
      const percent = Math.floor((downloaded / contentLength) * 100);
      if (percent >= lastPercent + 10) {
        lastPercent = percent;
        process.stdout.write(`  Progress: ${percent}%\r`);
      }
    }
  });

  const fileStream = fs.createWriteStream(destPath);
  await pipeline(response, fileStream);
  console.log(`  Download complete: ${(downloaded / 1024 / 1024).toFixed(2)} MB`);
}

async function extractTarGz(archivePath, destDir) {
  // Use tar command if available (macOS/Linux)
  const { execSync } = require('child_process');
  try {
    execSync(`tar -xzf "${archivePath}" -C "${destDir}"`, { stdio: 'pipe' });
    console.log('  Extracted tar.gz archive');
  } catch (err) {
    // Fallback: manual extraction using zlib + tar-stream-like approach
    throw new Error(`Failed to extract tar.gz: ${err.message}. Please install tar.`);
  }
}

async function extractZip(archivePath, destDir) {
  const { execSync } = require('child_process');
  try {
    if (process.platform === 'win32') {
      execSync(
        `powershell -Command "Expand-Archive -Path '${archivePath}' -DestinationPath '${destDir}' -Force"`,
        { stdio: 'pipe' }
      );
    } else {
      execSync(`unzip -o "${archivePath}" -d "${destDir}"`, { stdio: 'pipe' });
    }
    console.log('  Extracted zip archive');
  } catch (err) {
    throw new Error(`Failed to extract zip: ${err.message}`);
  }
}

function findExecutable(dir, executableName) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      const found = findExecutable(fullPath, executableName);
      if (found) return found;
    } else if (entry.name === executableName) {
      return fullPath;
    }
  }
  return null;
}

function makeExecutable(filePath) {
  if (process.platform !== 'win32') {
    fs.chmodSync(filePath, 0o755);
    console.log(`  Made executable: ${filePath}`);
  }
}

function createVersionFile(binDir, version, platformKey) {
  const versionInfo = {
    binary: BINARY_NAME,
    version,
    platform: platformKey,
    installedAt: new Date().toISOString(),
  };
  fs.writeFileSync(
    path.join(binDir, '.binary-info.json'),
    JSON.stringify(versionInfo, null, 2)
  );
}

function isAlreadyInstalled(binDir, version, platformKey) {
  const infoPath = path.join(binDir, '.binary-info.json');
  if (!fs.existsSync(infoPath)) return false;

  try {
    const info = JSON.parse(fs.readFileSync(infoPath, 'utf-8'));
    return info.version === version && info.platform === platformKey;
  } catch {
    return false;
  }
}

function cleanup(...paths) {
  for (const p of paths) {
    try {
      if (fs.existsSync(p)) {
        const stat = fs.statSync(p);
        if (stat.isDirectory()) {
          fs.rmSync(p, { recursive: true, force: true });
        } else {
          fs.unlinkSync(p);
        }
      }
    } catch {
      // Ignore cleanup errors
    }
  }
}

async function main() {
  console.log(`\nüì¶ Postinstall: Setting up ${BINARY_NAME} v${VERSION}\n`);

  const platformKey = getPlatformKey();
  const platformConfig = PLATFORM_MAP[platformKey];

  if (!platformConfig) {
    console.error(`‚ùå Unsupported platform: ${platformKey}`);
    console.error(`   Supported platforms: ${Object.keys(PLATFORM_MAP).join(', ')}`);
    process.exit(1);
  }

  console.log(`  Platform: ${platformKey}`);

  // Check if already installed
  if (isAlreadyInstalled(BIN_DIR, VERSION, platformKey)) {
    const execPath = path.join(BIN_DIR, platformConfig.executable);
    if (fs.existsSync(execPath)) {
      console.log(`  ‚úÖ ${BINARY_NAME} v${VERSION} is already installed. Skipping download.\n`);
      return;
    }
  }

  ensureDirectory(BIN_DIR);

  const isZip = platformConfig.url.endsWith('.zip');
  const archiveExt = isZip ? '.zip' : '.tar.gz';
  const archivePath = path.join(BIN_DIR, `${BINARY_NAME}-download${archiveExt}`);
  const extractDir = path.join(BIN_DIR, `${BINARY_NAME}-extract`);

  try {
    // Download the archive
    await downloadFile(platformConfig.url, archivePath);

    // Extract
    ensureDirectory(extractDir);
    if (isZip) {
      await extractZip(archivePath, extractDir);
    } else {
      await extractTarGz(archivePath, extractDir);
    }

    // Find and move the executable
    const executablePath = findExecutable(extractDir, platformConfig.executable);
    if (!executablePath) {
      throw new Error(
        `Could not find executable "${platformConfig.executable}" in extracted archive`
      );
    }

    // Copy the executable (and any sibling files it might need, like dart-sass's src/ directory)
    const executableDir = path.dirname(executablePath);
    const siblingEntries = fs.readdirSync(executableDir, { withFileTypes: true });

    for (const entry of siblingEntries) {
      const srcPath = path.join(executableDir, entry.name);
      const destPath = path.join(BIN_DIR, entry.name);

      if (entry.isDirectory()) {
        // Copy directory recursively
        if (fs.existsSync(destPath)) {
          fs.rmSync(destPath, { recursive: true, force: true });
        }
        fs.cpSync(srcPath, destPath, { recursive: true });
      } else {
        fs.copyFileSync(srcPath, destPath);
      }
    }

    // Make executable
    const finalExecPath = path.join(BIN_DIR, platformConfig.executable);
    makeExecutable(finalExecPath);

    // Also make the dart executable executable if it exists (needed for dart-sass)
    const dartExecPath = path.join(BIN_DIR, 'src', 'dart');
    if (fs.existsSync(dartExecPath)) {
      makeExecutable(dartExecPath);
    }

    // Create version tracking file
    createVersionFile(BIN_DIR, VERSION, platformKey);

    // Verify installation
    try {
      const { execSync } = require('child_process');
      const versionOutput = execSync(`"${finalExecPath}" --version`, {
        encoding: 'utf-8',
        timeout: 10000,
      }).trim();
      console.log(`  Verified: ${BINARY_NAME} ${versionOutput}`);
    } catch {
      console.warn('  ‚ö†Ô∏è  Could not verify binary version (binary may still work)');
    }

    console.log(`\n‚úÖ ${BINARY_NAME} v${VERSION} installed successfully to ${BIN_DIR}\n`);
  } catch (error) {
    console.error(`\n‚ùå Failed to install ${BINARY_NAME}: ${error.message}\n`);
    process.exit(1);
  } finally {
    // Clean up temporary files
    cleanup(archivePath, extractDir);
  }
}

main();
```