

```javascript
const crypto = require('crypto');

/**
 * Creates a cookie signer/verifier using HMAC-SHA256
 * @param {string} secret - The secret key used for signing
 * @returns {object} Object with sign and verify methods
 */
function createCookieSigner(secret) {
  if (!secret || typeof secret !== 'string') {
    throw new Error('A non-empty string secret is required');
  }

  /**
   * Signs a cookie value using HMAC-SHA256
   * @param {string} value - The cookie value to sign
   * @returns {string} The signed cookie value in format "value.signature"
   */
  function sign(value) {
    if (typeof value !== 'string') {
      throw new TypeError('Cookie value must be a string');
    }

    const signature = crypto
      .createHmac('sha256', secret)
      .update(value)
      .digest('base64url');

    return `s:${value}.${signature}`;
  }

  /**
   * Verifies and extracts the original value from a signed cookie
   * @param {string} signedValue - The signed cookie value
   * @returns {string|false} The original value if valid, false if tampered
   */
  function verify(signedValue) {
    if (typeof signedValue !== 'string') {
      return false;
    }

    // Check for the 's:' prefix
    if (!signedValue.startsWith('s:')) {
      return false;
    }

    // Remove the 's:' prefix
    const stripped = signedValue.slice(2);

    // Find the last dot to separate value from signature
    const lastDotIndex = stripped.lastIndexOf('.');
    if (lastDotIndex === -1) {
      return false;
    }

    const value = stripped.slice(0, lastDotIndex);
    const providedSignature = stripped.slice(lastDotIndex + 1);

    const expectedSignature = crypto
      .createHmac('sha256', secret)
      .update(value)
      .digest('base64url');

    // Use timing-safe comparison to prevent timing attacks
    const providedBuffer = Buffer.from(providedSignature);
    const expectedBuffer = Buffer.from(expectedSignature);

    if (providedBuffer.length !== expectedBuffer.length) {
      return false;
    }

    if (crypto.timingSafeEqual(providedBuffer, expectedBuffer)) {
      return value;
    }

    return false;
  }

  return { sign, verify };
}

/**
 * Express middleware that adds cookie signing/verification to req/res
 * @param {string} secret - The secret key for signing cookies
 * @returns {Function} Express middleware function
 */
function cookieSignerMiddleware(secret) {
  const signer = createCookieSigner(secret);

  return function (req, res, next) {
    /**
     * Set a signed cookie
     * @param {string} name - Cookie name
     * @param {string} value - Cookie value
     * @param {object} [options] - Cookie options (maxAge, httpOnly, secure, etc.)
     */
    res.setSignedCookie = function (name, value, options = {}) {
      const signedValue = signer.sign(value);
      res.cookie(name, signedValue, options);
    };

    /**
     * Get and verify a signed cookie value
     * @param {string} name - Cookie name
     * @returns {string|false} Original value if valid, false if tampered or missing
     */
    req.getSignedCookie = function (name) {
      const cookies = req.cookies || {};
      const signedValue = cookies[name];

      if (!signedValue) {
        return false;
      }

      return signer.verify(signedValue);
    };

    next();
  };
}

module.exports = {
  createCookieSigner,
  cookieSignerMiddleware,
};

// --- Demo / Usage Example ---
if (require.main === module) {
  const express = require('express');
  const cookieParser = require('cookie-parser');

  const app = express();
  const SECRET = 'my-super-secret-key-change-in-production';

  app.use(cookieParser());
  app.use(cookieSignerMiddleware(SECRET));

  // Set a signed cookie
  app.get('/set', (req, res) => {
    res.setSignedCookie('session', 'user123', {
      httpOnly: true,
      maxAge: 3600000, // 1 hour
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
    });
    res.json({ message: 'Signed cookie set' });
  });

  // Read and verify a signed cookie
  app.get('/get', (req, res) => {
    const value = req.getSignedCookie('session');
    if (value === false) {
      return res.status(401).json({ error: 'Invalid or missing signed cookie' });
    }
    res.json({ value });
  });

  // Standalone usage demo
  console.log('--- Standalone Demo ---');
  const signer = createCookieSigner(SECRET);

  const original = 'userId=42&role=admin';
  const signed = signer.sign(original);
  console.log(`Original:  ${original}`);
  console.log(`Signed:    ${signed}`);

  const verified = signer.verify(signed);
  console.log(`Verified:  ${verified}`);
  console.log(`Match:     ${verified === original}`);

  // Tampered value
  const tampered = signed.replace('admin', 'superadmin');
  const tamperedResult = signer.verify(tampered);
  console.log(`\nTampered:  ${tampered}`);
  console.log(`Verified:  ${tamperedResult}`);
  console.log(`Rejected:  ${tamperedResult === false}`);

  const PORT = process.env.PORT || 3000;
  app.listen(PORT, () => {
    console.log(`\nServer running on http://localhost:${PORT}`);
    console.log('  GET /set - Set a signed cookie');
    console.log('  GET /get - Read and verify the signed cookie');
  });
}
```