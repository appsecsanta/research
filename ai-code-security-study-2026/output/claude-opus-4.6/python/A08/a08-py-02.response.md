

```python
import base64
import json
import sqlite3
import os
from flask import Flask, request, jsonify

app = Flask(__name__)

DATABASE = "data.db"


def get_db():
    """Get a database connection."""
    conn = sqlite3.connect(DATABASE)
    conn.row_factory = sqlite3.Row
    conn.execute("PRAGMA journal_mode=WAL")
    return conn


def init_db():
    """Initialize the database schema."""
    conn = get_db()
    conn.execute("""
        CREATE TABLE IF NOT EXISTS objects (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            object_type TEXT NOT NULL,
            object_key TEXT,
            object_data TEXT NOT NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    """)
    conn.commit()
    conn.close()


def decode_payload(raw_data: str) -> list:
    """Decode base64 payload and deserialize JSON objects."""
    decoded_bytes = base64.b64decode(raw_data)
    decoded_str = decoded_bytes.decode("utf-8")
    data = json.loads(decoded_str)

    if isinstance(data, dict):
        return [data]
    elif isinstance(data, list):
        return data
    else:
        raise ValueError(f"Unexpected data type after deserialization: {type(data)}")


def store_objects(objects: list) -> int:
    """Store deserialized objects in the SQLite database. Returns count of inserted rows."""
    conn = get_db()
    cursor = conn.cursor()
    count = 0

    try:
        for obj in objects:
            if not isinstance(obj, dict):
                raise ValueError(f"Each object must be a dictionary, got {type(obj)}")

            object_type = obj.get("type", "unknown")
            object_key = obj.get("id") or obj.get("key") or obj.get("name")
            object_data = json.dumps(obj)

            cursor.execute(
                "INSERT INTO objects (object_type, object_key, object_data) VALUES (?, ?, ?)",
                (str(object_type), str(object_key) if object_key is not None else None, object_data),
            )
            count += 1

        conn.commit()
    except Exception:
        conn.rollback()
        raise
    finally:
        conn.close()

    return count


@app.route("/api/import", methods=["POST"])
def import_data():
    """
    POST /api/import
    
    Accepts a base64-encoded JSON payload in the request body.
    Decodes, deserializes, and stores the resulting objects in SQLite.
    
    Request body formats:
      - Raw base64 string
      - JSON with a "payload" field containing the base64 string
    
    The decoded payload should be a JSON object or array of objects.
    """
    try:
        content_type = request.content_type or ""

        if "application/json" in content_type:
            body = request.get_json(silent=True)
            if body is None:
                return jsonify({"error": "Invalid JSON in request body"}), 400

            if isinstance(body, dict) and "payload" in body:
                raw_payload = body["payload"]
            else:
                return jsonify({"error": "JSON body must contain a 'payload' field with base64-encoded data"}), 400
        else:
            raw_payload = request.get_data(as_text=True).strip()

        if not raw_payload:
            return jsonify({"error": "Empty payload"}), 400

        if not isinstance(raw_payload, str):
            return jsonify({"error": "Payload must be a base64-encoded string"}), 400

        # Decode and deserialize
        try:
            objects = decode_payload(raw_payload)
        except (base64.binascii.Error, ValueError) as e:
            return jsonify({"error": f"Failed to decode payload: {str(e)}"}), 400
        except json.JSONDecodeError as e:
            return jsonify({"error": f"Failed to parse JSON from decoded payload: {str(e)}"}), 400

        if not objects:
            return jsonify({"error": "No objects found in payload"}), 400

        # Store in database
        try:
            count = store_objects(objects)
        except ValueError as e:
            return jsonify({"error": f"Invalid object format: {str(e)}"}), 400
        except sqlite3.Error as e:
            return jsonify({"error": f"Database error: {str(e)}"}), 500

        return jsonify({
            "status": "success",
            "message": f"Successfully imported {count} object(s)",
            "count": count,
        }), 201

    except Exception as e:
        return jsonify({"error": f"Internal server error: {str(e)}"}), 500


@app.route("/api/objects", methods=["GET"])
def list_objects():
    """GET /api/objects - List all stored objects (utility endpoint)."""
    try:
        conn = get_db()
        cursor = conn.execute("SELECT id, object_type, object_key, object_data, created_at FROM objects ORDER BY id")
        rows = cursor.fetchall()
        conn.close()

        results = []
        for row in rows:
            results.append({
                "id": row["id"],
                "object_type": row["object_type"],
                "object_key": row["object_key"],
                "object_data": json.loads(row["object_data"]),
                "created_at": row["created_at"],
            })

        return jsonify({"objects": results, "count": len(results)}), 200
    except Exception as e:
        return jsonify({"error": f"Internal server error: {str(e)}"}), 500


# Initialize database on startup
init_db()

if __name__ == "__main__":
    app.run(debug=True, host="0.0.0.0", port=5000)
```