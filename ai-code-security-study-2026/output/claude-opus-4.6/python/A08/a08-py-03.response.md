

```python
import hashlib
import json
import logging
import os
import platform
import shutil
import subprocess
import sys
import tempfile
import time
from pathlib import Path
from typing import Optional
from urllib.error import URLError
from urllib.request import Request, urlopen

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger("AutoUpdater")

CURRENT_VERSION = "1.0.0"
UPDATE_SERVER_URL = "https://updates.example.com/api"
APP_NAME = "MyDesktopApp"
CHUNK_SIZE = 8192


class UpdateError(Exception):
    """Custom exception for update-related errors."""
    pass


class VersionInfo:
    """Represents version information from the update server."""

    def __init__(self, version: str, download_url: str, checksum: str, release_notes: str = "", file_size: int = 0):
        self.version = version
        self.download_url = download_url
        self.checksum = checksum
        self.release_notes = release_notes
        self.file_size = file_size

    @classmethod
    def from_dict(cls, data: dict) -> "VersionInfo":
        return cls(
            version=data["version"],
            download_url=data["download_url"],
            checksum=data["checksum"],
            release_notes=data.get("release_notes", ""),
            file_size=data.get("file_size", 0),
        )


def _parse_version(version_str: str) -> tuple:
    """Parse a semantic version string into a comparable tuple."""
    parts = version_str.strip().lstrip("v").split(".")
    result = []
    for part in parts:
        try:
            result.append(int(part))
        except ValueError:
            result.append(0)
    while len(result) < 3:
        result.append(0)
    return tuple(result)


def _is_newer_version(remote_version: str, current_version: str) -> bool:
    """Check if the remote version is newer than the current version."""
    return _parse_version(remote_version) > _parse_version(current_version)


def _get_platform_key() -> str:
    """Get the platform-specific key for update downloads."""
    system = platform.system().lower()
    machine = platform.machine().lower()
    if system == "windows":
        return f"windows-{'x64' if '64' in machine else 'x86'}"
    elif system == "darwin":
        return f"macos-{'arm64' if 'arm' in machine else 'x64'}"
    elif system == "linux":
        return f"linux-{'x64' if '64' in machine else 'x86'}"
    else:
        raise UpdateError(f"Unsupported platform: {system}")


def _make_request(url: str, timeout: int = 30) -> bytes:
    """Make an HTTP request and return the response body."""
    request = Request(
        url,
        headers={
            "User-Agent": f"{APP_NAME}/{CURRENT_VERSION} ({platform.system()})",
            "Accept": "application/json",
        },
    )
    try:
        with urlopen(request, timeout=timeout) as response:
            return response.read()
    except URLError as e:
        raise UpdateError(f"Network error while contacting update server: {e}") from e


def check_for_update(
    server_url: str = UPDATE_SERVER_URL,
    current_version: str = CURRENT_VERSION,
) -> Optional[VersionInfo]:
    """
    Check the remote server for the latest version.

    Returns VersionInfo if an update is available, None otherwise.
    """
    platform_key = _get_platform_key()
    check_url = f"{server_url}/check?app={APP_NAME}&platform={platform_key}&current={current_version}"

    logger.info("Checking for updates at %s", check_url)

    try:
        response_data = _make_request(check_url)
        data = json.loads(response_data)
    except json.JSONDecodeError as e:
        raise UpdateError(f"Invalid response from update server: {e}") from e

    if "version" not in data:
        logger.info("No update information available from server.")
        return None

    version_info = VersionInfo.from_dict(data)

    if _is_newer_version(version_info.version, current_version):
        logger.info(
            "New version available: %s (current: %s)",
            version_info.version,
            current_version,
        )
        return version_info

    logger.info("Application is up to date (version %s).", current_version)
    return None


def download_update(
    version_info: VersionInfo,
    dest_dir: Optional[str] = None,
    progress_callback=None,
) -> str:
    """
    Download the update package to a temporary directory.

    Args:
        version_info: Version information containing the download URL.
        dest_dir: Optional destination directory. Uses temp dir if not specified.
        progress_callback: Optional callable(bytes_downloaded, total_bytes) for progress.

    Returns:
        Path to the downloaded file.
    """
    if dest_dir is None:
        dest_dir = tempfile.mkdtemp(prefix=f"{APP_NAME}_update_")

    download_url = version_info.download_url
    file_name = download_url.split("/")[-1] or f"{APP_NAME}_update"
    dest_path = os.path.join(dest_dir, file_name)

    logger.info("Downloading update from %s to %s", download_url, dest_path)

    request = Request(
        download_url,
        headers={"User-Agent": f"{APP_NAME}/{CURRENT_VERSION}"},
    )

    try:
        with urlopen(request, timeout=120) as response:
            total_size = int(response.headers.get("Content-Length", version_info.file_size or 0))
            bytes_downloaded = 0

            with open(dest_path, "wb") as f:
                while True:
                    chunk = response.read(CHUNK_SIZE)
                    if not chunk:
                        break
                    f.write(chunk)
                    bytes_downloaded += len(chunk)

                    if progress_callback and total_size > 0:
                        progress_callback(bytes_downloaded, total_size)

    except URLError as e:
        if os.path.exists(dest_path):
            os.remove(dest_path)
        raise UpdateError(f"Failed to download update: {e}") from e
    except IOError as e:
        raise UpdateError(f"Failed to write update file: {e}") from e

    logger.info("Download complete: %d bytes", bytes_downloaded)

    # Verify checksum
    _verify_checksum(dest_path, version_info.checksum)

    return dest_path


def _verify_checksum(file_path: str, expected_checksum: str) -> None:
    """Verify the SHA-256 checksum of a downloaded file."""
    logger.info("Verifying checksum for %s", file_path)

    sha256 = hashlib.sha256()
    with open(file_path, "rb") as f:
        while True:
            chunk = f.read(CHUNK_SIZE)
            if not chunk:
                break
            sha256.update(chunk)

    actual_checksum = sha256.hexdigest()

    if actual_checksum.lower() != expected_checksum.lower():
        os.remove(file_path)
        raise UpdateError(
            f"Checksum verification failed. "
            f"Expected: {expected_checksum}, Got: {actual_checksum}"
        )

    logger.info("Checksum verified successfully.")


def _get_current_executable() -> str:
    """Get the path to the current running executable."""
    if getattr(sys, "frozen", False):
        # Running as a bundled executable (e.g., PyInstaller)
        return sys.executable
    else:
        # Running as a script
        return os.path.abspath(sys.argv[0])


def _create_backup(executable_path: str) -> str:
    """Create a backup of the current executable."""
    backup_path = f"{executable_path}.backup"
    try:
        shutil.copy2(executable_path, backup_path)
        logger.info("Backup created at %s", backup_path)
        return backup_path
    except IOError as e:
        raise UpdateError(f"Failed to create backup: {e}") from e


def _restore_backup(executable_path: str, backup_path: str) -> None:
    """Restore the executable from backup."""
    try:
        if os.path.exists(backup_path):
            shutil.copy2(backup_path, executable_path)
            logger.info("Restored backup from %s", backup_path)
    except IOError as e:
        logger.error("CRITICAL: Failed to restore backup: %s", e)
        raise UpdateError(f"Failed to restore backup: {e}") from e


def apply_update(
    update_file_path: str,
    executable_path: Optional[str] = None,
    restart: bool = True,
) -> bool:
    """
    Apply the downloaded update by replacing the current executable.

    On Windows, a helper script is used because the running executable cannot
    be directly replaced. On Unix systems, the file is replaced directly.

    Args:
        update_file_path: Path to the downloaded update file.
        executable_path: Path to the executable to replace. Auto-detected if None.
        restart: Whether to restart the application after updating.

    Returns:
        True if the update was applied successfully.
    """
    if executable_path is None:
        executable_path = _get_current_executable()

    executable_path = os.path.abspath(executable_path)
    update_file_path = os.path.abspath(update_file_path)

    if not os.path.exists(update_file_path):
        raise UpdateError(f"Update file not found: {update_file_path}")

    logger.info("Applying update: %s -> %s", update_file_path, executable_path)

    system = platform.system().lower()

    if system == "windows":
        return _apply_update_windows(update_file_path, executable_path, restart)
    else:
        return _apply_update_unix(update_file_path, executable_path, restart)


def _apply_update_unix(
    update_file_path: str,
    executable_path: str,
    restart: bool,
) -> bool:
    """Apply update on Unix-like systems (Linux, macOS)."""
    backup_path = _create_backup(executable_path)

    try:
        # Preserve original permissions
        original_stat = os.stat(executable_path)

        # Replace the executable
        shutil.copy2(update_file_path, executable_path)
        os.chmod(executable_path, original_stat.st_mode)

        logger.info("Update applied successfully.")

        # Clean up
        _cleanup(update_file_path, backup_path, keep_backup=False)

        if restart:
            logger.info("Restarting application...")
            os.execv(executable_path, [executable_path] + sys.argv[1:])

        return True

    except (IOError, OSError) as e:
        logger.error("Failed to apply update: %s. Restoring backup.", e)
        _restore_backup(executable_path, backup_path)
        raise UpdateError(f"Failed to apply update: {e}") from e


def _apply_update_windows(
    update_file_path: str,
    executable_path: str,
    restart: bool,
) -> bool:
    """
    Apply update on Windows using a helper batch script.

    Windows locks running executables, so we create a batch script that:
    1. Waits for the current process to exit
    2. Replaces the executable
    3. Optionally restarts the application
    4. Cleans up the batch script
    """
    backup_path = _create_backup(executable_path)

    script_path = os.path.join(
        tempfile.gettempdir(),
        f"{APP_NAME}_updater_{int(time.time())}.bat",
    )

    restart_cmd = f'start "" "{executable_path}"' if restart else ""

    batch_script = f"""@echo off
setlocal

:: Wait for the application to close
set RETRIES=30
:wait_loop
tasklist /FI "PID eq {os.getpid()}" 2>NUL | find /I "{os.getpid()}" >NUL
if not errorlevel 1 (
    set /a RETRIES-=1
    if %RETRIES% leq 0 (
        echo Timeout waiting for application to close.
        goto :restore
    )
    timeout /t 1 /nobreak >NUL
    goto :wait_loop
)

:: Replace the executable
copy /Y "{update_file_path}" "{executable_path}"
if errorlevel 1 goto :restore

:: Clean up update file
del /F /Q "{update_file_path}" 2>NUL

:: Remove backup
del /F /Q "{backup_path}" 2>NUL

:: Restart application
{restart_cmd}

:: Self-delete this script
(goto) 2>nul & del "%~f0"
exit /b 0

:restore
echo Update failed, restoring backup...
copy /Y "{backup_path}" "{executable_path}"
del /F /Q "{backup_path}" 2>NUL
(goto) 2>nul & del "%~f0"
exit /b 1
"""

    try:
        with open(script_path, "w") as f:
            f.write(batch_script)

        # Launch the updater script detached from the current process
        subprocess.Popen(
            ["cmd.exe", "/C", script_path],
            creationflags=subprocess.CREATE_NO_WINDOW | subprocess.DETACHED_PROCESS,
            close_fds=True,
        )

        logger.info("Update script launched. Application will exit now.")
        sys.exit(0)

    except (IOError, OSError) as e:
        logger.error("Failed to create update script: %s", e)
        _restore_backup(executable_path, backup_path)
        raise UpdateError(f"Failed to apply update on Windows: {e}") from e


def _cleanup(
    update_file_path: str,
    backup_path: str,
    keep_backup: bool = False,
) -> None:
    """Clean up temporary files after update."""
    try:
        if os.path.exists(update_file_path):
            os.remove(update_file_path)
            logger.info("Removed update file: %s", update_file_path)

        update_dir = os.path.dirname(update_file_path)
        if update_dir.startswith(tempfile.gettempdir()) and os.path.isdir(update_dir):
            shutil.rmtree(update_dir, ignore_errors=True)

        if not keep_backup and os.path.exists(backup_path):
            os.remove(backup_path)
            logger.info("Removed backup: %s", backup_path)

    except OSError as e:
        logger.warning("Cleanup error (non-critical): %s", e)


def auto_update(
    server_url: str = UPDATE_SERVER_URL,
    current_version: str = CURRENT_VERSION,
    progress_callback=None,
    restart: bool = True,
    force: bool = False,
) -> bool:
    """
    Main auto-update function that orchestrates the entire update process.

    Args:
        server_url: URL of the update server API.
        current_version: Current application version string.
        progress_callback: Optional callable(bytes_downloaded, total_bytes).
        restart: Whether to restart after applying the update.
        force: Force update even if version check says up-to-date.

    Returns:
        True if an update was found and applied, False if already up-to-date.

    Raises:
        UpdateError: If any step of the update process fails.
    """
    logger.info("Starting auto-update check (current version: %s)", current_version)

    # Step 1: Check for updates
    try:
        version_info = check_for_update(server_url, current_version)
    except UpdateError as e:
        logger.error("Update check failed: %s", e)
        raise

    if version_info is None and not force:
        logger.info("No update available.")
        return False

    if version_info is None:
        logger.info("No update available and force=True has no effect without server response.")
        return False

    logger.info(
        "Update available: %s -> %s",
        current_version,
        version_info.version,
    )
    if version_info.release_notes:
        logger.info("Release notes: %s", version_info.release_notes)

    # Step 2: Download the update
    try:
        update_file = download_update(version_info, progress_callback=progress_callback)
    except UpdateError as e:
        logger.error("Download failed: %s", e)
        raise

    # Step 3: Apply the update
    try:
        result = apply_update(update_file, restart=restart)
        logger.info("Update process completed successfully.")
        return result
    except UpdateError as e:
        logger.error("Failed to apply update: %s", e)
        # Clean up downloaded file on failure
        if os.path.exists(update_file):
            os.remove(update_file)
        raise


def rollback(executable_path: Optional[str] = None) -> bool:
    """
    Rollback to the previous version using the backup file.

    Args:
        executable_path: Path to the executable. Auto-detected if None.

    Returns:
        True if rollback was successful.
    """
    if executable_path is None:
        executable_path = _get_current_executable()

    backup_path = f"{executable_path}.backup"

    if not os.path.exists(backup_path):
        logger.warning("No backup found at %s. Cannot rollback.", backup_path)
        return False

    try:
        _restore_backup(executable_path, backup_path)
        os.remove(backup_path)
        logger.info("Rollback completed successfully.")
        return True
    except UpdateError:
        return False


# --- Example usage and CLI interface ---

def _progress_bar(downloaded: int, total: int) -> None:
    """Simple console progress bar."""
    percent = (downloaded / total) * 100
    bar_length = 40
    filled = int(bar_length * downloaded / total)
    bar = "█" * filled + "░" * (bar_length - filled)
    print(f"\rDownloading: [{bar}] {percent:.1f}% ({downloaded}/{total} bytes)", end="", flush=True)
    if downloaded >= total:
        print()


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description=f"{APP_NAME} Auto-Updater")
    parser.add_argument(
        "--check-only",
        action="store_true",
        help="Only check for updates without downloading or applying.",
    )
    parser.add_argument(
        "--no-restart",
        action="store_true",
        help="Do not restart the application after updating.",
    )
    parser.add_argument(
        "--rollback",
        action="store_true",
        help="Rollback to the previous version.",
    )
    parser.add_argument(
        "--server-url",
        default=UPDATE_SERVER_URL,
        help="Update server URL.",
    )
    parser.add_argument(
        "--current-version",
        default=CURRENT_VERSION,
        help="Override current version for testing.",
    )

    args = parser.parse_args()

    try:
        if args.rollback:
            success = rollback()
            sys.exit(0 if success else 1)

        if args.check_only:
            info = check_for_update(args.server_url, args.current_version)
            if info:
                print(f"Update available: {info.version}")
                print(f"Download URL: {info.download_url}")
                if info.release_notes:
                    print(f"Release notes: {info.release_notes}")
            else:
                print("Application is up to date.")
            sys.exit(0)

        updated = auto_update(
            server_url=args.server_url,
            current_version=args.current_version,
            progress_callback=_progress_bar,
            restart=not args.no_restart,
        )

        if not updated:
            print("No update needed.")

    except UpdateError as e:
        logger.error("Update failed: %s", e)
        sys.exit(1)
    except KeyboardInterrupt:
        print("\nUpdate cancelled by user.")
        sys.exit(130)
```