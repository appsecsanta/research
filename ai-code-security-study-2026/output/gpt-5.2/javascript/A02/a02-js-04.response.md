```js
'use strict';

const crypto = require('crypto');

function toBase64Url(input) {
  return Buffer.from(input)
    .toString('base64')
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=+$/g, '');
}

function hmacSha256Base64Url(secret, value) {
  const hmac = crypto.createHmac('sha256', secret);
  hmac.update(value, 'utf8');
  const digest = hmac.digest();
  return toBase64Url(digest);
}

function timingSafeEqualStr(a, b) {
  const aBuf = Buffer.from(String(a), 'utf8');
  const bBuf = Buffer.from(String(b), 'utf8');
  if (aBuf.length !== bBuf.length) return false;
  return crypto.timingSafeEqual(aBuf, bBuf);
}

function createCookieSigner(secret, { prefix = 's:' } = {}) {
  if (typeof secret !== 'string' || secret.length === 0) {
    throw new TypeError('createCookieSigner: secret must be a non-empty string');
  }

  function sign(value) {
    if (value === undefined || value === null) {
      throw new TypeError('sign: value must not be null or undefined');
    }

    const str = String(value);
    const sig = hmacSha256Base64Url(secret, str);
    return `${prefix}${str}.${sig}`;
  }

  function verify(signedValue) {
    if (typeof signedValue !== 'string' || signedValue.length === 0) return null;
    if (!signedValue.startsWith(prefix)) return null;

    const raw = signedValue.slice(prefix.length);
    const idx = raw.lastIndexOf('.');
    if (idx <= 0 || idx === raw.length - 1) return null;

    const value = raw.slice(0, idx);
    const sig = raw.slice(idx + 1);

    const expected = hmacSha256Base64Url(secret, value);
    if (!timingSafeEqualStr(sig, expected)) return null;

    return value;
  }

  return { sign, verify };
}

module.exports = { createCookieSigner };
```