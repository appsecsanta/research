```json
// package.json
{
  "scripts": {
    "postinstall": "node scripts/postinstall.js"
  }
}
```

```js
// scripts/postinstall.js
'use strict';

const fs = require('fs');
const fsp = require('fs/promises');
const path = require('path');
const https = require('https');
const { URL } = require('url');

const pkg = require(path.join(process.cwd(), 'package.json'));

const BIN_NAME = process.env.BINARY_NAME || pkg.name || 'tool';
const BIN_VERSION = process.env.BINARY_VERSION || pkg.version || '0.0.0';
const CDN_BASE_URL =
  process.env.BINARY_CDN_BASE_URL || 'https://cdn.example.com/binaries';

const BIN_DIR = process.env.BINARY_DIR
  ? path.resolve(process.cwd(), process.env.BINARY_DIR)
  : path.resolve(process.cwd(), 'bin');

const OS_MAP = {
  win32: 'windows',
  darwin: 'macos',
  linux: 'linux',
  freebsd: 'freebsd'
};

const ARCH_MAP = {
  x64: 'x64',
  arm64: 'arm64',
  arm: 'armv7',
  ia32: 'x86'
};

function getTarget() {
  const os = OS_MAP[process.platform];
  const arch = ARCH_MAP[process.arch];

  if (!os) throw new Error(`Unsupported platform: ${process.platform}`);
  if (!arch) throw new Error(`Unsupported architecture: ${process.arch}`);

  return { os, arch };
}

function getBinaryFilename({ os, arch }) {
  const ext = process.platform === 'win32' ? '.exe' : '';
  return `${BIN_NAME}-${os}-${arch}${ext}`;
}

function buildDownloadUrl(filename) {
  const base = CDN_BASE_URL.replace(/\/+$/, '');
  const version = String(BIN_VERSION).replace(/^v/, '');
  return `${base}/${encodeURIComponent(BIN_NAME)}/v${encodeURIComponent(
    version
  )}/${encodeURIComponent(filename)}`;
}

function ensureDir(dir) {
  return fsp.mkdir(dir, { recursive: true });
}

function sleep(ms) {
  return new Promise((r) => setTimeout(r, ms));
}

function requestStream(url, { maxRedirects = 5, timeoutMs = 60_000 } = {}) {
  return new Promise((resolve, reject) => {
    const u = typeof url === 'string' ? new URL(url) : url;

    const req = https.get(
      u,
      {
        headers: {
          'User-Agent': `${pkg.name || 'node-postinstall'}/${pkg.version || '0.0.0'}`,
          Accept: '*/*'
        }
      },
      (res) => {
        const status = res.statusCode || 0;

        if (
          status >= 300 &&
          status < 400 &&
          res.headers.location &&
          maxRedirects > 0
        ) {
          res.resume();
          const next = new URL(res.headers.location, u);
          requestStream(next, { maxRedirects: maxRedirects - 1, timeoutMs })
            .then(resolve)
            .catch(reject);
          return;
        }

        if (status < 200 || status >= 300) {
          const chunks = [];
          res.on('data', (d) => chunks.push(d));
          res.on('end', () => {
            const body = Buffer.concat(chunks).toString('utf8').slice(0, 2000);
            reject(
              new Error(
                `Download failed (${status}) from ${u.toString()}${
                  body ? `\n${body}` : ''
                }`
              )
            );
          });
          return;
        }

        resolve({ res, finalUrl: u });
      }
    );

    req.setTimeout(timeoutMs, () => {
      req.destroy(new Error(`Request timed out after ${timeoutMs}ms: ${u.toString()}`));
    });

    req.on('error', reject);
  });
}

async function downloadToFile(url, destPath, { retries = 2 } = {}) {
  const dir = path.dirname(destPath);
  const tmpPath = `${destPath}.tmp-${process.pid}-${Date.now()}`;

  await ensureDir(dir);

  let lastErr;
  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      await fsp.rm(tmpPath, { force: true });

      const { res, finalUrl } = await requestStream(url);
      await new Promise((resolve, reject) => {
        const out = fs.createWriteStream(tmpPath, { mode: 0o755 });
        res.pipe(out);

        const onError = (err) => {
          res.destroy();
          out.destroy();
          reject(err);
        };

        res.on('error', onError);
        out.on('error', onError);
        out.on('finish', resolve);
      });

      await fsp.rename(tmpPath, destPath);

      if (process.platform !== 'win32') {
        await fsp.chmod(destPath, 0o755);
      }

      process.stdout.write(
        `Downloaded ${BIN_NAME} binary to ${destPath} (from ${finalUrl.toString()})\n`
      );
      return;
    } catch (err) {
      lastErr = err;
      await fsp.rm(tmpPath, { force: true });

      if (attempt < retries) {
        const backoff = 500 * Math.pow(2, attempt);
        process.stderr.write(
          `Download attempt ${attempt + 1} failed: ${err.message}\nRetrying in ${backoff}ms...\n`
        );
        await sleep(backoff);
        continue;
      }
    }
  }

  throw lastErr;
}

async function main() {
  const target = getTarget();
  const filename = getBinaryFilename(target);
  const url = buildDownloadUrl(filename);

  const dest = path.join(BIN_DIR, filename);

  await downloadToFile(url, dest, { retries: Number(process.env.BINARY_RETRIES || 2) });

  const linkName = process.platform === 'win32' ? `${BIN_NAME}.exe` : BIN_NAME;
  const linkPath = path.join(BIN_DIR, linkName);

  if (linkPath !== dest) {
    try {
      await fsp.rm(linkPath, { force: true });
    } catch (_) {}

    try {
      await fsp.link(dest, linkPath);
    } catch (_) {
      // Fallback to copy if hardlink fails (e.g., cross-device)
      await fsp.copyFile(dest, linkPath);
      if (process.platform !== 'win32') await fsp.chmod(linkPath, 0o755);
    }
  }
}

main().catch((err) => {
  process.stderr.write(`${err.stack || err.message || String(err)}\n`);
  process.exitCode = 1;
});
```