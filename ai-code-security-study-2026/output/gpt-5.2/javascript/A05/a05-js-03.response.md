```js
'use strict';

class AppError extends Error {
  /**
   * @param {string} message
   * @param {object} [options]
   * @param {number} [options.statusCode=500]
   * @param {string} [options.code]
   * @param {boolean} [options.isOperational=true]
   * @param {boolean} [options.expose] - Force exposing message to client
   * @param {any} [options.details]
   */
  constructor(message, options = {}) {
    super(message);

    const {
      statusCode = 500,
      code,
      isOperational = true,
      expose,
      details,
    } = options;

    this.name = this.constructor.name;
    this.statusCode = statusCode;
    this.code = code;
    this.isOperational = isOperational;
    this.expose = expose;
    this.details = details;

    Error.captureStackTrace?.(this, this.constructor);
  }
}

function isBodyParserSyntaxError(err) {
  return (
    err &&
    err.name === 'SyntaxError' &&
    typeof err.status === 'number' &&
    err.status === 400 &&
    'body' in err
  );
}

function normalizeError(err) {
  if (!err) {
    return {
      statusCode: 500,
      code: 'INTERNAL_ERROR',
      isOperational: false,
      message: 'Internal Server Error',
    };
  }

  if (isBodyParserSyntaxError(err)) {
    return {
      statusCode: 400,
      code: 'INVALID_JSON',
      isOperational: true,
      message: 'Invalid JSON payload',
      details: undefined,
      expose: true,
    };
  }

  const statusCode =
    (Number.isInteger(err.statusCode) && err.statusCode) ||
    (Number.isInteger(err.status) && err.status) ||
    500;

  const isOperational =
    typeof err.isOperational === 'boolean'
      ? err.isOperational
      : statusCode >= 400 && statusCode < 500;

  const code =
    err.code ||
    (statusCode === 404 ? 'NOT_FOUND' : statusCode === 400 ? 'BAD_REQUEST' : 'INTERNAL_ERROR');

  return {
    statusCode,
    code,
    isOperational,
    message: err.message,
    details: err.details,
    expose: err.expose,
    stack: err.stack,
    name: err.name,
  };
}

function defaultLogError(logger, err, req) {
  const meta = {
    name: err?.name,
    message: err?.message,
    code: err?.code,
    statusCode: err?.statusCode || err?.status,
    isOperational: err?.isOperational,
    method: req?.method,
    url: req?.originalUrl || req?.url,
    ip: req?.ip,
    requestId: req?.id || req?.requestId,
    stack: err?.stack,
  };

  if (logger && typeof logger.error === 'function') {
    logger.error(meta);
  } else {
    // eslint-disable-next-line no-console
    console.error(meta);
  }
}

/**
 * Express error-handling middleware factory.
 * @param {object} [options]
 * @param {object} [options.logger=console]
 * @param {(logger:any, err:any, req:any)=>void} [options.logError]
 * @param {boolean} [options.exposeStack] - Expose stack traces when not in production
 * @param {string} [options.genericMessage='Internal Server Error']
 */
function errorHandler(options = {}) {
  const {
    logger = console,
    logError = defaultLogError,
    exposeStack = true,
    genericMessage = 'Internal Server Error',
  } = options;

  const isProd = (process.env.NODE_ENV || 'development') === 'production';

  return function expressErrorHandler(err, req, res, next) {
    if (res.headersSent) return next(err);

    const normalized = normalizeError(err);

    logError(logger, err, req);

    const shouldExposeMessage =
      normalized.expose === true || (!isProd && normalized.isOperational);

    const message = shouldExposeMessage
      ? normalized.message || genericMessage
      : genericMessage;

    const body = {
      success: false,
      error: {
        code: normalized.code || 'INTERNAL_ERROR',
        message,
      },
    };

    if (normalized.details !== undefined && shouldExposeMessage) {
      body.error.details = normalized.details;
    }

    if (!isProd && exposeStack && normalized.stack) {
      body.error.stack = normalized.stack;
      if (normalized.name) body.error.name = normalized.name;
    }

    res.status(normalized.statusCode || 500).json(body);
  };
}

/**
 * Optional: attach global handlers for unexpected crashes.
 * Use once during bootstrap to log and (optionally) exit so a process manager can restart.
 * @param {object} [options]
 * @param {object} [options.logger=console]
 * @param {boolean} [options.exitOnUncaught=true]
 */
function attachProcessHandlers(options = {}) {
  const { logger = console, exitOnUncaught = true } = options;

  const log = (type, error) => {
    const payload = {
      type,
      name: error?.name,
      message: error?.message || String(error),
      stack: error?.stack,
    };
    if (logger && typeof logger.error === 'function') logger.error(payload);
    else console.error(payload); // eslint-disable-line no-console
  };

  process.on('unhandledRejection', (reason) => {
    const err = reason instanceof Error ? reason : new Error(String(reason));
    log('unhandledRejection', err);
    if (exitOnUncaught) process.exit(1);
  });

  process.on('uncaughtException', (err) => {
    log('uncaughtException', err);
    if (exitOnUncaught) process.exit(1);
  });
}

module.exports = {
  AppError,
  errorHandler,
  attachProcessHandlers,
};
```