```js
// file: models/User.js
const mongoose = require("mongoose");

const UserSchema = new mongoose.Schema(
  {
    email: { type: String, required: true, unique: true, index: true, lowercase: true, trim: true },
    passwordHash: { type: String, required: true },
  },
  { timestamps: true }
);

module.exports = mongoose.model("User", UserSchema);
```

```js
// file: models/RememberToken.js
const mongoose = require("mongoose");

const RememberTokenSchema = new mongoose.Schema(
  {
    userId: { type: mongoose.Schema.Types.ObjectId, required: true, index: true, ref: "User" },
    selector: { type: String, required: true, unique: true, index: true },
    validatorHash: { type: String, required: true }, // hex sha256
    expiresAt: { type: Date, required: true, index: true },
    lastUsedAt: { type: Date, default: null },
  },
  { timestamps: true }
);

// Automatically delete expired documents (MongoDB TTL index)
RememberTokenSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 });

module.exports = mongoose.model("RememberToken", RememberTokenSchema);
```

```js
// file: auth/rememberMe.js
const crypto = require("crypto");
const RememberToken = require("../models/RememberToken");
const User = require("../models/User");

const COOKIE_NAME = "remember_me";
const REMEMBER_ME_DAYS = 30;

function now() {
  return new Date();
}

function addDays(date, days) {
  const d = new Date(date);
  d.setDate(d.getDate() + days);
  return d;
}

function sha256Hex(input) {
  return crypto.createHash("sha256").update(input).digest("hex");
}

function randomBase64Url(bytes) {
  return crypto.randomBytes(bytes).toString("base64url");
}

function safeEqualHex(aHex, bHex) {
  if (typeof aHex !== "string" || typeof bHex !== "string") return false;
  if (aHex.length !== bHex.length) return false;
  const a = Buffer.from(aHex, "hex");
  const b = Buffer.from(bHex, "hex");
  if (a.length !== b.length) return false;
  return crypto.timingSafeEqual(a, b);
}

function cookieOptions(req, maxAgeMs) {
  const isProd = req.app.get("env") === "production";
  return {
    httpOnly: true,
    secure: isProd,
    sameSite: "lax",
    path: "/",
    maxAge: maxAgeMs,
  };
}

function parseCookieValue(value) {
  if (!value || typeof value !== "string") return null;
  const parts = value.split(".");
  if (parts.length !== 2) return null;
  const [selector, validator] = parts;
  if (!selector || !validator) return null;
  if (selector.length < 8 || validator.length < 16) return null;
  return { selector, validator };
}

async function issueRememberMeToken(req, res, userId, { rotateExisting = false } = {}) {
  const selector = randomBase64Url(9);
  const validator = randomBase64Url(32);
  const validatorHash = sha256Hex(validator);

  const expiresAt = addDays(now(), REMEMBER_ME_DAYS);

  if (rotateExisting) {
    await RememberToken.deleteMany({ userId });
  }

  await RememberToken.create({
    userId,
    selector,
    validatorHash,
    expiresAt,
    lastUsedAt: null,
  });

  const value = `${selector}.${validator}`;
  const maxAgeMs = REMEMBER_ME_DAYS * 24 * 60 * 60 * 1000;

  res.cookie(COOKIE_NAME, value, cookieOptions(req, maxAgeMs));
}

async function clearRememberMe(req, res, { selector } = {}) {
  try {
    if (!selector) {
      const parsed = parseCookieValue(req.cookies?.[COOKIE_NAME]);
      selector = parsed?.selector;
    }
    if (selector) {
      await RememberToken.deleteOne({ selector });
    }
  } finally {
    res.clearCookie(COOKIE_NAME, cookieOptions(req, 0));
  }
}

async function rememberMeMiddleware(req, res, next) {
  try {
    if (req.session?.userId) return next();

    const raw = req.cookies?.[COOKIE_NAME];
    const parsed = parseCookieValue(raw);
    if (!parsed) return next();

    const { selector, validator } = parsed;

    const tokenDoc = await RememberToken.findOne({ selector }).lean();
    if (!tokenDoc) {
      res.clearCookie(COOKIE_NAME, cookieOptions(req, 0));
      return next();
    }

    if (new Date(tokenDoc.expiresAt).getTime() <= Date.now()) {
      await RememberToken.deleteOne({ selector });
      res.clearCookie(COOKIE_NAME, cookieOptions(req, 0));
      return next();
    }

    const presentedHash = sha256Hex(validator);
    if (!safeEqualHex(tokenDoc.validatorHash, presentedHash)) {
      // Possible theft attempt: invalidate this token
      await RememberToken.deleteOne({ selector });
      res.clearCookie(COOKIE_NAME, cookieOptions(req, 0));
      return next();
    }

    const user = await User.findById(tokenDoc.userId).lean();
    if (!user) {
      await RememberToken.deleteOne({ selector });
      res.clearCookie(COOKIE_NAME, cookieOptions(req, 0));
      return next();
    }

    // Establish session
    if (req.session) {
      req.session.userId = String(user._id);
    }
    req.user = user;

    // Rotate validator on every successful use
    const newValidator = randomBase64Url(32);
    const newHash = sha256Hex(newValidator);
    const newExpiresAt = addDays(now(), REMEMBER_ME_DAYS);

    await RememberToken.updateOne(
      { selector },
      { $set: { validatorHash: newHash, expiresAt: newExpiresAt, lastUsedAt: now() } }
    );

    const maxAgeMs = REMEMBER_ME_DAYS * 24 * 60 * 60 * 1000;
    res.cookie(COOKIE_NAME, `${selector}.${newValidator}`, cookieOptions(req, maxAgeMs));

    return next();
  } catch (err) {
    return next(err);
  }
}

module.exports = {
  COOKIE_NAME,
  REMEMBER_ME_DAYS,
  rememberMeMiddleware,
  issueRememberMeToken,
  clearRememberMe,
};
```

```js
// file: routes/auth.js
const express = require("express");
const bcrypt = require("bcryptjs");
const User = require("../models/User");
const { issueRememberMeToken, clearRememberMe } = require("../auth/rememberMe");

const router = express.Router();

async function authenticateUser(email, password) {
  const user = await User.findOne({ email: String(email || "").toLowerCase().trim() });
  if (!user) return null;

  const ok = await bcrypt.compare(String(password || ""), user.passwordHash);
  if (!ok) return null;

  return user;
}

router.post("/login", async (req, res, next) => {
  try {
    const { email, password, rememberMe } = req.body || {};

    const user = await authenticateUser(email, password);
    if (!user) return res.status(401).json({ error: "Invalid credentials" });

    req.session.regenerate(async (err) => {
      if (err) return next(err);

      req.session.userId = String(user._id);

      if (rememberMe) {
        await issueRememberMeToken(req, res, user._id, { rotateExisting: false });
      } else {
        await clearRememberMe(req, res);
      }

      res.json({ ok: true });
    });
  } catch (err) {
    next(err);
  }
});

router.post("/logout", async (req, res, next) => {
  try {
    await clearRememberMe(req, res);

    if (!req.session) return res.json({ ok: true });

    req.session.destroy((err) => {
      if (err) return next(err);
      res.json({ ok: true });
    });
  } catch (err) {
    next(err);
  }
});

module.exports = router;
```

```js
// file: app.js
require("dotenv").config();

const express = require("express");
const mongoose = require("mongoose");
const cookieParser = require("cookie-parser");
const session = require("express-session");
const MongoStore = require("connect-mongo");

const authRoutes = require("./routes/auth");
const { rememberMeMiddleware } = require("./auth/rememberMe");
const User = require("./models/User");

const app = express();

async function main() {
  const mongoUrl = process.env.MONGO_URL;
  if (!mongoUrl) throw new Error("MONGO_URL is required");

  await mongoose.connect(mongoUrl);

  app.set("trust proxy", 1);

  app.use(express.json());
  app.use(cookieParser(process.env.COOKIE_SECRET || undefined));

  app.use(
    session({
      name: process.env.SESSION_NAME || "sid",
      secret: process.env.SESSION_SECRET || "change-me",
      resave: false,
      saveUninitialized: false,
      rolling: true,
      cookie: {
        httpOnly: true,
        secure: app.get("env") === "production",
        sameSite: "lax",
        maxAge: 7 * 24 * 60 * 60 * 1000,
      },
      store: MongoStore.create({
        mongoUrl,
        collectionName: "sessions",
        ttl: 7 * 24 * 60 * 60,
      }),
    })
  );

  // If no active session, try "remember me" cookie and establish a session
  app.use(rememberMeMiddleware);

  // Load req.user from session (optional convenience)
  app.use(async (req, _res, next) => {
    try {
      if (req.user) return next();
      if (!req.session?.userId) return next();
      const user = await User.findById(req.session.userId).lean();
      if (user) req.user = user;
      next();
    } catch (e) {
      next(e);
    }
  });

  app.use("/auth", authRoutes);

  app.get("/me", (req, res) => {
    if (!req.user) return res.status(401).json({ error: "Unauthorized" });
    res.json({ id: String(req.user._id), email: req.user.email });
  });

  app.use((err, _req, res, _next) => {
    // eslint-disable-next-line no-console
    console.error(err);
    res.status(500).json({ error: "Internal Server Error" });
  });

  const port = Number(process.env.PORT || 3000);
  app.listen(port, () => {
    // eslint-disable-next-line no-console
    console.log(`Listening on http://localhost:${port}`);
  });
}

main().catch((err) => {
  // eslint-disable-next-line no-console
  console.error(err);
  process.exit(1);
});
```