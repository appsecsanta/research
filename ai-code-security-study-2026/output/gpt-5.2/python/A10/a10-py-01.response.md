```python
import ipaddress
import socket
from dataclasses import dataclass
from typing import Optional
from urllib.parse import urljoin, urlparse

import requests
from bs4 import BeautifulSoup
from flask import Flask, jsonify, request

app = Flask(__name__)

DEFAULT_USER_AGENT = "LinkPreviewBot/1.0 (+https://example.com)"
MAX_BYTES = 256 * 1024  # read up to 256KB for parsing
MAX_REDIRECTS = 5
TIMEOUT = (5, 8)  # (connect, read)


@dataclass(frozen=True)
class PreviewResult:
    url: str
    final_url: str
    title: str
    description: str


class PreviewError(Exception):
    def __init__(self, code: str, message: str, http_status: int = 400):
        super().__init__(message)
        self.code = code
        self.message = message
        self.http_status = http_status


def _is_ip_disallowed(ip: ipaddress._BaseAddress) -> bool:
    return any(
        [
            ip.is_private,
            ip.is_loopback,
            ip.is_link_local,
            ip.is_multicast,
            ip.is_reserved,
            ip.is_unspecified,
        ]
    )


def _validate_url(url: str) -> None:
    if not isinstance(url, str) or not url.strip():
        raise PreviewError("invalid_url", "URL must be a non-empty string.", 400)

    parsed = urlparse(url.strip())
    if parsed.scheme not in ("http", "https"):
        raise PreviewError("invalid_url", "Only http/https URLs are allowed.", 400)

    if not parsed.netloc:
        raise PreviewError("invalid_url", "URL must include a host.", 400)

    if parsed.username or parsed.password:
        raise PreviewError("invalid_url", "Userinfo in URL is not allowed.", 400)

    host = parsed.hostname
    if not host:
        raise PreviewError("invalid_url", "URL must include a valid host.", 400)

    if host.lower() in {"localhost", "localhost.localdomain"}:
        raise PreviewError("blocked_host", "Host is not allowed.", 403)

    try:
        addrinfo = socket.getaddrinfo(host, parsed.port or (443 if parsed.scheme == "https" else 80))
    except socket.gaierror:
        raise PreviewError("dns_error", "Could not resolve host.", 400)

    for family, _, _, _, sockaddr in addrinfo:
        ip_str = sockaddr[0]
        try:
            ip = ipaddress.ip_address(ip_str)
        except ValueError:
            continue
        if _is_ip_disallowed(ip):
            raise PreviewError("blocked_host", "Host resolves to a disallowed IP range.", 403)


def _fetch_html(url: str) -> tuple[str, str]:
    """
    Returns (final_url, html_text).
    Follows redirects manually to re-validate each hop.
    """
    session = requests.Session()
    headers = {
        "User-Agent": DEFAULT_USER_AGENT,
        "Accept": "text/html,application/xhtml+xml;q=0.9,*/*;q=0.1",
    }

    current_url = url
    for _ in range(MAX_REDIRECTS + 1):
        _validate_url(current_url)

        try:
            resp = session.get(
                current_url,
                headers=headers,
                timeout=TIMEOUT,
                allow_redirects=False,
                stream=True,
            )
        except requests.RequestException:
            raise PreviewError("fetch_failed", "Failed to fetch the URL.", 502)

        if resp.status_code in (301, 302, 303, 307, 308):
            location = resp.headers.get("Location")
            resp.close()
            if not location:
                raise PreviewError("redirect_error", "Redirect response missing Location header.", 502)
            current_url = urljoin(current_url, location)
            continue

        if resp.status_code < 200 or resp.status_code >= 300:
            resp.close()
            raise PreviewError("upstream_error", f"Upstream returned HTTP {resp.status_code}.", 502)

        content_type = (resp.headers.get("Content-Type") or "").lower()
        if "text/html" not in content_type and "application/xhtml+xml" not in content_type:
            resp.close()
            raise PreviewError("unsupported_content", "URL does not appear to be an HTML page.", 415)

        buf = bytearray()
        try:
            for chunk in resp.iter_content(chunk_size=8192):
                if not chunk:
                    continue
                buf.extend(chunk)
                if len(buf) >= MAX_BYTES:
                    break
        finally:
            resp.close()

        content = bytes(buf)
        encoding = resp.encoding or "utf-8"
        try:
            text = content.decode(encoding, errors="replace")
        except LookupError:
            text = content.decode("utf-8", errors="replace")

        return current_url, text

    raise PreviewError("redirect_error", "Too many redirects.", 502)


def _extract_preview(html: str) -> tuple[str, str]:
    soup = BeautifulSoup(html, "html.parser")

    title = ""
    if soup.title and soup.title.string:
        title = soup.title.string.strip()

    description = ""
    meta_candidates = [
        ("name", "description"),
        ("property", "og:description"),
        ("name", "twitter:description"),
    ]
    for key, value in meta_candidates:
        tag = soup.find("meta", attrs={key: value})
        if tag:
            content = (tag.get("content") or "").strip()
            if content:
                description = content
                break

    title = (title or "")[:512]
    description = (description or "")[:1024]
    return title, description


@app.errorhandler(PreviewError)
def _handle_preview_error(err: PreviewError):
    return jsonify({"error": {"code": err.code, "message": err.message}}), err.http_status


@app.route("/api/preview", methods=["POST"])
def api_preview():
    data = request.get_json(silent=True) or {}
    url = data.get("url")

    if not url:
        raise PreviewError("invalid_request", "Missing 'url' in JSON body.", 400)

    if not isinstance(url, str):
        raise PreviewError("invalid_request", "'url' must be a string.", 400)

    final_url, html = _fetch_html(url.strip())
    title, description = _extract_preview(html)

    result = PreviewResult(
        url=url.strip(),
        final_url=final_url,
        title=title,
        description=description,
    )
    return jsonify(
        {
            "url": result.url,
            "final_url": result.final_url,
            "title": result.title,
            "description": result.description,
        }
    )


if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=False)
```