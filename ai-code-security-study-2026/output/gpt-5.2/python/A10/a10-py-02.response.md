```python
import os
import re
import sqlite3
from contextlib import closing
from datetime import datetime, timezone
from typing import Any, Dict, Iterable, Optional
from urllib.parse import urlparse

import requests
from flask import Flask, g, jsonify, request

DEFAULT_DB_PATH = os.environ.get("WEBHOOKS_DB_PATH", "webhooks.sqlite3")
WEBHOOK_POST_TIMEOUT_SECONDS = float(os.environ.get("WEBHOOK_POST_TIMEOUT_SECONDS", "5.0"))

_URL_MAX_LENGTH = 2048
_ALLOWED_SCHEMES = {"http", "https"}


def _utc_now_iso() -> str:
    return datetime.now(timezone.utc).isoformat()


def _is_valid_webhook_url(url: str) -> bool:
    if not isinstance(url, str):
        return False
    url = url.strip()
    if not url or len(url) > _URL_MAX_LENGTH:
        return False

    parsed = urlparse(url)
    if parsed.scheme not in _ALLOWED_SCHEMES:
        return False
    if not parsed.netloc:
        return False

    # Basic guard against obvious whitespace/control characters
    if re.search(r"[\x00-\x1f\x7f\s]", url):
        return False

    return True


def _connect_db(db_path: str) -> sqlite3.Connection:
    conn = sqlite3.connect(db_path, detect_types=sqlite3.PARSE_DECLTYPES, check_same_thread=False)
    conn.row_factory = sqlite3.Row
    return conn


def init_db(db_path: str) -> None:
    os.makedirs(os.path.dirname(db_path) or ".", exist_ok=True)
    with closing(_connect_db(db_path)) as conn:
        conn.execute("PRAGMA journal_mode=WAL;")
        conn.execute("PRAGMA foreign_keys=ON;")
        conn.execute(
            """
            CREATE TABLE IF NOT EXISTS webhooks (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                url TEXT NOT NULL UNIQUE,
                created_at TEXT NOT NULL
            );
            """
        )
        conn.commit()


def create_app(db_path: str = DEFAULT_DB_PATH) -> Flask:
    app = Flask(__name__)
    app.config["WEBHOOKS_DB_PATH"] = db_path
    init_db(db_path)

    def get_db() -> sqlite3.Connection:
        if "db" not in g:
            g.db = _connect_db(app.config["WEBHOOKS_DB_PATH"])
        return g.db

    @app.teardown_appcontext
    def close_db(_: Optional[BaseException]) -> None:
        db = g.pop("db", None)
        if db is not None:
            db.close()

    @app.post("/api/webhooks/register")
    def register_webhook():
        data = request.get_json(silent=True) or {}
        url = (data.get("url") or "").strip()

        if not _is_valid_webhook_url(url):
            return jsonify({"error": "Invalid webhook URL"}), 400

        conn = get_db()
        try:
            conn.execute(
                "INSERT INTO webhooks (url, created_at) VALUES (?, ?);",
                (url, _utc_now_iso()),
            )
            conn.commit()
            return jsonify({"status": "registered", "url": url}), 201
        except sqlite3.IntegrityError:
            return jsonify({"status": "already_registered", "url": url}), 200

    return app


def iter_registered_webhooks(db_path: str = DEFAULT_DB_PATH) -> Iterable[str]:
    with closing(_connect_db(db_path)) as conn:
        conn.execute("PRAGMA foreign_keys=ON;")
        rows = conn.execute("SELECT url FROM webhooks ORDER BY id ASC;").fetchall()
        for row in rows:
            yield row["url"]


def send_event_to_webhooks(
    event_type: str,
    event_data: Dict[str, Any],
    *,
    db_path: str = DEFAULT_DB_PATH,
    timeout_seconds: float = WEBHOOK_POST_TIMEOUT_SECONDS,
    session: Optional[requests.Session] = None,
) -> Dict[str, Any]:
    if not isinstance(event_type, str) or not event_type.strip():
        raise ValueError("event_type must be a non-empty string")
    if not isinstance(event_data, dict):
        raise ValueError("event_data must be a dict")

    payload = {
        "type": event_type,
        "data": event_data,
        "sent_at": _utc_now_iso(),
    }

    sess = session or requests.Session()
    results = {"delivered": [], "failed": []}

    for url in iter_registered_webhooks(db_path=db_path):
        try:
            resp = sess.post(url, json=payload, timeout=timeout_seconds)
            ok = 200 <= resp.status_code < 300
            if ok:
                results["delivered"].append({"url": url, "status_code": resp.status_code})
            else:
                results["failed"].append(
                    {"url": url, "status_code": resp.status_code, "error": "non_2xx_response"}
                )
        except requests.RequestException as exc:
            results["failed"].append({"url": url, "status_code": None, "error": str(exc)})

    if session is None:
        sess.close()

    return results


app = create_app()

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=int(os.environ.get("PORT", "5000")))
```