```python
import os
import socket
import ipaddress
from io import BytesIO
from urllib.parse import urlparse, urljoin

import requests
from flask import Flask, Response, jsonify, request


DEFAULT_MAX_BYTES = 10 * 1024 * 1024  # 10 MiB
DEFAULT_TIMEOUT_SECONDS = 8
DEFAULT_MAX_REDIRECTS = 5


def _env_int(name: str, default: int) -> int:
    try:
        return int(os.environ.get(name, default))
    except (TypeError, ValueError):
        return default


MAX_BYTES = _env_int("IMAGE_PROXY_MAX_BYTES", DEFAULT_MAX_BYTES)
TIMEOUT_SECONDS = _env_int("IMAGE_PROXY_TIMEOUT_SECONDS", DEFAULT_TIMEOUT_SECONDS)
MAX_REDIRECTS = _env_int("IMAGE_PROXY_MAX_REDIRECTS", DEFAULT_MAX_REDIRECTS)


def _is_ip_public(ip: str) -> bool:
    try:
        addr = ipaddress.ip_address(ip)
    except ValueError:
        return False

    if (
        addr.is_private
        or addr.is_loopback
        or addr.is_link_local
        or addr.is_multicast
        or addr.is_reserved
        or addr.is_unspecified
    ):
        return False
    return True


def _hostname_resolves_to_public_ip(hostname: str) -> bool:
    try:
        infos = socket.getaddrinfo(hostname, None, proto=socket.IPPROTO_TCP)
    except socket.gaierror:
        return False

    ips = {info[4][0] for info in infos if info and info[4]}
    if not ips:
        return False

    return all(_is_ip_public(ip) for ip in ips)


def _is_safe_remote_url(raw_url: str) -> bool:
    try:
        p = urlparse(raw_url)
    except Exception:
        return False

    if p.scheme not in ("http", "https"):
        return False
    if not p.netloc:
        return False

    hostname = p.hostname
    if not hostname:
        return False

    if not _hostname_resolves_to_public_ip(hostname):
        return False

    return True


def _fetch_image(url: str) -> tuple[bytes, str, dict]:
    session = requests.Session()
    headers = {
        "User-Agent": "image-proxy/1.0",
        "Accept": "image/*,*/*;q=0.8",
    }

    current = url
    for _ in range(MAX_REDIRECTS + 1):
        if not _is_safe_remote_url(current):
            raise ValueError("Unsafe URL")

        resp = session.get(
            current,
            headers=headers,
            timeout=TIMEOUT_SECONDS,
            stream=True,
            allow_redirects=False,
        )

        if resp.is_redirect or resp.status_code in (301, 302, 303, 307, 308):
            loc = resp.headers.get("Location")
            resp.close()
            if not loc:
                raise RuntimeError("Redirect without Location")
            current = urljoin(current, loc)
            continue

        if resp.status_code != 200:
            resp.close()
            raise RuntimeError(f"Upstream returned HTTP {resp.status_code}")

        content_type = (resp.headers.get("Content-Type") or "").split(";")[0].strip().lower()
        if not content_type.startswith("image/"):
            resp.close()
            raise TypeError("Upstream content is not an image")

        content_length = resp.headers.get("Content-Length")
        if content_length:
            try:
                if int(content_length) > MAX_BYTES:
                    resp.close()
                    raise OverflowError("Image too large")
            except ValueError:
                pass

        buf = BytesIO()
        size = 0
        try:
            for chunk in resp.iter_content(chunk_size=64 * 1024):
                if not chunk:
                    continue
                size += len(chunk)
                if size > MAX_BYTES:
                    raise OverflowError("Image too large")
                buf.write(chunk)
        finally:
            resp.close()

        passthrough_headers = {}
        for h in ("ETag", "Last-Modified"):
            if h in resp.headers:
                passthrough_headers[h] = resp.headers[h]

        return buf.getvalue(), content_type, passthrough_headers

    raise RuntimeError("Too many redirects")


def create_app() -> Flask:
    app = Flask(__name__)

    @app.get("/api/image-proxy")
    def image_proxy():
        raw_url = (request.args.get("url") or "").strip()
        if not raw_url:
            return jsonify(error="Missing required query parameter: url"), 400

        try:
            data, content_type, upstream_headers = _fetch_image(raw_url)
        except ValueError:
            return jsonify(error="Invalid or unsafe url"), 400
        except OverflowError:
            return jsonify(error="Image too large"), 413
        except TypeError:
            return jsonify(error="Upstream content is not an image"), 415
        except requests.RequestException:
            return jsonify(error="Failed to fetch image"), 502
        except Exception:
            return jsonify(error="Failed to fetch image"), 502

        resp = Response(data, status=200, mimetype=content_type)
        resp.headers["Content-Length"] = str(len(data))
        resp.headers["X-Content-Type-Options"] = "nosniff"
        resp.headers["Cache-Control"] = "public, max-age=3600"
        for k, v in upstream_headers.items():
            resp.headers[k] = v
        return resp

    return app


app = create_app()

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=_env_int("PORT", 5000), debug=False)
```