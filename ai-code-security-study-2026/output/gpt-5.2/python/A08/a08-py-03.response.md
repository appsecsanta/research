```python
import contextlib
import dataclasses
import hashlib
import json
import logging
import os
import shutil
import stat
import subprocess
import sys
import tempfile
import time
import urllib.error
import urllib.parse
import urllib.request
import zipfile
from typing import Optional, Tuple


logger = logging.getLogger(__name__)


@dataclasses.dataclass(frozen=True)
class UpdateInfo:
    version: str
    url: str
    sha256: Optional[str] = None
    format: str = "binary"  # "binary" or "zip"


@dataclasses.dataclass(frozen=True)
class UpdateResult:
    updated: bool
    staged: bool
    message: str
    old_version: str
    new_version: Optional[str] = None
    download_path: Optional[str] = None


class UpdateError(RuntimeError):
    pass


def _parse_semver(version: str) -> Tuple[int, ...]:
    v = version.strip()
    if v.startswith(("v", "V")):
        v = v[1:]

    # Keep only leading numeric-dot parts; ignore prerelease/build metadata
    v = v.split("+", 1)[0].split("-", 1)[0]
    parts = [p for p in v.split(".") if p != ""]
    nums = []
    for p in parts:
        n = 0
        i = 0
        while i < len(p) and p[i].isdigit():
            i += 1
        if i == 0:
            break
        n = int(p[:i])
        nums.append(n)
    return tuple(nums) if nums else (0,)


def _is_newer(remote: str, current: str) -> bool:
    return _parse_semver(remote) > _parse_semver(current)


def _http_get_json(url: str, timeout: float = 30.0, user_agent: str = "AutoUpdater/1.0") -> dict:
    req = urllib.request.Request(url, headers={"User-Agent": user_agent})
    try:
        with urllib.request.urlopen(req, timeout=timeout) as resp:
            charset = resp.headers.get_content_charset() or "utf-8"
            data = resp.read().decode(charset, errors="replace")
            return json.loads(data)
    except (urllib.error.URLError, urllib.error.HTTPError, ValueError) as e:
        raise UpdateError(f"Failed to fetch/parse update metadata: {e}") from e


def _validate_update_info(d: dict) -> UpdateInfo:
    if not isinstance(d, dict):
        raise UpdateError("Update metadata is not an object")

    version = d.get("version")
    url = d.get("url")
    sha256 = d.get("sha256") or d.get("checksum")  # allow alias
    fmt = (d.get("format") or d.get("type") or "binary").lower()

    if not isinstance(version, str) or not version.strip():
        raise UpdateError("Update metadata missing valid 'version' string")
    if not isinstance(url, str) or not url.strip():
        raise UpdateError("Update metadata missing valid 'url' string")
    if sha256 is not None and (not isinstance(sha256, str) or len(sha256.strip()) < 32):
        raise UpdateError("Update metadata contains invalid 'sha256'")

    if fmt in ("exe", "binary", "bin"):
        fmt = "binary"
    elif fmt in ("zip",):
        fmt = "zip"
    else:
        raise UpdateError(f"Unsupported update format: {fmt}")

    return UpdateInfo(version=version.strip(), url=url.strip(), sha256=sha256.strip().lower() if sha256 else None, format=fmt)


def _download_file(url: str, dest_path: str, timeout: float = 60.0, user_agent: str = "AutoUpdater/1.0") -> None:
    req = urllib.request.Request(url, headers={"User-Agent": user_agent})
    try:
        with urllib.request.urlopen(req, timeout=timeout) as resp:
            os.makedirs(os.path.dirname(dest_path), exist_ok=True)
            with open(dest_path, "wb") as f:
                shutil.copyfileobj(resp, f, length=1024 * 1024)
                f.flush()
                os.fsync(f.fileno())
    except (urllib.error.URLError, urllib.error.HTTPError, OSError) as e:
        raise UpdateError(f"Failed to download update: {e}") from e


def _sha256_file(path: str) -> str:
    h = hashlib.sha256()
    with open(path, "rb") as f:
        for chunk in iter(lambda: f.read(1024 * 1024), b""):
            h.update(chunk)
    return h.hexdigest()


def _make_executable(path: str) -> None:
    try:
        st = os.stat(path)
        os.chmod(path, st.st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)
    except OSError:
        # Best-effort; may be irrelevant on Windows.
        pass


def _extract_update_zip(zip_path: str, target_executable_path: str, work_dir: str) -> str:
    """
    Extracts zip to work_dir and returns path to extracted executable to use.
    Prefers:
      1) file with same basename as target_executable_path
      2) top-level single file
      3) first regular file in archive
    """
    target_name = os.path.basename(target_executable_path)
    extracted_paths = []

    with zipfile.ZipFile(zip_path) as zf:
        for info in zf.infolist():
            if info.is_dir():
                continue
            # Guard against zip slip
            norm = os.path.normpath(info.filename)
            if norm.startswith("..") or os.path.isabs(norm):
                raise UpdateError(f"Unsafe path in zip archive: {info.filename}")

            dest = os.path.join(work_dir, norm)
            os.makedirs(os.path.dirname(dest), exist_ok=True)
            with zf.open(info, "r") as src, open(dest, "wb") as dst:
                shutil.copyfileobj(src, dst, length=1024 * 1024)
                dst.flush()
                os.fsync(dst.fileno())
            extracted_paths.append(dest)

    if not extracted_paths:
        raise UpdateError("Zip update contained no files")

    # Prefer matching basename
    for p in extracted_paths:
        if os.path.basename(p) == target_name:
            _make_executable(p)
            return p

    # If single file, use it
    if len(extracted_paths) == 1:
        _make_executable(extracted_paths[0])
        return extracted_paths[0]

    # Otherwise choose first file (stable sort)
    extracted_paths.sort()
    _make_executable(extracted_paths[0])
    return extracted_paths[0]


def _atomic_replace(src_path: str, dst_path: str) -> None:
    dst_dir = os.path.dirname(dst_path) or "."
    os.makedirs(dst_dir, exist_ok=True)

    # Preserve mode if possible
    with contextlib.suppress(OSError):
        dst_mode = os.stat(dst_path).st_mode
        os.chmod(src_path, dst_mode)

    os.replace(src_path, dst_path)
    with contextlib.suppress(OSError):
        _make_executable(dst_path)


def _spawn_detached(cmd, *, cwd=None) -> None:
    kwargs = {"cwd": cwd}
    if os.name == "nt":
        kwargs["creationflags"] = subprocess.CREATE_NEW_PROCESS_GROUP | subprocess.DETACHED_PROCESS  # type: ignore[attr-defined]
        kwargs["close_fds"] = True
        subprocess.Popen(cmd, **kwargs)
    else:
        kwargs["start_new_session"] = True
        subprocess.Popen(cmd, **kwargs)


def _stage_windows_replace_and_restart(current_exe: str, new_exe: str, pid: int, restart: bool) -> None:
    """
    Creates and runs a temporary .bat script that waits for the current PID to exit,
    replaces the executable, then restarts the app.
    """
    temp_dir = tempfile.mkdtemp(prefix="app-update-")
    bat_path = os.path.join(temp_dir, "apply_update.bat")

    current_exe_q = f'"{current_exe}"'
    new_exe_q = f'"{new_exe}"'

    # Use tasklist to wait; avoid relying on ping timing.
    # Also: copy then move to reduce chance of partial replace if antivirus holds file.
    lines = [
        "@echo off",
        "setlocal enabledelayedexpansion",
        f"set PID={pid}",
        f"set CURRENT={current_exe_q}",
        f"set NEW={new_exe_q}",
        "",
        ":waitloop",
        "for /f \"tokens=2 delims=,\" %%a in ('tasklist /fi \"PID eq %PID%\" /fo csv /nh 2^>nul') do set FOUND=%%~a",
        "if not \"%FOUND%\"==\"\" (",
        "  set FOUND=",
        "  timeout /t 1 /nobreak >nul",
        "  goto waitloop",
        ")",
        "",
        "timeout /t 1 /nobreak >nul",
        "copy /y %NEW% %CURRENT% >nul",
    ]
    if restart:
        lines += [
            "start \"\" %CURRENT%",
        ]
    lines += [
        "del /f /q %NEW% >nul 2>nul",
        f"rmdir /s /q \"{temp_dir}\" >nul 2>nul",
        "endlocal",
    ]

    with open(bat_path, "w", encoding="utf-8", newline="\r\n") as f:
        f.write("\r\n".join(lines) + "\r\n")

    _spawn_detached(["cmd.exe", "/c", bat_path], cwd=temp_dir)


def _stage_posix_replace_and_restart(current_exe: str, new_exe: str, pid: int, restart: bool) -> None:
    temp_dir = tempfile.mkdtemp(prefix="app-update-")
    sh_path = os.path.join(temp_dir, "apply_update.sh")

    # On POSIX we can usually overwrite/rename in-place even while running, but we
    # still wait for the process to exit to avoid surprising behavior.
    script = f"""#!/bin/sh
set -eu

PID="{pid}"
CURRENT="{current_exe}"
NEW="{new_exe}"

# Wait for PID to exit
while kill -0 "$PID" 2>/dev/null; do
  sleep 1
done

# Small delay for OS/file locks to settle
sleep 1

# Replace atomically
mv -f "$NEW" "$CURRENT"
chmod +x "$CURRENT" || true

"""
    if restart:
        script += f'exec "$CURRENT" &\n'
    script += f"""
rm -f "$NEW" >/dev/null 2>&1 || true
rm -rf "{temp_dir}" >/dev/null 2>&1 || true
"""

    with open(sh_path, "w", encoding="utf-8") as f:
        f.write(script)

    os.chmod(sh_path, 0o700)
    _spawn_detached([sh_path], cwd=temp_dir)


def auto_update(
    metadata_url: str,
    current_version: str,
    *,
    executable_path: Optional[str] = None,
    timeout: float = 30.0,
    download_timeout: float = 120.0,
    restart_after_update: bool = True,
    allow_downgrade: bool = False,
    user_agent: str = "AutoUpdater/1.0",
) -> UpdateResult:
    """
    Checks a remote server for latest version, downloads update package, and stages update
    by replacing the current executable.

    Expected metadata JSON:
      {
        "version": "1.2.3",
        "url": "https://example.com/downloads/app-1.2.3.exe" or ".zip",
        "sha256": "<hex>",               # optional, recommended
        "format": "binary" | "zip"       # optional, default "binary"
      }

    Notes:
      - On Windows, replacement is staged via a temporary .bat script, since a running
        executable cannot be overwritten. The caller should exit after receiving staged=True.
      - On POSIX, replacement is staged via a temporary shell script (safe and consistent).
    """
    if not executable_path:
        executable_path = sys.executable

    executable_path = os.path.abspath(executable_path)
    if not os.path.isfile(executable_path):
        raise UpdateError(f"Executable not found: {executable_path}")

    meta = _http_get_json(metadata_url, timeout=timeout, user_agent=user_agent)
    info = _validate_update_info(meta)

    if not allow_downgrade and not _is_newer(info.version, current_version):
        return UpdateResult(
            updated=False,
            staged=False,
            message="No update available",
            old_version=current_version,
            new_version=info.version,
        )

    # Create a staging directory
    staging_dir = tempfile.mkdtemp(prefix="app-update-download-")
    try:
        parsed = urllib.parse.urlparse(info.url)
        name = os.path.basename(parsed.path) or "update.pkg"
        download_path = os.path.join(staging_dir, name)

        _download_file(info.url, download_path, timeout=download_timeout, user_agent=user_agent)

        if info.sha256:
            got = _sha256_file(download_path)
            if got.lower() != info.sha256.lower():
                raise UpdateError(f"SHA-256 mismatch (expected {info.sha256}, got {got})")

        # Prepare replacement candidate path (binary)
        if info.format == "zip" or download_path.lower().endswith(".zip"):
            extract_dir = tempfile.mkdtemp(prefix="app-update-extract-")
            try:
                new_exe_path = _extract_update_zip(download_path, executable_path, extract_dir)
                # Move extracted exe into staging dir with a stable name
                staged_new_path = os.path.join(staging_dir, f"new_{os.path.basename(executable_path)}")
                shutil.move(new_exe_path, staged_new_path)
                new_exe_path = staged_new_path
            finally:
                with contextlib.suppress(Exception):
                    shutil.rmtree(extract_dir, ignore_errors=True)
        else:
            new_exe_path = os.path.join(staging_dir, f"new_{os.path.basename(executable_path)}")
            shutil.move(download_path, new_exe_path)
            _make_executable(new_exe_path)

        # Stage replacement via helper script (works on all platforms; avoids replacing while running)
        pid = os.getpid()
        if os.name == "nt":
            _stage_windows_replace_and_restart(executable_path, new_exe_path, pid, restart_after_update)
        else:
            _stage_posix_replace_and_restart(executable_path, new_exe_path, pid, restart_after_update)

        # Do not delete staging_dir; helper needs it
        return UpdateResult(
            updated=False,
            staged=True,
            message="Update staged; exit application to apply",
            old_version=current_version,
            new_version=info.version,
            download_path=new_exe_path,
        )

    except Exception:
        with contextlib.suppress(Exception):
            shutil.rmtree(staging_dir, ignore_errors=True)
        raise
```