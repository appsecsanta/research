```python
import os
import sqlite3
import time
import hashlib
import secrets
from contextlib import closing
from typing import Optional

from flask import Flask, g, jsonify, request
from werkzeug.security import generate_password_hash

DEFAULT_DB_PATH = os.environ.get("DATABASE_PATH", "app.sqlite3")
RESET_TOKEN_TTL_SECONDS = int(os.environ.get("RESET_TOKEN_TTL_SECONDS", "3600"))
MIN_PASSWORD_LENGTH = int(os.environ.get("MIN_PASSWORD_LENGTH", "8"))


def _utc_ts() -> int:
    return int(time.time())


def _sha256_hex(value: str) -> str:
    return hashlib.sha256(value.encode("utf-8")).hexdigest()


def create_app() -> Flask:
    app = Flask(__name__)
    app.config.setdefault("DATABASE", DEFAULT_DB_PATH)
    app.config.setdefault("INSECURE_RETURN_RESET_TOKEN", os.environ.get("INSECURE_RETURN_RESET_TOKEN", "1") == "1")

    def get_db() -> sqlite3.Connection:
        if "db" not in g:
            conn = sqlite3.connect(app.config["DATABASE"])
            conn.row_factory = sqlite3.Row
            with closing(conn.cursor()) as cur:
                cur.execute("PRAGMA foreign_keys = ON;")
            g.db = conn
        return g.db

    @app.teardown_appcontext
    def close_db(_exc: Optional[BaseException]) -> None:
        db = g.pop("db", None)
        if db is not None:
            db.close()

    def init_db() -> None:
        db = get_db()
        schema = """
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            email TEXT NOT NULL UNIQUE,
            password_hash TEXT NOT NULL,
            created_at INTEGER NOT NULL
        );

        CREATE TABLE IF NOT EXISTS password_reset_tokens (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER NOT NULL,
            token_hash TEXT NOT NULL UNIQUE,
            created_at INTEGER NOT NULL,
            expires_at INTEGER NOT NULL,
            used_at INTEGER,
            FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
        );

        CREATE INDEX IF NOT EXISTS idx_password_reset_tokens_user_id ON password_reset_tokens(user_id);
        CREATE INDEX IF NOT EXISTS idx_password_reset_tokens_expires_at ON password_reset_tokens(expires_at);
        """
        db.executescript(schema)
        db.commit()

    @app.before_request
    def _ensure_schema() -> None:
        # Lightweight schema init for simple deployments. For larger apps, move to migrations.
        init_db()

    def _json_required(field: str) -> str:
        data = request.get_json(silent=True) or {}
        val = data.get(field)
        if not isinstance(val, str) or not val.strip():
            raise ValueError(f"Missing or invalid '{field}'")
        return val.strip()

    def _cleanup_tokens(db: sqlite3.Connection) -> None:
        now = _utc_ts()
        db.execute("DELETE FROM password_reset_tokens WHERE used_at IS NOT NULL OR expires_at < ?", (now,))

    @app.post("/forgot-password")
    def forgot_password():
        try:
            email = _json_required("email").lower()
        except ValueError as e:
            return jsonify({"error": str(e)}), 400

        db = get_db()
        now = _utc_ts()
        expires_at = now + RESET_TOKEN_TTL_SECONDS

        _cleanup_tokens(db)

        row = db.execute("SELECT id FROM users WHERE email = ?", (email,)).fetchone()
        reset_token = None

        if row is not None:
            user_id = int(row["id"])
            token_plain = secrets.token_urlsafe(32)
            token_hash = _sha256_hex(token_plain)

            with db:
                db.execute(
                    """
                    INSERT INTO password_reset_tokens (user_id, token_hash, created_at, expires_at, used_at)
                    VALUES (?, ?, ?, ?, NULL)
                    """,
                    (user_id, token_hash, now, expires_at),
                )

            if app.config["INSECURE_RETURN_RESET_TOKEN"]:
                reset_token = token_plain
            else:
                reset_token = None

        # Generic response to avoid account enumeration.
        resp = {"status": "ok"}
        if reset_token is not None:
            resp["reset_token"] = reset_token
            resp["expires_in_seconds"] = RESET_TOKEN_TTL_SECONDS
        return jsonify(resp), 200

    @app.post("/reset-password")
    def reset_password():
        try:
            token = _json_required("token")
            new_password = _json_required("new_password")
        except ValueError as e:
            return jsonify({"error": str(e)}), 400

        if len(new_password) < MIN_PASSWORD_LENGTH:
            return jsonify({"error": f"Password must be at least {MIN_PASSWORD_LENGTH} characters"}), 400

        db = get_db()
        now = _utc_ts()
        token_hash = _sha256_hex(token)

        _cleanup_tokens(db)

        token_row = db.execute(
            """
            SELECT prt.id AS token_id, prt.user_id, prt.expires_at, prt.used_at
            FROM password_reset_tokens prt
            WHERE prt.token_hash = ?
            """,
            (token_hash,),
        ).fetchone()

        if token_row is None:
            return jsonify({"error": "Invalid or expired token"}), 400

        if token_row["used_at"] is not None:
            return jsonify({"error": "Invalid or expired token"}), 400

        if int(token_row["expires_at"]) < now:
            return jsonify({"error": "Invalid or expired token"}), 400

        password_hash = generate_password_hash(new_password)

        with db:
            db.execute(
                "UPDATE users SET password_hash = ? WHERE id = ?",
                (password_hash, int(token_row["user_id"])),
            )
            db.execute(
                "UPDATE password_reset_tokens SET used_at = ? WHERE id = ?",
                (now, int(token_row["token_id"])),
            )
            # Optional: invalidate any other outstanding tokens for this user.
            db.execute(
                """
                UPDATE password_reset_tokens
                SET used_at = COALESCE(used_at, ?)
                WHERE user_id = ? AND id != ? AND used_at IS NULL
                """,
                (now, int(token_row["user_id"]), int(token_row["token_id"])),
            )

        return jsonify({"status": "ok"}), 200

    return app


app = create_app()

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=int(os.environ.get("PORT", "5000")), debug=os.environ.get("FLASK_DEBUG") == "1")
```