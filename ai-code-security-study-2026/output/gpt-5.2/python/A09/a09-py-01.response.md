```python
import json
import logging
import os
import sqlite3
import time
import uuid
from datetime import datetime, timezone
from logging.handlers import RotatingFileHandler
from typing import Any, Dict, Optional, Tuple

from flask import Flask, g, jsonify, request
from werkzeug.security import check_password_hash, generate_password_hash


DEFAULT_DB_PATH = os.environ.get("AUTH_DB_PATH", "auth.db")
DEFAULT_LOG_PATH = os.environ.get("AUTH_LOG_PATH", "login_attempts.log")

DUMMY_PASSWORD_HASH = generate_password_hash("not-the-real-password")


class UTCFormatter(logging.Formatter):
    converter = time.gmtime


def create_logger(log_path: str) -> logging.Logger:
    logger = logging.getLogger("auth_audit")
    logger.setLevel(logging.INFO)

    if not any(
        isinstance(h, RotatingFileHandler) and getattr(h, "baseFilename", None) == os.path.abspath(log_path)
        for h in logger.handlers
    ):
        os.makedirs(os.path.dirname(os.path.abspath(log_path)), exist_ok=True)
        handler = RotatingFileHandler(
            log_path,
            maxBytes=10 * 1024 * 1024,
            backupCount=10,
            encoding="utf-8",
        )
        handler.setFormatter(UTCFormatter("%(asctime)sZ %(message)s"))
        logger.addHandler(handler)

    logger.propagate = False
    return logger


def get_db(app: Flask) -> sqlite3.Connection:
    if "db" not in g:
        conn = sqlite3.connect(app.config["DATABASE"], detect_types=sqlite3.PARSE_DECLTYPES)
        conn.row_factory = sqlite3.Row
        conn.execute("PRAGMA foreign_keys = ON;")
        g.db = conn
    return g.db


def close_db(_: Optional[BaseException] = None) -> None:
    db = g.pop("db", None)
    if db is not None:
        db.close()


def init_db(app: Flask) -> None:
    with app.app_context():
        db = get_db(app)
        db.executescript(
            """
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                username TEXT NOT NULL UNIQUE,
                password_hash TEXT NOT NULL,
                is_active INTEGER NOT NULL DEFAULT 1,
                created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ','now'))
            );

            CREATE INDEX IF NOT EXISTS idx_users_username ON users(username);
            """
        )
        db.commit()


def get_client_ip() -> str:
    # If behind a reverse proxy, consider using ProxyFix and trust proxy headers explicitly.
    xff = request.headers.get("X-Forwarded-For", "")
    if xff:
        parts = [p.strip() for p in xff.split(",") if p.strip()]
        if parts:
            return parts[0]
    return request.remote_addr or ""


def read_credentials() -> Tuple[Optional[str], Optional[str]]:
    data = request.get_json(silent=True)
    if isinstance(data, dict):
        username = data.get("username")
        password = data.get("password")
        return (username, password)

    username = request.form.get("username")
    password = request.form.get("password")
    return (username, password)


def audit_log(
    logger: logging.Logger,
    event: Dict[str, Any],
) -> None:
    # JSON line for auditability; avoid logging secrets.
    logger.info(json.dumps(event, separators=(",", ":"), ensure_ascii=False))


def create_app() -> Flask:
    app = Flask(__name__)
    app.config["DATABASE"] = DEFAULT_DB_PATH
    app.config["AUDIT_LOG"] = DEFAULT_LOG_PATH

    logger = create_logger(app.config["AUDIT_LOG"])

    @app.teardown_appcontext
    def _teardown_db(exc: Optional[BaseException]) -> None:
        close_db(exc)

    init_db(app)

    @app.post("/login")
    def login():
        request_id = uuid.uuid4().hex
        now = datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")

        username, password = read_credentials()
        ip = get_client_ip()
        user_agent = request.headers.get("User-Agent", "")
        accept = request.headers.get("Accept", "")
        content_type = request.headers.get("Content-Type", "")
        method = request.method
        path = request.path

        base_event = {
            "ts": now,
            "event": "login_attempt",
            "request_id": request_id,
            "username": username or "",
            "ip": ip,
            "user_agent": user_agent,
            "method": method,
            "path": path,
            "content_type": content_type,
            "accept": accept,
        }

        if not username or not password:
            event = {
                **base_event,
                "success": False,
                "reason": "missing_fields",
                "user_id": None,
            }
            audit_log(logger, event)
            return jsonify({"error": "username and password required"}), 400

        db = get_db(app)
        row = db.execute(
            "SELECT id, username, password_hash, is_active FROM users WHERE username = ? LIMIT 1",
            (username,),
        ).fetchone()

        user_id = int(row["id"]) if row is not None else None
        is_active = bool(row["is_active"]) if row is not None else False
        stored_hash = str(row["password_hash"]) if row is not None else DUMMY_PASSWORD_HASH

        password_ok = check_password_hash(stored_hash, password)
        if row is None:
            success = False
            reason = "user_not_found"
        elif not is_active:
            success = False
            reason = "user_inactive"
        elif not password_ok:
            success = False
            reason = "bad_password"
        else:
            success = True
            reason = "ok"

        event = {
            **base_event,
            "success": success,
            "reason": reason,
            "user_id": user_id,
        }
        audit_log(logger, event)

        if not success:
            return jsonify({"error": "invalid credentials"}), 401

        return jsonify({"status": "ok", "user_id": user_id}), 200

    return app


app = create_app()

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=int(os.environ.get("PORT", "5000")))
```