```python
import base64
import json
import logging
import time
import uuid
from datetime import datetime, timezone
from logging.handlers import RotatingFileHandler
from typing import Any, Dict, Iterable, Optional, Sequence, Tuple, Union

from flask import Flask, Response, g, request
from werkzeug.http import parse_options_header
from werkzeug.wrappers import Response as WerkzeugResponse


def _utc_iso() -> str:
    return datetime.now(timezone.utc).isoformat(timespec="milliseconds")


def _parse_charset(content_type: Optional[str]) -> Optional[str]:
    if not content_type:
        return None
    _, params = parse_options_header(content_type)
    charset = params.get("charset")
    return charset.strip() if isinstance(charset, str) and charset.strip() else None


def _is_text_mimetype(mimetype: Optional[str]) -> bool:
    if not mimetype:
        return False
    mimetype = mimetype.lower()
    return (
        mimetype.startswith("text/")
        or mimetype in ("application/json", "application/xml", "application/javascript")
        or mimetype.endswith("+json")
        or mimetype.endswith("+xml")
    )


def _safe_body_representation(
    data: Optional[bytes],
    *,
    content_type: Optional[str],
    mimetype: Optional[str],
    max_bytes: Optional[int],
) -> Dict[str, Any]:
    if data is None:
        return {"bytes": 0, "truncated": False, "text": ""}

    original_len = len(data)
    truncated = False

    if max_bytes is not None and max_bytes >= 0 and len(data) > max_bytes:
        data = data[:max_bytes]
        truncated = True

    charset = _parse_charset(content_type) or "utf-8"
    text_preferred = _is_text_mimetype(mimetype)

    if text_preferred:
        try:
            return {
                "bytes": original_len,
                "truncated": truncated,
                "encoding": charset,
                "text": data.decode(charset, errors="replace"),
            }
        except Exception:
            pass

    try:
        return {
            "bytes": original_len,
            "truncated": truncated,
            "base64": base64.b64encode(data).decode("ascii"),
        }
    except Exception:
        return {"bytes": original_len, "truncated": truncated, "unavailable": True}


def _headers_to_dict(headers: Iterable[Tuple[str, str]]) -> Dict[str, Union[str, Sequence[str]]]:
    out: Dict[str, Union[str, Sequence[str]]] = {}
    multi: Dict[str, list] = {}

    for k, v in headers:
        lk = k
        if lk in out:
            if lk not in multi:
                multi[lk] = [out[lk]] if isinstance(out[lk], str) else list(out[lk])  # type: ignore[arg-type]
            multi[lk].append(v)
            out[lk] = multi[lk]
        else:
            out[lk] = v

    return out


class ApiRequestResponseLogger:
    """
    Flask middleware (implemented via hooks) to log requests and responses to a file.

    Usage:
        app = Flask(__name__)
        ApiRequestResponseLogger(app, log_file="/var/log/api-traffic.log")

    Produces one JSON object per line.
    """

    def __init__(
        self,
        app: Optional[Flask] = None,
        *,
        log_file: str = "api_traffic.log",
        logger_name: str = "api.request_response",
        max_body_bytes: Optional[int] = 1024 * 1024,
        exclude_paths: Optional[Sequence[str]] = None,
        include_response_headers: bool = True,
        include_request_headers: bool = True,
        level: int = logging.INFO,
        rotate_max_bytes: int = 50 * 1024 * 1024,
        rotate_backup_count: int = 5,
    ) -> None:
        self.log_file = log_file
        self.logger_name = logger_name
        self.max_body_bytes = max_body_bytes
        self.exclude_paths = set(exclude_paths or [])
        self.include_response_headers = include_response_headers
        self.include_request_headers = include_request_headers
        self.level = level
        self.rotate_max_bytes = rotate_max_bytes
        self.rotate_backup_count = rotate_backup_count

        self.logger = logging.getLogger(self.logger_name)
        self.logger.setLevel(self.level)
        self.logger.propagate = False

        if not any(isinstance(h, RotatingFileHandler) and getattr(h, "baseFilename", None) == log_file for h in self.logger.handlers):
            handler = RotatingFileHandler(
                filename=self.log_file,
                maxBytes=self.rotate_max_bytes,
                backupCount=self.rotate_backup_count,
                encoding="utf-8",
            )
            handler.setLevel(self.level)
            handler.setFormatter(logging.Formatter("%(message)s"))
            self.logger.addHandler(handler)

        if app is not None:
            self.init_app(app)

    def init_app(self, app: Flask) -> None:
        app.before_request(self._before_request)  # type: ignore[arg-type]
        app.after_request(self._after_request)    # type: ignore[arg-type]

    def _should_skip(self) -> bool:
        path = (request.path or "").rstrip("/") or "/"
        if path in self.exclude_paths:
            return True
        return False

    def _before_request(self) -> None:
        if self._should_skip():
            g._api_log_skip = True
            return

        g._api_log_skip = False
        g._api_log_request_id = request.headers.get("X-Request-Id") or str(uuid.uuid4())
        g._api_log_start = time.perf_counter()

        try:
            # cache=True allows reading again later without losing the stream
            g._api_log_request_body = request.get_data(cache=True, as_text=False)
        except Exception:
            g._api_log_request_body = None

    def _after_request(self, response: Response) -> Response:
        if getattr(g, "_api_log_skip", False):
            return response

        start = getattr(g, "_api_log_start", None)
        duration_ms = None
        if isinstance(start, (int, float)):
            duration_ms = round((time.perf_counter() - start) * 1000.0, 3)

        request_id = getattr(g, "_api_log_request_id", None)

        req_headers: Optional[Dict[str, Any]] = None
        if self.include_request_headers:
            try:
                req_headers = _headers_to_dict(request.headers.items())
            except Exception:
                req_headers = None

        resp_headers: Optional[Dict[str, Any]] = None
        if self.include_response_headers:
            try:
                resp_headers = _headers_to_dict(response.headers.items())
            except Exception:
                resp_headers = None

        req_body_bytes = getattr(g, "_api_log_request_body", None)
        req_body = _safe_body_representation(
            req_body_bytes,
            content_type=request.content_type,
            mimetype=request.mimetype,
            max_bytes=self.max_body_bytes,
        )

        resp_body_bytes: Optional[bytes]
        try:
            if isinstance(response, WerkzeugResponse) and getattr(response, "direct_passthrough", False):
                resp_body_bytes = None
            else:
                resp_body_bytes = response.get_data(as_text=False)
        except Exception:
            resp_body_bytes = None

        resp_body = _safe_body_representation(
            resp_body_bytes,
            content_type=response.content_type,
            mimetype=getattr(response, "mimetype", None),
            max_bytes=self.max_body_bytes,
        )

        record: Dict[str, Any] = {
            "ts": _utc_iso(),
            "request_id": request_id,
            "remote_addr": request.headers.get("X-Forwarded-For", request.remote_addr),
            "method": request.method,
            "url": request.url,
            "path": request.path,
            "query_string": request.query_string.decode("utf-8", errors="replace") if request.query_string else "",
            "request": {
                "headers": req_headers,
                "body": req_body,
                "content_type": request.content_type,
                "content_length": request.content_length,
            },
            "response": {
                "status_code": response.status_code,
                "status": response.status,
                "headers": resp_headers,
                "body": resp_body,
                "content_type": response.content_type,
                "content_length": response.calculate_content_length(),
            },
            "duration_ms": duration_ms,
        }

        try:
            self.logger.info(json.dumps(record, ensure_ascii=False, separators=(",", ":")))
        except Exception:
            # Never break production request flow due to logging issues
            pass

        return response
```