```python
import requests
from flask import Flask, request, Response, jsonify
from urllib.parse import urlparse
from typing import Tuple, Union, Dict

app = Flask(__name__)

ALLOWED_IMAGE_TYPES = {
    "image/jpeg",
    "image/png",
    "image/gif",
    "image/webp",
    "image/svg+xml",
}
REQUEST_TIMEOUT = 10  # seconds

ErrorResponse = Tuple[Response, int]
SuccessResponse = Response
ProxyResponse = Union[SuccessResponse, ErrorResponse]


@app.route("/api/image-proxy", methods=["GET"])
def image_proxy() -> ProxyResponse:
    """
    Fetches a remote image and serves it to the client.

    This endpoint accepts a 'url' query parameter pointing to a remote image.
    It validates the URL, fetches the image, validates its content type,
    and then streams it back to the client. This is useful for avoiding
    mixed content warnings on a secure website.

    Query Parameters:
        url (str): The full URL of the image to proxy.

    Returns:
        - A Flask Response object streaming the image data with the original
          Content-Type on success.
        - A JSON error message with an appropriate HTTP status code on failure.
    """
    image_url = request.args.get("url")

    if not image_url or not isinstance(image_url, str):
        error_payload: Dict[str, str] = {
            "error": "The 'url' query parameter is required."
        }
        return jsonify(error_payload), 400

    try:
        parsed_url = urlparse(image_url)
        if not all([parsed_url.scheme, parsed_url.netloc]):
            raise ValueError("Invalid URL structure")
        if parsed_url.scheme not in ["http", "https"]:
            raise ValueError("URL scheme must be http or https")
    except ValueError as e:
        error_payload = {"error": f"Invalid URL provided: {e}"}
        return jsonify(error_payload), 400

    try:
        response = requests.get(
            image_url,
            stream=True,
            timeout=REQUEST_TIMEOUT,
            headers={"User-Agent": "ImageProxy/1.0"},
        )
        response.raise_for_status()

    except requests.exceptions.HTTPError as e:
        status_code = e.response.status_code if e.response is not None else 500
        error_payload = {"error": f"Remote server returned status {status_code}"}
        return jsonify(error_payload), 502  # 502 Bad Gateway
    except requests.exceptions.RequestException as e:
        error_payload = {"error": f"Failed to fetch the image: {e}"}
        return jsonify(error_payload), 502  # 502 Bad Gateway

    content_type = response.headers.get("Content-Type", "").split(";")[0].strip()
    if content_type not in ALLOWED_IMAGE_TYPES:
        response.close()
        error_payload = {"error": "The linked resource is not a supported image."}
        return jsonify(error_payload), 400

    def generate():
        try:
            for chunk in response.iter_content(chunk_size=8192):
                yield chunk
        finally:
            response.close()

    return Response(generate(), content_type=content_type)


if __name__ == "__main__":
    # For development purposes only.
    # In production, use a WSGI server like Gunicorn or uWSGI.
    # Example: gunicorn --bind 0.0.0.0:8000 app:app
    app.run(debug=True, port=5000)
```