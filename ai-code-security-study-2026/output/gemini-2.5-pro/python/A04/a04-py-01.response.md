```python
import os
import secrets
from datetime import datetime, timedelta, timezone

from flask import Flask, jsonify, request
from flask_sqlalchemy import SQLAlchemy
from werkzeug.security import generate_password_hash, check_password_hash

# --- Configuration ---
basedir = os.path.abspath(os.path.dirname(__file__))
DB_PATH = os.path.join(basedir, "app.db")
TOKEN_EXPIRATION_HOURS = 1

# --- App Initialization ---
app = Flask(__name__)
app.config["SQLALCHEMY_DATABASE_URI"] = f"sqlite:///{DB_PATH}"
app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
db = SQLAlchemy(app)


# --- Models ---
class User(db.Model):
    """User model for storing user details."""
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(256), nullable=False)

    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)


class PasswordResetToken(db.Model):
    """Token model for password reset functionality."""
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    token = db.Column(db.String(128), unique=True, nullable=False)
    expires_at = db.Column(db.DateTime, nullable=False)

    user = db.relationship('User')


# --- Helper Routes for Testing ---
@app.route("/register", methods=["POST"])
def register():
    """A simple route to create a user for testing purposes."""
    data = request.get_json()
    if not data or not data.get("email") or not data.get("password"):
        return jsonify({"error": "Email and password are required"}), 400

    if User.query.filter_by(email=data["email"]).first():
        return jsonify({"error": "Email address already registered"}), 409

    user = User(email=data["email"])
    user.set_password(data["password"])
    db.session.add(user)
    db.session.commit()

    return jsonify({"message": f"User {user.email} created successfully"}), 201


# --- Password Reset Flow ---
@app.route("/forgot-password", methods=["POST"])
def forgot_password():
    """
    Initiates the password reset process.
    Accepts an email, generates a reset token, and stores it.
    """
    data = request.get_json()
    if not data or not data.get("email"):
        return jsonify({"error": "Email is required"}), 400

    email = data["email"]
    user = User.query.filter_by(email=email).first()

    # To prevent user enumeration, always return a success-like message.
    # The actual token generation and sending (e.g., via email) happens only if the user exists.
    if user:
        # Invalidate any existing tokens for this user
        PasswordResetToken.query.filter_by(user_id=user.id).delete()

        token = secrets.token_urlsafe(64)
        expires_at = datetime.now(timezone.utc) + timedelta(hours=TOKEN_EXPIRATION_HOURS)

        reset_token = PasswordResetToken(
            user_id=user.id, token=token, expires_at=expires_at
        )
        db.session.add(reset_token)
        db.session.commit()

        # In a real application, you would send an email with the reset link/token here.
        # For this example, we return the token in the response for demonstration.
        print(f"Password reset token for {email}: {token}")
        return jsonify({
            "message": "If an account with that email exists, a password reset token has been generated.",
            "token_for_testing": token
        }), 200

    return jsonify({
        "message": "If an account with that email exists, a password reset token has been generated."
    }), 200


@app.route("/reset-password", methods=["POST"])
def reset_password():
    """
    Resets the user's password using a valid token.
    Accepts a token and a new password.
    """
    data = request.get_json()
    if not data or not data.get("token") or not data.get("new_password"):
        return jsonify({"error": "Token and new_password are required"}), 400

    token_str = data["token"]
    new_password = data["new_password"]

    reset_token = PasswordResetToken.query.filter_by(token=token_str).first()

    if not reset_token:
        return jsonify({"error": "Invalid or expired token"}), 400

    if datetime.now(timezone.utc) > reset_token.expires_at:
        db.session.delete(reset_token)
        db.session.commit()
        return jsonify({"error": "Invalid or expired token"}), 400

    user = reset_token.user
    if not user:
        # This case should be rare due to foreign key constraints
        db.session.delete(reset_token)
        db.session.commit()
        return jsonify({"error": "User not found for this token"}), 404

    user.set_password(new_password)
    db.session.delete(reset_token)  # Invalidate the token after use
    db.session.commit()

    return jsonify({"message": "Password has been reset successfully"}), 200


if __name__ == "__main__":
    with app.app_context():
        db.create_all()
    app.run(debug=True, port=5001)
```