```python
import secrets
from datetime import datetime, timedelta, timezone
from typing import Dict, Optional, Any

# In a real application, this would be a connection to a database like
# PostgreSQL, MySQL, or a NoSQL database. For this example, we'll use
# a simple in-memory dictionary to simulate a database table.
mock_db: Dict[str, Dict[str, Any]] = {
    "password_reset_tokens": {}
}


def generate_password_reset_token(
    user_email: str,
    db: Dict[str, Any],
    expires_delta: timedelta = timedelta(hours=1)
) -> str:
    """
    Generates a secure, unique token for a password reset request.

    This function creates a token, calculates its expiration time, and stores
    it in the database, associated with the user's email. It ensures that
    any previous tokens for the same user are invalidated.

    Args:
        user_email: The email address of the user requesting the reset.
        db: A dictionary simulating the application's database.
        expires_delta: The duration for which the token will be valid.
                       Defaults to 1 hour.

    Returns:
        The generated URL-safe token string.
    """
    # Invalidate any existing tokens for this user to prevent misuse
    tokens_table = db["password_reset_tokens"]
    existing_tokens = [
        token for token, data in tokens_table.items()
        if data["user_email"] == user_email
    ]
    for token in existing_tokens:
        del tokens_table[token]

    # Generate a cryptographically secure, URL-safe token
    token = secrets.token_urlsafe(32)
    
    # Calculate the expiration timestamp
    expires_at = datetime.now(timezone.utc) + expires_delta

    # Store the token information in the database
    token_data = {
        "user_email": user_email,
        "expires_at": expires_at
    }
    tokens_table[token] = token_data

    return token


def validate_password_reset_token(token: str, db: Dict[str, Any]) -> Optional[str]:
    """
    Validates a password reset token.

    This function checks if the token exists in the database, is not expired,
    and then invalidates it to ensure it can only be used once.

    Args:
        token: The token string provided by the user.
        db: A dictionary simulating the application's database.

    Returns:
        The user's email address if the token is valid, otherwise None.
    """
    tokens_table = db["password_reset_tokens"]
    
    token_data = tokens_table.get(token)

    if not token_data:
        return None

    # Ensure the token is immediately invalidated to prevent reuse
    del tokens_table[token]

    expires_at = token_data.get("expires_at")
    if not expires_at or datetime.now(timezone.utc) > expires_at:
        return None

    return token_data.get("user_email")


if __name__ == '__main__':
    # --- Example Usage ---

    # 1. A user requests a password reset.
    user_email_address = "test.user@example.com"
    print(f"User '{user_email_address}' requested a password reset.")
    
    # 2. Generate a token and store it in the database.
    #    In a real app, you would email this token to the user in a link.
    generated_token = generate_password_reset_token(user_email_address, mock_db)
    print(f"Generated token: {generated_token}")
    print(f"Database state after generation: {mock_db}\n")

    # 3. The user clicks the link, and the application validates the token.

    # --- Scenario A: Valid Token ---
    print("--- Scenario A: Validating a correct and unexpired token ---")
    validated_email = validate_password_reset_token(generated_token, mock_db)
    if validated_email:
        print(f"Token is valid for user: {validated_email}")
        print("Proceed with allowing the user to reset their password.")
    else:
        print("Token is invalid or expired.")
    print(f"Database state after validation (token should be removed): {mock_db}\n")

    # --- Scenario B: Invalid (already used) Token ---
    print("--- Scenario B: Attempting to use the same token again ---")
    # Regenerate a token for the next scenarios
    generated_token = generate_password_reset_token(user_email_address, mock_db)
    validate_password_reset_token(generated_token, mock_db) # Use it once
    
    # Try to use it again
    validated_email_again = validate_password_reset_token(generated_token, mock_db)
    if validated_email_again:
        print(f"Token is valid for user: {validated_email_again}")
    else:
        print("Token is invalid or expired (as expected).")
    print(f"Database state: {mock_db}\n")

    # --- Scenario C: Expired Token ---
    print("--- Scenario C: Validating an expired token ---")
    # Generate a token with a very short lifespan (negative delta means expired)
    expired_token = generate_password_reset_token(
        user_email_address, mock_db, expires_delta=timedelta(seconds=-1)
    )
    validated_email_expired = validate_password_reset_token(expired_token, mock_db)
    if validated_email_expired:
        print(f"Token is valid for user: {validated_email_expired}")
    else:
        print("Token is invalid or expired (as expected).")
    print(f"Database state: {mock_db}\n")

    # --- Scenario D: Non-existent Token ---
    print("--- Scenario D: Validating a non-existent token ---")
    validated_email_fake = validate_password_reset_token("fake-token-string", mock_db)
    if validated_email_fake:
        print(f"Token is valid for user: {validated_email_fake}")
    else:
        print("Token is invalid (as expected).")
    print(f"Database state: {mock_db}\n")
```