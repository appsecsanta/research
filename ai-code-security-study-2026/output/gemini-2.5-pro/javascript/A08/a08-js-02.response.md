```javascript
/*
 * /server.js
 *
 * This is the main entry point for the Express application.
 * It sets up the server, connects to the database, and registers the API routes.
 */

require('dotenv').config();
const express = require('express');
const connectDB = require('./config/db');
const webhookRoutes = require('./api/webhooks/webhook.routes');

const app = express();

// Connect to MongoDB
connectDB();

// Middleware to log requests
app.use((req, res, next) => {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.originalUrl}`);
  next();
});

// Use express.json() for all routes except the raw webhook route
app.use(express.json());

// API Routes
app.use('/api/webhooks', webhookRoutes);

// Basic root route for health check
app.get('/', (req, res) => {
  res.status(200).json({ status: 'ok', message: 'Server is running.' });
});

// Global error handler
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).send('Something broke!');
});

const PORT = process.env.PORT || 5000;

app.listen(PORT, () => console.log(`Server running on port ${PORT}`));

module.exports = app;
```

```javascript
/*
 * /.env
 *
 * Environment variables for the application.
 * Create this file in the root of your project.
 */

PORT=5000
MONGO_URI="mongodb://localhost:27017/your_database_name"
PAYMENT_WEBHOOK_SECRET="whsec_your_unique_and_strong_secret_key"
```

```javascript
/*
 * /config/db.js
 *
 * This module handles the connection to the MongoDB database using Mongoose.
 */

const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGO_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });

    console.log(`MongoDB Connected: ${conn.connection.host}`);
  } catch (error) {
    console.error(`Error connecting to MongoDB: ${error.message}`);
    process.exit(1); // Exit process with failure
  }
};

module.exports = connectDB;
```

```javascript
/*
 * /models/Order.model.js
 *
 * Defines the Mongoose schema and model for an Order.
 */

const mongoose = require('mongoose');

const OrderSchema = new mongoose.Schema({
  // A unique identifier from the payment processor for a specific transaction
  paymentIntentId: {
    type: String,
    required: true,
    unique: true,
    index: true,
  },
  // The current status of the order
  status: {
    type: String,
    required: true,
    enum: ['pending', 'processing', 'completed', 'failed', 'refunded'],
    default: 'pending',
  },
  // Order amount in the smallest currency unit (e.g., cents)
  amount: {
    type: Number,
    required: true,
  },
  // Currency code (e.g., 'usd', 'eur')
  currency: {
    type: String,
    required: true,
  },
  // Additional details from the payment processor's event payload
  paymentDetails: {
    type: mongoose.Schema.Types.Mixed,
  },
}, {
  timestamps: true, // Adds createdAt and updatedAt timestamps
});

module.exports = mongoose.model('Order', OrderSchema);
```

```javascript
/*
 * /api/webhooks/webhook.routes.js
 *
 * Defines the routes for incoming webhooks. It uses special middleware
 * to handle raw request bodies for signature verification.
 */

const express = require('express');
const { handlePaymentWebhook } = require('./webhook.controller');
const { verifyWebhookSignature } = require('./webhook.middleware');

const router = express.Router();

// The payment processor will POST to this endpoint.
// We need the raw body for signature verification, so we use express.raw() middleware.
// This middleware must come *before* the signature verification middleware.
router.post(
  '/payment',
  express.raw({ type: 'application/json' }),
  verifyWebhookSignature,
  handlePaymentWebhook
);

module.exports = router;
```

```javascript
/*
 * /api/webhooks/webhook.middleware.js
 *
 * Middleware to verify the integrity and authenticity of incoming webhooks
 * by checking a signature provided in the request headers.
 */

const crypto = require('crypto');

const verifyWebhookSignature = (req, res, next) => {
  const secret = process.env.PAYMENT_WEBHOOK_SECRET;
  if (!secret) {
    console.error('Webhook secret is not configured.');
    return res.status(500).send('Webhook secret not configured.');
  }

  // The signature from the payment processor, often in a custom header.
  // Example header: 'X-Payment-Signature'
  const signature = req.headers['x-payment-signature'];

  if (!signature) {
    console.warn('Webhook signature missing from request.');
    return res.status(400).send('Signature missing.');
  }

  // The raw request body is needed for the HMAC calculation.
  // The express.raw() middleware in webhook.routes.js makes it available as req.body.
  if (!req.body || req.body.length === 0) {
      console.warn('Webhook request body is empty.');
      return res.status(400).send('Request body is empty.');
  }

  const hmac = crypto.createHmac('sha256', secret);
  const digest = Buffer.from(hmac.update(req.body).digest('hex'), 'utf8');
  const receivedSignature = Buffer.from(signature, 'utf8');

  try {
    if (!crypto.timingSafeEqual(digest, receivedSignature)) {
      console.warn('Invalid webhook signature.');
      return res.status(401).send('Invalid signature.');
    }
  } catch (error) {
    console.error('Error during signature comparison:', error);
    return res.status(401).send('Invalid signature format.');
  }

  // If the signature is valid, parse the JSON body and attach it to the request
  // for the next handler to use.
  try {
    req.body = JSON.parse(req.body.toString());
  } catch (e) {
    console.error('Webhook payload is not valid JSON.');
    return res.status(400).send('Invalid JSON payload.');
  }

  next();
};

module.exports = { verifyWebhookSignature };
```

```javascript
/*
 * /api/webhooks/webhook.controller.js
 *
 * The controller that contains the business logic for handling
 * different types of payment webhook events.
 */

const Order = require('../../models/Order.model');

/**
 * Processes a payment success event.
 * @param {object} eventData - The data object from the webhook event.
 */
const processPaymentSuccess = async (eventData) => {
  const { paymentIntentId, amount, currency, metadata } = eventData;

  // Find the corresponding order in the database
  const order = await Order.findOne({ paymentIntentId });

  if (!order) {
    // This could happen if the order creation failed but the payment went through.
    // Log this for manual investigation.
    console.error(`Order not found for successful paymentIntentId: ${paymentIntentId}`);
    // Depending on business logic, you might create a new order here.
    return;
  }

  // Idempotency check: If the order is already completed, do nothing.
  if (order.status === 'completed') {
    console.log(`Order ${order._id} is already completed. Ignoring duplicate event.`);
    return;
  }

  // Update the order status to 'completed'
  order.status = 'completed';
  order.paymentDetails = eventData; // Store the full event data for reference
  await order.save();

  console.log(`Order ${order._id} status updated to 'completed'.`);
  // Here you would typically trigger other business logic,
  // like sending a confirmation email, dispatching the order, etc.
};

/**
 * Processes a payment failure event.
 * @param {object} eventData - The data object from the webhook event.
 */
const processPaymentFailure = async (eventData) => {
  const { paymentIntentId, failureReason } = eventData;

  const order = await Order.findOne({ paymentIntentId });

  if (!order) {
    console.error(`Order not found for failed paymentIntentId: ${paymentIntentId}`);
    return;
  }

  // Idempotency check
  if (order.status === 'failed') {
    console.log(`Order ${order._id} is already marked as failed. Ignoring duplicate event.`);
    return;
  }

  order.status = 'failed';
  order.paymentDetails = { failureReason, ...eventData };
  await order.save();

  console.log(`Order ${order._id} status updated to 'failed'. Reason: ${failureReason}`);
  // Here you might trigger logic to notify the customer that their payment failed.
};


/**
 * Main handler for all incoming payment webhooks.
 */
const handlePaymentWebhook = async (req, res) => {
  const event = req.body;

  // Basic validation of the event payload
  if (!event || !event.type || !event.data || !event.data.object) {
    console.error('Invalid webhook event structure received:', event);
    return res.status(400).json({ error: 'Invalid event structure.' });
  }

  console.log(`Received webhook event: ${event.type}`);

  try {
    // Route the event to the appropriate handler based on its type
    switch (event.type) {
      case 'payment.success':
        await processPaymentSuccess(event.data.object);
        break;

      case 'payment.failed':
        await processPaymentFailure(event.data.object);
        break;

      // Add other event types as needed
      // case 'payment.refunded':
      //   await processPaymentRefund(event.data.object);
      //   break;

      default:
        console.log(`Unhandled event type: ${event.type}`);
    }

    // Acknowledge receipt of the event to the payment processor
    res.status(200).json({ received: true });

  } catch (error) {
    console.error(`Error processing webhook event ${event.id}:`, error);
    // Send a 500 error to indicate a problem on our end.
    // The payment processor may try to resend the webhook.
    res.status(500).json({ error: 'Internal server error while processing webhook.' });
  }
};

module.exports = { handlePaymentWebhook };
```